# ===============================================
# Comparing two ways of imputing missing SNP data
# ===============================================

# 23/01/2023

# In this simulated example, individuals belong to different gene pools (ie genetic clusters).
# The main gene pool of an individual is defined as the gene pool for which that individual has the highest proportion of assignment.
# I want to impute missing data based on the most frequent allele within the main gene pool of each individual.


library(tidyverse)
library(gtools)
library(magrittr)
library(tictoc)

set.seed(485)


# Data simulation
# ===============

# Not realistic at all, but will do the job :D

gp_nb <- 6 # Number of gene pools
ind_nb <- 10 # Number of individuals in each gene pool
snp_nb <- 100 # number of genetic markers (ie SNPs)


# Function to generate a vector of allele counts with some NAs
generate_allele_counts <- function(x){
  
  vec <- sapply(1:gp_nb, function(x) c(0,1,2) %>% 
                  sample(ind_nb, replace = TRUE, prob=as.vector(rdirichlet(1,c(1/3,1/3,1/3))))) %>% 
    as.vector() 
  
  na_nb <- rbinom(n=1,size=60,prob=0.05)
  na_id <- sample(1:(gp_nb*ind_nb),na_nb,replace=F)
  vec[na_id] <- NA
  
  return(vec)
  
}

# Generate the fake genomic dataset
df <- sapply(1:snp_nb, generate_allele_counts) %>% 
  as.data.frame() %>% 
  set_colnames(paste0("snp",1:snp_nb))


# Attribute individual and gene pool ID
df <- data.frame(individual=paste0("i",1:(gp_nb*10)), 
                 gene_pool=sapply(1:gp_nb, function(x) rep(paste0("gp",x),ind_nb)) %>% as.vector()) %>% 
  bind_cols(df)



# Using a loop for to impute missing data
# =======================================

dfloop <- df
  
tic("Loop")
for(i in unique(dfloop$gene_pool)){
    subset <- dfloop[dfloop$gene_pool==i,]
    subset <- apply(subset[,3:ncol(subset)], 2, function(x) replace(x, is.na(x), as.numeric(names(which.max(table(x))))))
    dfloop[dfloop$gene_pool==i,3:ncol(dfloop)] <- subset
}
toc()



# Using tidyverse functions for to impute missing data
# ====================================================


tic("Tidyverse (loooooser)")
dftidy <- df %>% 
  group_by(gene_pool) %>% 
  mutate_if(is.numeric,~replace_na(.,as.numeric(names(which.max(table(.)))))) 
toc()

# Comment: I get the following warning message: `mutate_if()` ignored the following grouping variables: Column `gene_pool`
# But, it actually does not ignore it.
# It is discussed in the following issue:
# https://github.com/tidyverse/dplyr/issues/4572
# To note, they say in the issue that across(), contrarily to mutate_if(), ignores the grouping variables.

# We check that the two datasets generated by the two functions are identical.
identical(as.data.frame(dftidy),dfloop) # that's ok :)


# first pipes I tried (= how to make life difficult)

tic("Tidyverse")
dftidy_mapdfr <- df %>% 
  group_by(gene_pool) %>% 
  group_split() %>% 
  map_dfr(function(gene_pool){ # map_dfr is superseded
    gene_pool %>% 
      mutate_if(is.numeric, ~replace_na(.,as.numeric(names(which.max(table(.))))))
  })
toc()


# The function map_dfr() is superseded
# R docs advises to use map() or modify() instead with list_rbind(), which I do below

tic("Tidyverse")
dftidy_modify <- df %>% 
  group_by(gene_pool) %>% 
  group_split() %>% 
  modify(\(gene_pool){
    gene_pool %>% 
      mutate_if(is.numeric, ~replace_na(.,as.numeric(names(which.max(table(.))))))
  }) %>% 
  list_rbind()
toc()





# Conclusion
# ==========

# In my small example (but this is also the case with my true data), imputing missing data is much faster with the for loop!
# But, why??? 

# My explanation attempt: 
# The for loop slips the dataframes in different subsets stored in different objects, so then it is quicker to work on these smaller objects.
# whereas the tidyverse pipe stores a list of dataframes (so one object) and so it is longer to find and replace information in this big object
# Ok, well, after writing it, I find this explanation very very wobbly X)
