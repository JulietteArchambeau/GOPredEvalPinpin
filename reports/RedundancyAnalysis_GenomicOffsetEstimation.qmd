---
title: "RDA analysis"
subtitle: "Genomic offset predictions"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    toc: true
    toc-depth: 4
    code-fold: true
    page-layout: full
embed-resources: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body {
   font-size: 15px;
}
code.r{
  font-size: 11px;
}
pre {
  font-size: 11px
}

table {
  font-size: 11px
}
</style>

```{r setup, include=F}
knitr::opts_chunk$set(dev.args = list(png = list(type = "cairo")))
knitr::opts_chunk$set(cache=F, size="tiny")
options(width = 300)
library(knitr)      # CRAN v1.26
library(kableExtra) # CRAN v1.1.0
library(tidyverse)
library(vegan)
library(here)
library(cowplot)
library(magrittr)
library(rnaturalearthdata)
library(rnaturalearth)
library(sf)

# my own function for building tables in reports
source(here("scripts/functions/kable_mydf.R"))
source(here("scripts/functions/extract_climatedt_metadata.R")) # extracting meta data of the climatic variables in ClimateDT
```




# Introduction

Most analyses conducted in this document are based on @capblancq2021redundancy and the associated [Github repository](https://github.com/Capblancq/RDA-landscape-genomics).


# Data

> Genomic data

```{r LoadData}
# Population-based allele frequencies
# ===================================
geno <- read.csv(here("data/DryadRepo/ImputedGenomicData_AlleleFrequencies_withoutmaf.csv"),
                     row.names = 1)

# SNP sets
# ========
snp_sets <- readRDS(here("outputs/list_snp_sets.rds"))
```

> Climatic data

```{r}
# Set of climatic variables
# =========================
clim_var <- readRDS(here("data/ClimaticData/NamesSelectedVariables.rds")) %>% 
  `[[`(3) # We keep the set 3 of climatic variables (the third list element)


# Climatic data
# =============

source(here("scripts/functions/generate_clim_datasets.R"))

clim_dfs <- generate_clim_datasets(clim_var)
```


# Adaptive landscape

> Projecting adaptive gradient(s) across space

## Adaptively enriched genetic space

The different sets of SNPs (one set of control SNPs and two sets of putative adaptive loci) are used as **multivariate response** in a new 'adaptively enriched' RDA, using the selected climatic variables as explanatory variables.


```{r FunctionToRunRDA}
runRDA <- function(snp_set, clim_var, clim_df, geno){
  
# Keep the genomic data of the selected SNPs
geno <- geno[,snp_set]
  
# RDA formula  
form_rda <- paste("geno ~ ", paste(clim_var$variables,collapse= " + "))
  
# run RDA with only the selected SNPs
rda_outliers <- rda(as.formula(form_rda), clim_df)

}
```

```{r RunRDA}
snp_sets <- lapply(snp_sets, function(x) {
  
x$rda_model <- runRDA(snp_set = x$set_snps,
                      clim_var = clim_var,
                      clim_df = clim_dfs$clim_past,
                      geno = geno)
return(x)

}) %>% setNames(names(snp_sets))
```

An RDA biplot can be used to visualize the relationship between the selected SNPs and the underlying climatic variables.

```{r FunctionToMakeRDAbiplots}
make_RDAbiplot <- function(x) {
  
TAB_loci <- as.data.frame(scores(x$rda_model, choices=c(1:2), display="species", scaling="none"))
TAB_var <- as.data.frame(scores(x$rda_model, choices=c(1:2), display="bp"))

eigenvalues <- summary(eigenvals(x$rda_model, model = "constrained")) %>% as.data.frame()
varexp_axis1 <- eigenvalues[2,1] *100 
varexp_axis2 <- eigenvalues[2,2] *100 


ggplot() +
  geom_hline(yintercept=0, linetype="dashed", color = gray(.80), linewidth=0.6) +
  geom_vline(xintercept=0, linetype="dashed", color = gray(.80), linewidth=0.6) +
  geom_point(data = TAB_loci, aes(x=RDA1*3, y=RDA2*3), colour = "#EB8055FF", size = 2, alpha = 0.8) + #"#F9A242FF"
  geom_segment(data = TAB_var, aes(xend=RDA1, yend=RDA2, x=0, y=0), colour="black", linewidth=0.15, linetype=1, arrow=arrow(length = unit(0.02, "npc"))) +
  geom_text(data = TAB_var, aes(x=1.1*RDA1, y=1.1*RDA2, label = row.names(TAB_var)), size = 3) +
  xlab(paste0("RDA 1 (",round(varexp_axis1,1),"%)")) + 
  ylab(paste0("RDA 2 (",round(varexp_axis2,1),"%)")) +
  facet_wrap(~paste0(x$set_name, " (n=",length(x$set_snps),")")) +
  guides(color=guide_legend(title="Locus type")) +
  theme_bw(base_size = 11) +
  theme(panel.grid = element_blank(), 
        plot.background = element_blank(), 
        panel.background = element_blank(), 
        strip.text = element_text(size=11))

}
```


```{r MakeRDAbiplots, fig.width=14, fig.height=6}
rda_biplots <- lapply(snp_sets, make_RDAbiplot)

grid_RDAbiplots <- plot_grid(rda_biplots[[1]],rda_biplots[[2]],rda_biplots[[3]], 
                         nrow=1)
ggsave(here("figs/RDA/RDAbiplots_SNPsets.pdf"), grid_RDAbiplots, width = 14, height=6)

grid_RDAbiplots
```

## Adaptive index across the landscape

From @capblancq2021redundancy and the associated [Github repository](https://github.com/Capblancq/RDA-landscape-genomics): The scores (loadings) of the climatic variables along the RDA axes can be used to calculate a genetic-based index of adaptation for each pixel of the landscape. This index is estimated independently for each RDA axis of interest using the formula:

$$\sum_{i=1}^{n}a_ib_i$$
where $a$ is the climatic variable score (loading) along the RDA axis, $b$ is the standardized value for this particular variable at the focal pixel, and $i$ refers to one of the $n$ different variables used in the RDA model.


# Genomic offset


## Estimation

Below, the past and future climatic data are scaled with the parameters (mean and variance) of the past climatic data.

```{r FunctionCalculateGOSpatialPoints}
# Function to calculate the RDA genetic offset
# ============================================

# clim_fit = climatic data used to fit the RDA model (the climate-of-origin of the populations)

# clim_pred = climatic data used for predictions (so either the future climate of the populations, 
            # or climate of the common gardens or the NFI plots)

# weights = if NULL, the adaptive index is not weighted by the relative importance of the RDA axes in 
# explaining the variance.

# K = number of RDA axes used to calculate the genomic offset

# snp_set = list with at least the RDA models 


pred_GO_spatial_points <- function(snp_set, 
                                   K, 
                                   clim_fit, 
                                   clim_pred, 
                                   weights = NULL, 
                                   CG=F){
  
# weights based on the variance explained by the different axes
weights <- (snp_set$rda_model$CCA$eig/sum(snp_set$rda_model$CCA$eig))[1:K]


list_AI <- lapply(list(clim_fit,clim_pred), function(df){
  
  lapply(1:K, function(i){
  
# Below we calculate the adaptive index for the axis i
# For that, we multiply the value of the variables at the location of the population
    # by the loadings of the variables along the axis i
ai <- apply(df[,-1], 1, function(x) sum(x * snp_set$rda_model$CCA$biplot[,i]))

if(!is.null(weights)){ai <- ai * weights[i]}
    
  }) %>% 
    setNames(paste0("RDA", 1:length(.))) %>% 
    as.data.frame()
  
})

if(CG==F){
  
eucloffset <- unlist(lapply(1:nrow(list_AI[[1]]), function(x) dist(rbind(list_AI[[1]][x,], list_AI[[2]][x,]), method = "euclidean")))

} else if(CG==T){
  
eucloffset <- lapply(1:nrow(list_AI[[2]]), function(x) as.matrix(dist(rbind(list_AI[[2]][x,],list_AI[[1]]), method = "euclidean"))[2:(nrow(list_AI[[1]])+1),1]) %>% 
  setNames(clim_pred[,1] %>% pull()) %>% 
  as.data.frame() %>% 
  cbind(clim_fit[,1])
  
  
  }

return(eucloffset)
}
```

```{r PredictGO}
snp_sets <- lapply(snp_sets, function(x) {
  
x$go <- pred_GO_spatial_points(snp_set = x,
                               K = 2, # why K=2??
                               clim_fit = clim_dfs$clim_past,
                               clim_pred = clim_dfs$clim_fut,
                               weights = T)
return(x)
})
```

## Relationship with Euclidean distance

```{r FunctionEuclideanDistancePlots}
source(here("scripts/functions/make_eucli_plot.R"))
```

```{r CalculateEucliDistance}
# Euclidean distance
Delta = clim_dfs$clim_past[,-1] - clim_dfs$clim_fut[,-1]
dist_env = sqrt( rowSums(Delta^2) ) 
```

```{r LoadInfoMainGenePoolPerPop}
# Main gene pools (for the figures)
gps <- readRDS(here("data/GenomicData/MainGenePoolPopulations.rds")) %>% 
  arrange(pop)
```

```{r MakeEucliPlots, fig.width=12, results="hide"}
par(mfrow=c(1,2))

lapply(snp_sets, function(x) make_eucli_plot(
  X = dist_env,
  Y = x$go,
  colors = gps$color_main_gp_pop,
  color_names = gps$main_gp_pop,
  ylab = "RDA genomic offset",
  plot_title = x$set_name))
```


Same plots as above but with the x and y axes cut off to help visualization.

```{r PlotSetSNPsEucliDistanceAxisLimits, fig.width=12, results="hide"}
par(mfrow=c(1,2))

lapply(snp_sets, function(x) make_eucli_plot(
  X = dist_env,
  Y = x$go,
  colors = gps$color_main_gp_pop,
  color_names = gps$main_gp_pop,
  ylab = "RDA genomic offset",
  plot_title = x$set_name,
  xlim=c(0,22),ylim=c(0,15)))
```

## Maps

```{r FunctionToMakeGomaps}
make_go_map <- function(dfcoord, 
                        snp_set, 
                        point_size=2, 
                        x_limits = c(-10, 12),
                        y_limits = c(33, 50),
                        CG=F,
                        cg_name=NULL,
                        cg_coord=NULL){

  if(CG==FALSE){
  point_go <- dfcoord %>% mutate(GO=snp_set$go)  
  plot_title <- snp_set$set_name
  } else if(CG==TRUE){
  point_go <- dfcoord %>% 
    left_join(snp_set$go[,c("pop",cg_name)], by="pop") %>% 
    dplyr::rename(GO=all_of(cg_name))
  plot_title <- paste0(str_to_title(cg_name), " - ",snp_set$set_name)
  }
  
p <-  ggplot() + 
  geom_sf(data = world, fill="gray98") + 
  theme_bw() +
  scale_x_continuous(limits = x_limits) +
  scale_y_continuous(limits = y_limits) + 
  geom_point(data=point_go, aes(x=longitude,y=latitude,color=GO), size=point_size) + 
  xlab("") + ylab("") +
  ggtitle(plot_title) +
  scale_color_gradientn(name = "GO", colours = rev(rainbow(5)))

if(CG==T){
p <- p + geom_point(data=cg_coord[cg_coord$site==cg_name,],
               aes(x=longitude,y=latitude), 
               size=5, color="black", shape=8)}

return(p)
}
```


I show only one map here because they are almost the same.

```{r GOmaps, fig.width=8,fig.height=8, results="hide"}
world <- ne_countries(scale = "medium", returnclass = "sf")

pop_coord <- read_csv(here("data/DryadRepo/PopulationCoordinatesPastClimateInformation.csv"),
                        show_col_types = FALSE) %>%
  dplyr::select(pop,longitude,latitude)


go_maps <- lapply(snp_sets, function(x) make_go_map(dfcoord=pop_coord, 
                                                    snp_set = x,
                                                    point_size = 3))
go_maps[[1]]
```



```{r OtherMaps, eval=F}
# another way to make maps with ggplot2
library(maps)

world_map <- map_data("world")

ggplot() + 
  geom_map(data=world_map, map=world_map,
           aes(map_id=region),
           color="gray30", size=0.1, fill=NA)+
  scale_x_continuous(limits = c(-10, 12)) +
  scale_y_continuous(limits = c(32, 50)) + 
  coord_fixed(ratio = 1) + 
  xlab("Longitude (in degrees)") +
  ylab("Latitude (in degrees)") +
  theme_bw() +
  geom_point(data=point_go, aes(x=longitude,y=latitude,color=GO), size=1.5) + 
  scale_color_gradientn(colours = rev(rainbow(5))) + 
  theme(legend.position = c(0.91, 0.16),
        legend.background = element_rect(linewidth=0.3, color = "gray90"))
```

# NFI

I show only one set of SNPs because the maps for the three sets of SNPs are very similar.

```{r NFIGOmaps, fig.width=8,fig.height=8, results="hide"}
nfi_clim <- readRDS(here("data/ClimaticData/NFIplots/NFIclimate.rds"))
  
nfi_dfs <- generate_clim_datasets(clim_var, clim_past = nfi_clim$clim_past, clim_fut = nfi_clim$clim_survey)


snp_sets_nfi <- lapply(snp_sets, function(x) {
  
x$go <- pred_GO_spatial_points(snp_set = x,
                               K = 2, # why K=2??
                               clim_fit = nfi_dfs$clim_past,
                               clim_pred = nfi_dfs$clim_fut,
                               weights = T)
return(x)
})

# checking missing data
# lapply(snp_sets_nfi, function(x) sum(is.na(x$go)))

go_maps_nfi <- lapply(snp_sets_nfi, function(x) make_go_map(dfcoord=nfi_clim$plot_coord, 
                                                            snp_set = x,
                                                            point_size = 0.5,
                                                            y_limits = c(35, 51)))

go_maps_nfi[[1]]
```


# Common gardens


```{r CalcGOCGs}
cg_clim <- readRDS(here("data/ClimaticData/CommonGardens/ClimateCG.rds"))
cg_coord <- read_csv(here("data/ClimaticData/CommonGardens/CommonGardensPreExtraction.csv"), 
                     show_col_types = FALSE)
cg_dfs <- generate_clim_datasets(clim_var, clim_fut = cg_clim)
  



snp_sets_cg <- lapply(snp_sets, function(x) {
  
x$go <- pred_GO_spatial_points(snp_set = x,
                               K = 2, # why K=2??
                               clim_fit = cg_dfs$clim_past,
                               clim_pred = cg_dfs$clim_fut,
                               weights = T,
                               CG=T)
return(x)
})
```

```{r MakeGoMapsCG, fig.width=15, fig.height=6, results="hide"}
go_maps_cg <- lapply(cg_dfs$clim_fut$cg, function(cg_name){
  
p <- lapply(snp_sets_cg, function(x) make_go_map(dfcoord=pop_coord, 
                                           snp_set = x,
                                           point_size = 3,
                                           CG=T,
                                           cg_name=cg_name,
                                           cg_coord=cg_coord))

plot_grid(p[[1]],p[[2]],p[[3]],nrow=1)
  
}) %>% setNames(cg_dfs$clim_fut$cg)


pdf(here("figs/RDA/GOmaps_CGs.pdf"), width=15,height=6)
lapply(go_maps_cg, function(x) x)
dev.off()

# show maps
lapply(go_maps_cg, function(x) x)
```

