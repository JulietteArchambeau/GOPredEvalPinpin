---
title: "Gradient Forest analysis - Part 1"
subtitle: "Candidate SNPs identification"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    toc: true
    toc-depth: 4
    code-fold: true
    page-layout: full
embed-resources: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body {
   font-size: 15px;
}
code.r{
  font-size: 11px;
}
pre {
  font-size: 11px
}

table {
  font-size: 10px
}
</style>



```{r setup, include=F}
knitr::opts_chunk$set(cache=F)
options(width = 300)
library(knitr)      # CRAN v1.26
library(kableExtra) # CRAN v1.1.0
library(tidyverse)
library(gradientForest)
library(parallel)
library(foreach)
library(doParallel)
library(readxl)
library(here)
library(data.table)
library(cowplot)
library(magrittr)
library(ggVennDiagram)


# my own function for building tables in reports
source(here("scripts/functions/kable_mydf.R"))
source(here("scripts/functions/extract_climatedt_metadata.R")) # extracting meta data of the climatic variables in ClimateDT
```



# Introduction


Most analyses conducted in the present report were conducted following @fitzpatrick2021experimental and @capblancq2023common, and the R code are based on [the github repository](https://github.com/fitzLab-AL/geneticOffsetR) associated with @fitzpatrick2021experimental. 


**Goal:** Identify candidate SNPs for local adaptation to climate using the **Gradient Forest (GF) algorithm**. 

To this goal, we will apply the GF algorithm to:
  
  - the 'raw' or *uncorrected* allele frequencies (**GF-raw** in @fitzpatrick2021experimental and @capblancq2023common).
  
  - the *corrected* allele frequencies, i.e. the allele frequencies corrected for population structure = corrected for population reladness. In @fitzpatrick2021experimental and @capblancq2023common, they use the population genetic variance-covariance matrix from Bayenv 2 to correct for population structure and called the matrix of corrected allele frequencies **GF-X**. From @fitzpatrick2021experimental: 'The GF-X approach was included to explore a more robust approach to allele frequency estimation that corrects for finite sampling and population relatedness prior to feeding into GF for outlier detection.' In our case, we extract the matrix of corrected allele frequencies using the latent factor mixed model (LFMM) approach; see section 5 'Corrected allele frequencies' in the `6_LEAanalysis.qmd` report.


**Strengths** of the GF algorithm: nonparametric (nonlinear allele frequency gradients), makes no assumption about the particular form of the geneâ€“environment relationship, incorporates multivariate predictors, interactions among predictors.

**Weakness**: not controlling for demographic history.

From @gain2023quantitative: 'Nonlinearity makes the GF model more flexible than linear models, but the additional degrees of freedom may not always be desirable when resolving bias-variance trade-offs.'

GF models are fitted to each locus individually and a $R^2$ is obtained for each locus. Empirical p-values are then calculated.

The **empirical p-value approach** is described in @lotterhos2014evaluation: '[...] if the set of neutral loci is large enough, the statistical significance of a putatively selected outlier locus could be assessed by its quantile in the empirical distribution of differentiation measures obtained from the neutral set.'

 
In @fitzpatrick2021experimental, the authors use a set of intergenic SNPs to obtain a distribution of $R^2$ values, which is considered as the empirical null distribution of $R^2$ values. They calculate the empirical p-values by determining the rank of the $R^2$ value for each locus within the distribution of $R^2$ values from the intergenic SNPs.

In the present report, we randomly sample $n$ SNPs and we compare $R^2$ value of each locus to the $R^2$ distribution of the $n$ randomly selected SNPs. Thus, the **empirical p-value** $\hat{p}$ of the locus $l$ is equal to:

$$\hat{p}_l = 1 - (r_l / n)$$
 with $r_l$ being the rank of the $R^2$ value of locus $l$ within the distribution of $R^2$ values of the  $n$ randomly selected SNPs. 

# Options, parameters and functions

## Functions from @fitzpatrick2021experimental

The following functions are based on the functions written by MC Fitzpatrick (Appalachian Lab, Frostburg, MD) and available in the Github repository:  <https://github.com/fitzLab-AL/geneticOffsetR>


### `format_geno`

Function to format the genomic data used in the GF analysis.

Inputs:

  - `genodata`: the genomic dataset with SNPs in columns and populations in rows (with population names as row names)
  - `selected_snps`: SNPs selected for the analysis. If 'all', all SNPs are selected.
  - `rm_rare_alleles`: specify whether rare alleles are removed or not. The rare alleles are the alleles that are polymorphic in fewer than five populations.
  - `selected_random_snps`: number of random SNPs selected for the analysis. If `selected_random_snps` = 0,  > 0, no random SNPs are selected.

```{r FunctionFormatGeno}
format_geno <- function(genodata, selected_snps, rm_rare_alleles, selected_random_snps){

  # run GF on all SNPs or a subset of selected SNPs?
  if(length(selected_snps)>1){genodata <- genodata %>% dplyr::select(all_of(selected_snps))}
  
  # remove SNPs that are polymorphic in fewer than five populations?
  if(rm_rare_alleles==T){genodata  <- genodata %>% dplyr::select(which(unlist(lapply(lapply(., unique), length))>=6))}
  
  # run GF on a random subset of SNPs?
  if(selected_random_snps>0){genodata <- genodata %>% dplyr::select(sample(colnames(.),selected_random_snps))}
  
  return(genodata)
  }
```

### `run_gf_ind`

Function to run the GF models individually for each locus.

Inputs:

  - `genodata`: the genomic dataset with SNPs in columns and populations in rows (with population names as row names)
  - `climdata`: table with the climatic variables with a row for each population
  - `clim_var`: vector with the names of the climatic variables to be used in the GF models
  - `ntree`: number of trees to fit 
  - `cores`: number of processors to use
  
```{r FunctionRunGFInd}
run_gf_ind <- function(genodata, climdata, clim_var, ntree, cores){

  # create custom object to hold output 
  gf_output_obj <- setClass("gf_output_obj", slots = c(gf_data="data.frame", gf_impts="list"))
  
  # check that populations are in the same order in the genomic and climatic datasets
  if(identical(climdata$pop,rownames(genodata))==F){
    stop("Populations are not in the same order in the genomic and climatic tables.")
  }
  
  # check to make sure user has set the number of cores (min = 1)
  if(is.na(cores)){
    stop(paste0("You need to provide the number of processors to use (i.e., cores = 4). You have a maximum of ", detectCores(), " cores available."))
  }
  
  if(cores>detectCores()){
    stop(paste0("You have a maximum of ", detectCores(), " cores available."))
  }
  
 
    # fit the GF model to each SNP individually and in parallel
    cl <- makeCluster(cores, setup_strategy = "sequential")
    registerDoParallel(cl)
    
    gf_impts <- foreach(k=1:ncol(genodata), .verbose=F, .packages=c("gradientForest")) %dopar%{
      locus <- data.frame(genodata[,k])
      names(locus) <- colnames(genodata)[k]
      gf_mod <- gradientForest(data.frame(climdata[, clim_var], locus), 
                               predictor.vars=clim_var, response.vars=colnames(genodata)[k], 
                               corr.threshold=0.5, ntree=ntree, trace=F)

      if(!is.null(gf_mod)){data.frame(variable=names(importance(gf_mod)),
                                      impts = importance(gf_mod), 
                                      snp = colnames(genodata)[k])}
    }
    
    stopCluster(cl)
    
    
    return(gf_output_obj(gf_data = data.frame(genodata), gf_impts = gf_impts))
 
  }
```



### `extract_pvals`

Function to calculate the empirical p-values

Inputs:


  - `gf_outputs`: output object from `run_gf_ind` function
  - `neutral_snps`: subset of randomly selected SNPs used as 'neutral' SNPs to develop the empirical null model

 

```{r FunctionExtractPvals}
extract_pvals <- function(gf_outputs, neutral_snps){

# extract the R2 importance values from the GF outputs and arrange them in a
  # dataframe with a row for each SNP with R2>0 and a column with the R2 of each climatic variable
gf_R2 <-  gf_outputs@gf_impts %>% 
    bind_rows() %>% 
    pivot_wider(names_from = "variable", values_from = "impts") %>% 
    rowwise() %>% 
    mutate(totalR2 = sum(c_across(where(is.numeric)))) %>% 
    arrange(snp)

# extend the table to all the SNPs used in the GF analysis
  dat <- gf_outputs@gf_data %>% 
    t() %>% 
    as.data.frame() %>% 
    rownames_to_column("snp") %>% 
    dplyr::select(snp) %>% 
    as_tibble() %>% 
    left_join(gf_R2, by="snp") %>% 
    mutate(across(where(is.numeric), ~replace_na(.x, 0)))
  
  
# subset of random SNPs considered as the 'neutral' SNPs
  neutral_snps_R2 <- dat %>% 
    filter(snp %in% neutral_snps)
  
pV <- sapply(1:nrow(dat), function(x, dat, neutral_snps, neutral_snps_R2){
    snps2Rank <- rbind(dat[x,], neutral_snps_R2) %>% 
      distinct() %>% 
      dplyr::select(-snp)
    P <- apply(snps2Rank, 2, function(y){
      rankSNP <- frank(y)
      return(1-rankSNP[1]/length(rankSNP))
    })}, dat, neutral_snps, neutral_snps_R2)
  
  # format output as data.frame
  pV <- t(pV)
  colnames(pV) <- paste("pval_", colnames(pV), sep="")
  pV <- data.frame(dat, pV)
  return(pV)
}
```


### `identify_GFoutliers`

Function to identify the GF outliers

Inputs:


  - `list_clim_var`: list of vectors with the names of the climatic variables to be used in the GF models
  - `nb_neutral_snps`: number of random SNPs to sample from the genomic data to develop the empirical null model



```{r FunctionToIdentifyGFoutliers}
identify_GFoutliers <- function(genodata,
                                climdata,
                                clim_var, 
                                set_seed,
                                ntree, 
                                rm_rare_alleles, 
                                selected_snps, 
                                cores, 
                                selected_random_snps,
                                nb_neutral_snps){
  
genodata <- format_geno(genodata,
                        selected_snps,
                        rm_rare_alleles,
                        selected_random_snps)

# we sample random SNPs that are considered as neutral SNPs
set.seed(set_seed)
neutral_snps <- sample(colnames(genodata),nb_neutral_snps,replace = F)

# We run the GF models individually for each SNP
gf_outputs <-  run_gf_ind(genodata = genodata, climdata = climdata, clim_var = clim_var, ntree = ntree, cores)

# We calculate the empirical p-values for each SNP
gf_pvals <- extract_pvals(gf_outputs=gf_outputs,neutral_snps=neutral_snps)
  
gf_out <- list(genodata = genodata,
               clim_var= clim_var,
               gf_pvals = gf_pvals)

return(gf_out)
}
```


# Downloading the data

## Genomic data

We load the *uncorrected* and *corrected* allele frequency matrices in a list.

```{r LoadGenomicData}
# we load the two genomic matrices
list_geno <- list(mat_raw = read.csv(here::here("data/DryadRepo/ImputedGenomicData_AlleleFrequencies_withoutmaf.csv"), 
                                     row.names = 1), 
                  mat_X = read.csv(here::here("data/DryadRepo/CorrectedAlleleFrequencies_withoutmaf.csv"), 
                                     row.names = 1))
```


The *uncorrected* allele frequency matrix is already a matrix a population-level allele frequencies, i.e. so with the number of populations in rows and the number of genetic markers in columns.


```{r UncorrectedAlleleFrequencyMatrix}
list_geno$mat_raw[1:10,1:10] %>% kable_mydf()
```


The *corrected* allele frequency matrix is a matrix of genotype-level (ie individual-level) allele frequencies, i.e. so with the number of genotypes (ie clones, individuals) in rows and the number of genetic markers in columns. We have to transform it in a population-level allele frequency matrix.


```{r CorrectedAlleleFrequencyMatrix}
# we calculate the population-level allele frequencies for the corrected matrix
list_geno$mat_X <- list_geno$mat_X %>% 
  rownames_to_column(var="pop") %>% 
  mutate(pop=str_sub(pop,1,3)) %>% 
  group_by(pop) %>% 
  summarise_all(~sum(., na.rm = TRUE)/((n()-sum(is.na(.)))*2)) %>% 
  column_to_rownames("pop")

list_geno$mat_X[1:10,1:10] %>% kable_mydf()
```


**Comment:** This data contains the population-based allele frequencies of the **minor allele**. The minor allele was identified as the minor allele across all individuals. However, as the populations do not contain the same number of individuals, the average of the population-based allele frequencies is higher than 0.5 for some SNPs.

```{r HighFreqAlleles}
high_freqs <- lapply(list_geno, function(x)

  x %>% 
  summarise_all(mean) %>% 
  pivot_longer(everything(),names_to = "snp",values_to= "mean") %>% 
  filter(mean>0.5))
```


For the corrected matrix, `r length(high_freqs$mat_X$snp)` have average population-based allele frequencies higher than 0.5. However, for the uncorrected matrix, `r length(high_freqs$mat_raw$snp)` SNPs have average population-based allele frequencies higher than 0.5. Can we still call them population minor allele frequencies?

## Climatic data

We load the population-specific climatic information for the climatic variables of interest. 

```{r LoadClimaticData}
# Selected climatic variables
# ===========================
clim_var <- readRDS(here("data/ClimaticData/NamesSelectedVariables.rds"))

extract_climatedt_metadata(var_clim = clim_var) %>% 
  dplyr::select(label,description,unit) %>% 
  set_colnames(str_to_title(colnames(.))) %>% 
  kable_mydf()

# Past and future climatic data
# =============================
source(here("scripts/functions/generate_scaled_clim_datasets.R"))
clim_ref <- generate_scaled_clim_datasets(clim_var)[[1]]
```


# Run GF models and calculate p-values


```{r RunGFModels, eval=F}
gf_out <- lapply(list_geno, function(geno)

identify_GFoutliers(genodata = geno,
                    climdata = clim_ref,
                    clim_var = clim_var,
                    rm_rare_alleles = T, 
                    set_seed = 4930,
                    selected_snps = "all", 
                    ntree=500,
                    cores = 9, 
                    selected_random_snps = 0,
                    nb_neutral_snps = 2000)) %>% 
  setNames(c("gf_raw","gf_X"))

saveRDS(gf_out, here::here("outputs/GF/gf_models.rds"))
```

# Identify outliers

Different possible thresholds to identify the candidate SNPs:

  - $p$-value threshold: $p$-value < 0.005 or $p$-value < 0.001.
  
  - rank-based threshold. e.g. the 0.2% or 0.5% of the SNPs with the lowest p-values (i.e. 19 or 49 SNPs in our study). As done in @capblancq2023common and @fitzpatrick2021experimental.
  
  - Bonferroni threshold.
  
```{r IdentifyOutliers}
gf_out <- readRDS(here::here("outputs/GF/gf_models.rds"))

gf_outliers <- lapply(gf_out, function(x){

# Thresholds based on the p-values
outliers_pv05 <- x$gf_pvals %>% filter(pval_totalR2<0.05) %>% pull(snp) # this threshold is not enough strict
outliers_pv01 <- x$gf_pvals %>% filter(pval_totalR2<0.01) %>% pull(snp)

# Thresholds based the p-value rank of the SNPs
# 0.2% with the lowest p-value (19 SNPs)
outliers_rank002 <- x$gf_pvals %>% 
  arrange(pval_totalR2) %>% 
  slice(1:(dim(list_geno[[1]])[[2]]*0.002)) %>% 
  pull(snp)

# 0.5% with the lowest p-value (48 SNPs)
outliers_rank005 <- x$gf_pvals %>% 
  arrange(pval_totalR2) %>% 
  slice(1:(dim(list_geno[[1]])[[2]]*0.005)) %>% 
  pull(snp)

# Threshold with a Bonferroni correction
outliers_bonf <- x$gf_pvals %>% 
  filter(pval_totalR2<0.01/length(x$gf_pvals$snp)) %>% 
  pull(snp)
  
list(outliers_pv05 = outliers_pv05,
     outliers_pv01 = outliers_pv01,
     outliers_rank002 = outliers_rank002,
     outliers_rank005 = outliers_rank005,
     outliers_bonf = outliers_bonf)


})

saveRDS(gf_outliers, here::here("outputs/GF/gf_outliers.rds"))
```



# Common outliers with RDA


```{r MakeVennDiagrams}
# Function to make the Venn diagrams
make_venndiagram <- function(list_candidates,
                             caption="",
                             title=""){

list_candidates %>% 
    ggVennDiagram(lty="solid", size=0.2) + 
  scale_fill_gradient2(low = "white", high = 'gray40') + 
  scale_color_manual(values = rep("gray80",4)) + 
  guides(fill = "none") + 
  labs(caption=caption) +
  ggtitle(title) +
  theme(text = element_text(size=16),
        plot.caption = element_text(hjust=0.5, size=rel(1.2))) + 
  scale_x_continuous(expand = expansion(mult = .2))
}
```

In the Venn diagrams below, the candidate SNPs identified with GF correspond to the 0.5% SNPs (48 SNPs) with the lowest empirical $p$-values.

```{r VennDiagrams, fig.height=8, fig.width=10}
rda_outliers <- readRDS(here::here("outputs/RDA/RDA_outliers.rds"))
gf_out <- readRDS(here::here("outputs/GF/gf_outliers.rds"))

list_outliers <- list("RDA-raw" = rda_outliers[[3]]$outliers$snp,
                      "RDA-X" = rda_outliers[[4]]$outliers$snp,
                      "GF-raw" = gf_out$gf_raw$outliers_rank005,
                      "GF-X" = gf_out$gf_X$outliers_rank005)

list_outliers %>% make_venndiagram()

list_outliers[c(2,4)] %>% make_venndiagram(title="GEAs corrected for population structure")

list_outliers[c(1,3)] %>% make_venndiagram(title="GEAs not corrected for population structure")
```


# Unstable identification across runs

I am a bit worried about the GF runs because the outputs vary from one run to another.


```{r ConsistenceAcrossRuns, eval=T}
gf_out <- readRDS(here::here("outputs/GF/gf_outliers.rds"))
gf_out_1 <- readRDS(here::here("outputs/GF/gf_outliers_1.rds"))
gf_out_2 <- readRDS(here::here("outputs/GF/gf_outliers_2.rds"))

list("run 1"=gf_out_1$gf_raw$outliers_rank005,
     "run 2"=gf_out_2$gf_raw$outliers_rank005,
     "run 3"=gf_out$gf_raw$outliers_rank005) %>% 
  make_venndiagram(title="0.5% SNPs with the lowest p-values")

list("run 1"=gf_out_1$gf_raw$outliers_rank002,
     "run 2"=gf_out_2$gf_raw$outliers_rank002,
     "run 3"=gf_out$gf_raw$outliers_rank002) %>% 
  make_venndiagram(title="0.2% SNPs with the lowest p-values")
```

