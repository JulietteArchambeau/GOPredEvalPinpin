---
title: "Climatic variable selection, candidate SNPs identification, genomic offset predictions"
subtitle: "Based on RDA"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::html_document2:
    df_print: kable
    fig.caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: no
  pdf_document:
    toc: yes
    toc_depth: '4'
editor_options:
  chunk_output_type: console
bibliography: references.bib
always_allow_html: true
---


<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>

<style type="text/css">
div.main-container {
  max-width: 2000px;
  margin-left: auto;
  margin-right: auto;
}
</style>


<!-- ```{css} -->
<!-- pre { -->
<!--   max-height: 300px; -->
<!--   overflow-y: auto; -->
<!-- } -->

<!-- pre[class] { -->
<!--   max-height: 600px; -->
<!-- } -->
<!-- ``` -->


```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=F)
options(width = 300)
library(knitr)      # CRAN v1.26
library(kableExtra) # CRAN v1.1.0
library(dplyr)      # CRAN v1.0.0
library(psych)      # CRAN v1.8.12 (pairs.panels function)
library(tidyverse)  # CRAN v1.3.0
library(raster)     # CRAN v3.3-13
library(stringr)    # CRAN v1.4.0
library(ggbiplot)
library(corrplot)
library(vegan)
library(xtable)
library(reshape2)
library(robust)
library(qvalue)
library(ggpubr)
library(magrittr)
```

```{r Functions}
# Functions from other packages:
source("scripts/functions/corpmat.R") # to compute the matrix of p-value
source("scripts/functions/rdadapt.R") # to conduct a RDA based genome scan
source("scripts/functions/detectoutliers.R") # to identify outliers based on their RDA loadings

# Function to generate a corrplot
make_corrplot <- function(df,variables,fig_options){
  
  # correlation matrix
  cor <- cor(df[,variables]) 
  
  # matrix of the p-value of the correlation
  pmat <- corpmat(cor)

  # Generate a correlation plot
  png(filename=fig_options$path,
      width=fig_options$width,
      height=fig_options$height,
      res=fig_options$res)
  corrplot::corrplot(cor, 
                     method="color", 
                     col=colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))(200),
                     type="upper", 
                     order="hclust",
                     addCoef.col = "black", # Add coefficient of correlation
                     tl.col="black", 
                     tl.srt=45, #Text label color and rotation
                   
                     # Combine with significance
                     p.mat = pmat, 
                     sig.level = 0.01, 
                     insig = "blank",
                     
                     # hide correlation coefficient on the principal diagonal
                     diag=FALSE,
                     number.cex=0.6)
  dev.off()
  
}

# Function to build tables
kable_mydf <- function(x, boldfirstcolumn){
  x %>% 
  kable() %>%  
  kable_styling(bootstrap_options = c("stripped","hover", "condensed"), full_width = F) %>% 
  {if(boldfirstcolumn == TRUE) column_spec(., 1, bold = T) else .}
}
```

<br>


Most analyses conducted in this document are based on:

  - @forester2018comparing and the associated [vignette](https://popgen.nescent.org/2018-03-27_RDA_GEA.html). 
  
  - @capblancq2021redundancy and the associated [Github repository](https://github.com/Capblancq/RDA-landscape-genomics).
  

RDA can either be performed on *individual-based genotypes* (i.e. allele counts 0, 1 or 2) or *population-based allele frequencies*. @forester2018comparing suggests to use individual-based allele counts when most samples have individual coordinates and individual environment data (which depends on the resolution of the environmental data across the study area). In the present study, it seems more relevant to work with allele frequencies as several genotypes were collected at each sampling site (i.e. source population) and therefore experience the same climatic conditions. Moreover, the sample sizes varies across populations.

However, when I first conducted these analyses (in the third chapter of my PhD), I used *individual-based genotypes* because I accounted for the neutral population genetic structure with the ancestry coefficients from @jaramillo2015molecular, which are at the genotype level (i.e. proportion of gene pool assignment for each genotype). As the population genetic structure is highly confounded with the climatic gradients across the populations sampled (see section \ref(VarPart)), correcting for population structure with the ancestry coefficient most likely resulted in overcorrection for population structure. 

In the present document,  we will therefore use *population-based allele frequencies* to select the climatic variables with the stepwise selection procedure (section \ref(StepwiseSelection)), identify the candidate SNPs with RDA and calculate the genomic offset.

We only use the *individual-based allele counts* for variance partitioning in section \ref(VarPart), in which we estimate the relative contribution of climate, population structure and geography. Population structure is either accounted for with the ancestry coefficients at the genotype level from @jaramillo2015molecular (section \ref(VarPartInd)), either using the first PCs of a PCA based on *population-level allele frequencies* (section \ref(VarPartPop)).

  
# Downloading the data

## Genomic data


```{r LoadGenomicData}
# Individual-based allele counts
# ==============================
geno_ind <- read.csv("data/DryadRepo/ImputedGenomicData_AlleleCounts_NOMAF_454clones_9817snps.csv",row.names = 1) %>% 
  t() %>% 
  as.data.frame()

kable_mydf(geno_ind[1:10,1:10], boldfirstcolumn = T)


# Population-based allele frequencies
# ===================================
geno_pop <- read.csv("data/DryadRepo/ImputedGenomicData_AlleleFrequencies_NOMAF_34pops_9817snps.csv",
                     row.names = 1)

kable_mydf(geno_pop[1:10,1:10] %>% round(3), boldfirstcolumn = T)
```

The genomic dataset with *individual-based allele counts* contains `r nrow(geno_ind)` clones (i.e. genotypes) and `r ncol(geno_ind)` SNPs. The genomic dataset with *population-based allele frequencies* contains `r nrow(geno_pop)` populations and `r ncol(geno_pop)` SNPs.

RDA requires complete data frames (i.e., no missing data). Missing data were imputed based on the main gene pool of the clone, i.e. using the most common allele at each SNP (see report `1_FormattingGenomicData.Rmd`).

## Climatic data


### Load ClimateDT data 

Climatic data comes from the [Climate Downscaling Tool (ClimateDT)](https://www.ibbr.cnr.it/climate-dt/). Annual climatic variables were extracted between 1901 and 2098. 

**Reference period:** we use the annual values between 1901 and 1950 to capture the climatic conditions under which the populations have evolved. 


```{r LoadClimateDToutputs}
clim <- read_csv("data/DryadRepo/ClimateDT/ClimateDToutputs_Populations_1901_2098.csv",
               show_col_types = FALSE) %>% 
  dplyr::filter(Year<1951) %>%  # we keep the years btw 1901 to 1950
  group_by(ID) %>% # group by population
  summarise_all("mean") %>% # take the average of the annual values for the ref period 1901-1950
  dplyr::select(-Year) %>% 
  dplyr::rename(longitude=Longitude,
                latitude=Latitude,
                elevation=Elevation,
                pop=ID)

kable_mydf(clim[1:10,1:10], boldfirstcolumn = F)
```

The dataset contains `r nrow(clim)` populations and `r ncol(clim)-4` climatic variables. The description of the climatic variables is available [here](https://www.ibbr.cnr.it/climate-dt/?action=fldlist).

### Filtering the climatic variables

```{r IdCorrelatedClimaticVariables}
# Function to identify climatic variable with a correlation coeff higher than a given threshold
identify_corr_var <- function(df,corr_threshold){

# calculate the correlation matrix among the variables
clim_cor <- df %>% 
  dplyr::select(-pop,-elevation,-contains("itude")) %>% 
  cor()

# attribute NA to the lower triangle and diagonal of the matrix
clim_cor[lower.tri(clim_cor,diag=T)] <- NA

# build a dataframe with the correlated variables
clim_cor <- clim_cor %>% 
  melt() %>% 
  na.omit() %>% 
  dplyr::filter(value>corr_threshold)

}

# we want to identify variables with a correlation coefficient higher than:
corr_threshold <- 0.95

# we ran the function to identify the highly correlated variables
clim_cor <- identify_corr_var(df=clim,corr_threshold = corr_threshold)

kable_mydf(clim_cor, boldfirstcolumn = F)
```

`r nrow(clim_cor)` pairs of variables have a correlation coefficient higher than `r corr_threshold`.

We remove some variables so that there are no more pairs of variables with a correlation coefficient greater than `r corr_threshold`.

We also remove the variables `MOP` and `AOP` because there is no metadata for these variables on the ClimateDT website.

We remove also some variables of low biological interest for maritime past adaptation or adaptation to future climate: `PAS` (precipitation as snow between August and July), `bio13` (precipitation of the wettest month).

When estimating exposure to climate change in section \ref(ExpCC), we saw that `bFFP` has weird future climatic values, so we remove it also. 

We remove `EPQ` (Emberger Pluviometric Quotient) because there is very low information about this variable in the litterature and its possible influence on forest trees.

```{r FilteringClimVariables}
clim_var_to_rm <- c("bio7","TD", # we keep bio4
                    "bio6","bio11","EMT","NFFD","eFFP", # we keep MCMT
                    "GDD0","GDD5", # we keep bio1
                    "bio17","bio18","bio14", # we keep MSP
                    "DMA","bio19","bio16", # we keep bio12
                    "bio2","CMD", # we keep Eref
                    "bio10", # we keep MWMT
                    "MOP","AOP", # we rm these variables because there is no metadata for them in the ClimateDT website!
                    "PAS","bio13", # low biological interest
                    "bFFP",
                    "EPQ"
                    )

clim <- clim %>% dplyr::select(-all_of(clim_var_to_rm))

# we check that there are no more pairs of highly correlated variables
identify_corr_var(df=clim,corr_threshold = 0.95) %>% nrow()
```

### Viz 

We can look at the distribution of the climatic variables.

```{r PlotDistributionClimaticVariables, fig.height=12, fig.width=15}
p <- clim %>% 
  dplyr::select(-pop,-contains("itude"),-elevation) %>% 
  pivot_longer(everything(),names_to="variable") %>% 
  ggplot(aes(x=value)) +  
  geom_histogram(aes(y=after_stat(density)), colour="blue",fill="white",bins = 34) +
  geom_density(alpha=.2,fill="pink") +
  facet_wrap(~variable,scales="free") + 
  theme_bw() 

p %>% ggsave(file="figs/ExploratoryAnalyses/DistributionClimaticVariables_selected.png",
               width=15,height=12)

p
```

We also generate a correlation plot and perform a PCA to look at the correlation among the remaining climatic variables.

```{r CorrelationsPanels,fig.height=9,fig.width=12}
# Chunk to generate figures to visualize the correlations among the climatic variables
fig_options <- list(
  path = "figs/ExploratoryAnalyses/CorrplotClimVariables.png",
  width=1000,
  height=1000,
  res=100)

make_corrplot(df = clim, 
              variables = colnames(clim)[-1], # we keep long, lat, elev and clim variables
              fig_options = fig_options)


# Generate a PCA
pca <- prcomp(clim[,-1], center = TRUE,scale. = TRUE)

p <- ggbiplot(pca,varname.size =4) +  
  ylim(-4, 2.5) +    
  xlim(-3, 3) + 
  theme_minimal(base_size = 12)

ggsave(p,file="figs/ExploratoryAnalyses/PCAClimVariables.png",width=8,height=8,
       bg="white")
p
```



## Population genetic structure


### Ancestry coefficients

The proportion of gene pool assignment was estimated in @jaramillo2015molecular for each genotype with the *STRUCTURE* software.

```{r GenerateListDfIndividualLevel}
# We will store two datasets in a list: one with raw variables, the other one with mean-centered variables

listdf_ind <- list()

listdf_ind$df <- read.csv("data/DryadRepo/PopulationStructureCorrea2015.csv") %>% 
  filter(clon %in% rownames(geno_ind)) %>% # keep the same clones as in the genomic data
  unique() %>% 
  dplyr::rename(pop=prov) %>% 
  left_join(clim,by="pop") %>% # merge with the climatic variables
  dplyr::select(-max.Q) %>% 
  arrange(clon) # the clones have to be in the same order as in the genomic data.

# Run this line to check that the order of the clones in the genomic data and explanatory variables data is the same.
# identical(as.vector(listdf_ind$df$clon),rownames(geno_ind)) # should be TRUE 

kable_mydf(listdf_ind$df[1:10,1:14],boldfirstcolumn = F)


# create df with standardized variables (ie centered and scaled)
listdf_ind$dfsc <- listdf_ind$df %>% 
  dplyr::mutate(across(where(is.numeric), ~ (. - mean(.)) / sd(.)))

kable_mydf(listdf_ind$dfsc[1:10,1:14],boldfirstcolumn = F)
```


### PC scores

Another way to account for population structure in the RDA models is to use PCs from a *principal component analysis* (PCA) as proxies of the population evolutionary history. This is the method used in @capblancq2021redundancy.

As advised in @capblancq2021redundancy, the estimation of the population genetic structure should be performed on genomic data not filtered for minor allele frequencies because small genetic variations are expected to be involved in differentiating neutral genetic groups. So, we use *population-based allele frequencies* not filtered for MAF and imputed for missing data (based on the most common allele in the gene pool, see report `1_FormattingGenomicData.Rmd`).


```{r LoadImtGenDataMAF}
geno_pop_maf <-  read.csv("data/DryadRepo/ImputedGenomicData_AlleleFrequencies_MAF_34pops_10520snps.csv")

kable_mydf(geno_pop_maf[1:10,1:8], boldfirstcolumn = F)
```

We run the PCA with the `rda` function of the `vegan` package, which performs a PCA when no predictor is included.

```{r RunPCA, fig.height=4,fig.width=6}
pca <- rda(geno_pop_maf[,-1], scale=T)

# Screeplot of the PCA eigenvalues
screeplot(pca, type = "barplot", npcs=10, main="PCA Eigenvalues")
```

Based on the screeplot, retaining three or four PCs may be reasonable to account for neutral population structure in downstream analyses. 

In our case, we keep the first three PCs.

```{r GenerateListDfPopLevelNotScaled}
# We store two datasets in a list: one with raw variables, the other one with mean-centered variables

listdf_pop <- list()

listdf_pop$df <- data.frame(pop = geno_pop_maf[,1], # population id
                            PCs = scores(pca, choices=c(1:3), display="sites", scaling="none")) %>% #
  setNames(c("pop", "PC1", "PC2", "PC3")) %>% 
  inner_join(clim, by="pop")


# extract mean and variance of the PC scores
listdf_pop$df %>% 
  dplyr::select(contains("PC")) %>% 
  dplyr::summarise(across(everything(),list(mean=mean,sd=sd))) %>% 
  pivot_longer(everything()) %>% 
  mutate(PC = str_sub(name,1,3),
         index = str_sub(name,5,-1)) %>%
  dplyr::select(-name) %>% 
  pivot_wider(names_from="index",values_from="value") %>% 
  kable_mydf(boldfirstcolumn = F)
```

The PC scores have a mean of O but a standard deviation of 0.2, so we scale them too so that they have the same standard deviation as the climatic variables.

```{r GenerateListDfPopLevelScaled}
listdf_pop$dfsc <- listdf_pop$df %>% 
  dplyr::mutate(across(where(is.numeric), ~ (. - mean(.)) / sd(.)))

kable_mydf(listdf_pop$dfsc[1:8,1:9], boldfirstcolumn = F)
```


### Population main gene pool

We extract the main gene pool for each population.

```{r IdAdmixturePopulations}
# Split into dataframes specific to each population
gp_pop <- listdf_ind$df %>% 
  dplyr::select(clon,pop) %>% 
  left_join(read.csv("data/DryadRepo/PopulationStructureCorrea2015.csv") %>% dplyr::rename(pop=prov), by=c("pop","clon")) %>% 
  group_by(pop) %>% 
  group_split() %>% 
  setNames(unique(sort(listdf_ind$df$pop)))

# Are there some populations for which the main gene pool is not the same for all genotypes?
gp_pop %>% 
  map_dfr(\(x) {
    data.frame(Populations = unique(x$pop),
               MainGenePoolNumber = x$max.Q %>% unique() %>% length())
  }) %>% 
  group_by(MainGenePoolNumber) %>% 
  group_split()  %>% 
  map_dfr(\(x) {
    data.frame(Populations = paste0(x$Populations, collapse =", "),
               MainGenePoolNumber = unique(x$MainGenePoolNumber))
  }) %>% 
  kable_mydf(boldfirstcolumn = F)
```


The LEI and QUA populations have genotypes that belong to two different main gene pool, the main gene pool corresponding to the gene pool with the highest proportion of assignment from the STRUCTURE analysis in @jaramillo2015molecular.

We can visualize the admixture in the following tables.


```{r AdmixturePopulations}
gp_pop[["LEI"]] %>% kable_mydf(boldfirstcolumn = F)
gp_pop[["QUA"]] %>% kable_mydf(boldfirstcolumn = F)
```


```{r CreateNewColumWithMainGenePoolPopulations}
gp_pop <- gp_pop %>% 
  modify(\(x) mutate(x, mainGPpop= x$max.Q  %>% table() %>% which.max() %>% names())) %>% 
  list_rbind() %>% 
  dplyr::select(pop, mainGPpop) %>% 
  distinct()

# We add this column to the dataframes in  listdf_pop
listdf_pop <- listdf_pop %>% 
  modify(\(x) right_join(gp_pop,x,by="pop"))

saveRDS(listdf_pop, "outputs/RDA/RDA_explanatorydataframes_PopLevel.rds")

kable_mydf(listdf_pop$dfsc[1:8,1:7], boldfirstcolumn = F)
```


# Selecting the climatic variables

## Criteria 1: exposure to climate change{#ExpCC}


For each climatic variable:

   + we calculate the *mean* and *standard deviation* of its annual values for the reference period 1901-1950: $\mu_{ref}$ and $\sigma_{ref}$, respectively.
  
  + we calculate the *Z-score* of each of its annual values $X$ for a given future period, such as *Z-score* = $(X - \mu_{ref})/\sigma_{ref}$


```{r CalculatingZscoreExposureCC,warning=F}
# Time window for future climates:
min_fut_clim <- 2023
max_fut_clim <- 2050

# Do we average the z-scores across future years?
avg <- FALSE

# We load ClimateDT outputs 
raw_clim <-  read_csv("data/DryadRepo/ClimateDT/ClimateDToutputs_Populations_1901_2098.csv",
               show_col_types = FALSE)

# selected clim variables
var_clim <- colnames(raw_clim)[!colnames(raw_clim) %in% c("ID","Year","Longitude","Latitude","Elevation",clim_var_to_rm)]


# calculating the z-scores
zscores <- lapply(var_clim, function(x){
  
past_clim <- raw_clim %>% 
  dplyr::filter(Year<1951) %>%  # keep 1901 to 1950
  dplyr::select(ID,all_of(x)) %>% 
  group_by(ID) %>% 
  dplyr::summarise_all(list(mean="mean",sd="sd"))

# z-scores
zcores <- raw_clim %>% 
  dplyr::filter(Year>min_fut_clim & Year<max_fut_clim) %>% 
  dplyr::select(ID,Year,all_of(x)) %>% 
  dplyr::rename(var=x) %>% 
  left_join(past_clim,by="ID") %>% 
  dplyr::mutate(zscore=(var-mean)/sd) 

if(avg==TRUE){
  zcores <-  zcores %>% 
    group_by(ID) %>% 
    dplyr::summarise_at("zscore","mean")
} else{
  zcores <-  zcores %>% 
    dplyr::select(ID,Year,zscore)
}
  
}) %>% 
  setNames(var_clim) %>% 
  bind_rows(.id="var") 

# we sort the average z-scores (across populations and years) to determine 
# which climatic variables have the highest abs(Z-scores)
abs_mean_zscore <- zscores %>% 
  spread(var,zscore) %>% 
  mutate_if(is.numeric,abs) %>%
  dplyr::select(all_of(var_clim)) %>% 
  dplyr::summarise_all("mean") %>% 
  gather(variable, value) %>% 
  arrange(value)
```

```{r ViolinPlotExposureCC, fig.cap="\\large Deviation of future values of the climatic variables from the reference period 1901-1950. A point is specific to a given year and a given population", fig.height=10,fig.width=10, fig.align="center"}
# Violin plots
p <- zscores %>%
  mutate(var=factor(var,levels=c(abs_mean_zscore$variable))) %>% 
  ggplot(aes(x=var, y=zscore)) + 
  geom_jitter(shape=16,aes(colour = Year),position=position_jitter(0.2),size=0.5) +
  geom_violin(alpha=0.2) + 
  scale_colour_gradient2(low = "blue", mid="yellow",high = "red",midpoint=(max_fut_clim+min_fut_clim)/2) +
  coord_flip() +
  xlab("") + ylab("Z-scores") +
  theme_bw() +
  theme(legend.position=c(0.8, 0.7),
        legend.title = element_text(size = 18),
        legend.text = element_text(size = 15),
        axis.text = element_text(size = 14),
        axis.title = element_text(size=16),
        legend.box.background = element_rect(colour = "black"))

p %>% ggsave(file="figs/ExploratoryAnalyses/ExposureClimateChange.png",
             width=10,height=10)
p
```

*Temperature*-related variables show the *highest deviations* from their distribution under the reference period 1901-1950 and also all show a consistent increase across populations and years.

*Precipitation*-related variables show *lower deviations* from their distribution under the reference period 1901-1950. Moreover, they do not show a consistent decrease across years and populations. 

**Notes on the graph interpretation:** Figure \@ref(fig:ViolinPlotExposureCC) quantifies the relative deviations of the values of the climate variables from their distribution over the reference period 1901-1950. The highest deviations of temperature-related variables do not imply that populations will be less affected by future changes in precipitation than in temperatures.  Indeed, for some climate variables, even minor changes can severely affect populations. For example, some populations may already be suffering from summer droughts and even a small decrease in precipitation could have dramatic consequences.

## Criteria 2: a predictive approach{#StepwiseSelection}

To select the variables of interest, we may also use a *predictive approach* using *RDA with stepwise selection*, where the goal is to *maximize the genetic variance* explained by a set of predictors [@capblancq2021redundancy].

For that, we use the selection procedure from the `ordiR2step` function of the package `vegan`. 

We have to specify two models:

  - a *null* model where the response is explained only by an intercept.

  - a *full* model including all variables. 
  
In the `ordi2step` function, the default criteria for including the variables is based on both *significance* of the newly selected variables, and the comparison of *adjusted variation* ($R^2_{adj}$) explained by the selected variables to $R^2_{adj}$ explained by the full model. If the new variable is not significant or the $R^2_{adj}$ of the model including this new variable does not exceed the $R^2_{adj}$ of the full model, the selection procedure stops.

We use the following stopping criteria: variable significance of p < 0.01 using 1000 permutations, and the $R^2_{adj}$ of the full model.  

```{r NumberStewiseSelectionModels}
# How many iterations of the stepwise selection procedure do we perform?
nbmodels <- 100
```


```{r StepwiseSelectionPopLevel, eval=F}
# we standardize the climatic variables
climsc <- clim %>% dplyr::mutate(across(where(is.numeric), ~ (. - mean(.)) / sd(.)))

# null model
rda_null <- rda(geno_pop ~ 1, climsc)

# formula full model
formula_full_model <- colnames(climsc)[!colnames((climsc)) %in% c("pop","elevation","latitude","longitude")] %>% 
  paste(collapse= " + ") # climatic variables
formula_full_model <- paste0("geno_pop ~ ",formula_full_model) %>% as.formula()

# full model
rda_full <- rda(formula_full_model, climsc)

# Stepwise selection with ordiR2step function
sumstepwise <- lapply(1:nbmodels, function(x) {
  mod <- ordiR2step(rda_null, rda_full, Pin = 0.01, R2permutations = 1000, R2scope = T)
  return(names(mod$CCA$envcentre))}) %>% 
  setNames(paste0("model",1:nbmodels)) %>% 
  ldply(function(x) data.frame(variables=x),.id="models") %>%  
  dplyr::summarise(count(variables)) %>% 
  setNames(c("variable","count"))

saveRDS(sumstepwise,file=paste0("outputs/VariableSelection/SummaryStepwiseSelection_PopLevel_",nbmodels,"models.rds"))
```

```{r SummaryStepwiseSelection}
sumstepwise <- readRDS(file=paste0("outputs/VariableSelection/SummaryStepwiseSelection_PopLevel_",nbmodels,"models.rds"))

kable_mydf(sumstepwise, boldfirstcolumn = F)
```


## Criteria 3: biological meaning and study goals

Study goals:

  - evaluate the genomic offset predictions with different methods.
  
  - provide GO estimates for the studied populations to identify populations that may be at risk of maladaptation under climate change (those estimates will be provided based on the "best performing" genomic offset predictions in the evaluation part).
  
### Variable selection for the evaluation part

Importantly, it may be relevant not to select the same climatic variables for the different study goals and evaluation methods. 

Indeed, seedling survival in common gardens after a strong summer drought is likely to be mainly impacted by the differences in adaptation to drought conditions among populations. So, it may be relevant to estimate a genomic offset based only on climatic variables capturing summer droughts, aka a *summer-drought genomic offset* (ie *summer drought GO*).

To evaluate genomic offset predictions using height of young trees in common gardens as a proxy of fitness, both winter and summer temperature and precipitation variables can be used as they may all impact tree growth. However, it may still be interesting to compare the *summer drought GO* predictions with the GO predictions based on climatic variables capturing both winter and summer conditions (ie *global-climate genomic offset*, *global-climate GO*), as winter conditions may also impact tree growth in common gardens. 

In natural populations, climate change can *directly* impact tree mortality through more and more frequent and intense summer droughts. In contrast, an increase in winter temperatures is highly unlikely to directly impact the death of adult trees. Therefore, to determine whether current mortality rates in natural populations may be attributed to maladaptation to summer drought conditions, it may be relevant to evaluate the association between *drought genomic offset* predictions and mortality rates in National Forest Inventory plots.
On the other hand, increased temperatures in winter can benefit to pests and pathogens, which can indirectly impact tree death. In such a case, it may also be relevant to evaluate the association between mortality rates in NFI plots and GO predictions considering both winter and summer climatic conditions.
Note that in the NFI, a tree is not counted as dead if its death is attributed to pests. However, mortality is a multifactorial process and it can be very difficult (if not impossible) to determine the relative contributions of climate, pests and other factors to tree death.

Evaluation of the genomic offset predictions with ecophysiological models: I have to read the paper of Cailleux-Petit et al. to determine whether it is relevant to evaluate both *summer drought GO* and *global-climate GO* predictions.

### Variable selection for providing GO predictions for the studied populations

According to previous studies, maritime pine populations show strong patterns of adaption to temperatures, and especially cold temperatures (eg [@grivet2011molecular]). Under climate change, cold temperatures are expected to increase in average at the location of the studied populations (Figure \@ref(fig:ViolinPlotExposureCC)). An increase in cold temperatures is unlikely to directly negatively impact the fitness of adult trees but it may impact the survival of young trees, the reproductive ability and the impact of pests and pathogens. 

Thus, for the second objective of this paper (which is to provide GO estimates for the studied populations), whether or not to include winter conditions in GO predictions is a tricky question, for which there is probably no correct answer. 

In this paper, we will follow the following workflow:

  - if the predictions of *summer-drought GO* or *global-climate GO* are consistently better across the different evaluation methods, then we will provide these GO predictions for the studied populations.
  
  - if the predictions of *summer-drought GO* or *global-climate GO* are not consistently better across the different evaluation parts, then we will provide both the *summer-drought GO* or *global-climate GO* predictions for the studied populations.


## Selected variables

### Summer-drought climatic variables

Selected variables:

  - `MSP`: the precipitation of driest quarter (in mm).
  
  - `MWMT`: the mean warmest month temperature (in °C).
  

`MWMT` will increase a lot under climate change => strong exposure to climate change.

```{r VizSelectedDroughtVar, fig.width=5,fig.height=5}
## Selected summer-drought variables
drought_var <- list(name="Summer-drought variables",
                   code="Droughtvar",
                   variables=c("MSP","MWMT"))
```

### Global-climate variables

Selected variables:

  - `bio1`: mean annual temperature (in °C). 
  
  - `bio12`: annual precipitation (in mm).
  
  - `MSP`: summer precipitation (in mm).
  
  - `MWMT`: the mean warmest month temperature (in °C).
  
  - `MCMT`: the mean coldest month temperature (in °C).
  
  - `bio15`: mean annual temperature (in °C). 
  
  - `bio3`: isothermality (`bio2`/`bio7`) (x100) (index) with `bio2` the mean diurnal range (mean of monthly (max temp - min temp)) and `bio7` the temperature annual range (`bio5`-`bio6`, with `bio5` the max temperature of warmest month and `bio6` the minimum temperature of the coldest month).
  
  - `bio4`: temperature seasonality (standard deviation x100) (in °C). 
  

`bio1`, and to a lesser extent `MWMT`, will increase a lot under climate change => strong exposure to climate change.

```{r VizSelectedGlobalVar, fig.width=10,fig.height=10}
## Selected global-climate variables
global_var <- list(name="Global-climate variables",
                   code="GCvar",
                   variables=c("bio1","bio12","bio15","bio3","bio4")) #"MCMT","MWMT", "MSP"
```


### Viz correlation

We can look at the correlation amon variables and with the PCs scores and geographic variables.

```{r VizCorrSelectedVariables, fig.height=12,fig.width=12}
fig_options <- list(
  path = "figs/ExploratoryAnalyses/CorrplotSelectedClimVariables.png",
  width=900,
  height=900,
  res=100)

corrplot_var <- colnames(listdf_pop$df)[colnames(listdf_pop$df) %in% c("longitude","latitude","PC1","PC2","PC3",global_var$variables)]

make_corrplot(df = listdf_pop$df,#
              variables = corrplot_var, # we keep long, lat, elev and clim variables
              fig_options = fig_options)

listdf_pop$df %>%
  dplyr::select(all_of(corrplot_var)) %>%
  unique() %>%
  pairs.panels(scale=T,hist.col="palegreen1")
```


# Variance partitioning{#VarPart}

We want to disentangle the *relative contribution* of different factors in explaining genetic variation, namely:

  - *climate*, either captured by the *summer-drought* climate variables or the *global* climate variables.
  
  - *neutral population structure*, captured by the ancestry coefficients from @jaramillo2015molecular. 
  
  - *geography*, accounted for by the population coordinates (longitude and latitude).
  
  

We will run:

  - one *full* RDA with all factors (population structure, environment and geographical distance), i.e. no variable conditioning.
  
  - three *partial* RDA in which the factor of interest is conditioned by the other two factors.
  

  
```{r FunctionVarPart}
var_part <- function(df_geno, select_clim_var, df_var, scale_rda, center_rda){

# The df of the explanatory variables has to include only the variables included in the model
df_var <- df_var %>% 
  dplyr::select(all_of(select_clim_var$variables),
                starts_with("Q"),
                starts_with("PC"),
                ends_with("itude"))


# Build formulas of the RDA models
# ================================
form_clim_var <- paste(select_clim_var$variables,collapse= " + ") # climatic variables
form_pgs_var <- colnames(df_var) %>% stringr::str_subset("^Q|^PC") %>%  paste(collapse= " + ") # pop structure
form_geo_var <- colnames(df_var) %>% stringr::str_subset("itude") %>%  paste(collapse= " + ") # coordinates

# complete model formulas
form_full_rda <- paste("df_geno ~ ",
                       paste(c(form_clim_var,form_pgs_var,form_geo_var),collapse=" + " )) %>% 
  as.formula()

form_clim_rda <- paste("df_geno ~ ",
                       form_clim_var,"+ Condition(",paste(c(form_pgs_var,form_geo_var),collapse=" + " ), ")") %>% 
  as.formula()

form_pgs_rda <- paste("df_geno ~ ",
                       form_pgs_var,"+ Condition(",paste(c(form_clim_var,form_geo_var),collapse=" + " ), ")") %>% 
  as.formula()

form.geo_rda <- paste("df_geno ~ ",
                       form_geo_var,"+ Condition(",paste(c(form_clim_var,form_pgs_var),collapse=" + " ), ")") %>% 
  as.formula()


# Run the RDA models
# ==================

# Full RDA
full_rda <- rda(form_full_rda, 
                data=df_var, 
                scale=scale_rda,
                center=center_rda) 
anova_full_rda <- anova(full_rda)

# Partial RDA: pure climatic model
clim_rda <- rda(form_clim_rda, 
                data=df_var, 
                scale=scale_rda,
                center=center_rda)
anova_clim_rda <- anova(clim_rda)

# Partial RDA: pure neutral population structure model
pgs_rda <- rda(form_pgs_rda, 
                data=df_var, 
                scale=scale_rda,
                center=center_rda)
anova_pgs_rda <- anova(pgs_rda)

# Partial RDA: pure geography model
geo_rda <- rda(form.geo_rda, 
                data=df_var, 
                scale=scale_rda,
                center=center_rda)
anova_geo_rda <- anova(geo_rda)


# Summary table
# =============

sum_tab_RDA <- tibble("RDA models"=c("Full model: Y ~ clim + geo + pgs.",
                      "Pure climate model: Y ~ clim | (geo + pgs)",
                      "Pure pop. gen. structure model: Y ~ pgs | (geo + clim)",
                      "Pure geography model: Y ~ geo | (pgs + clim)"),
       "Total exp. variance"=c(RsquareAdj(full_rda)[[1]],
              RsquareAdj(clim_rda)[[1]],
              RsquareAdj(pgs_rda)[[1]],
              RsquareAdj(geo_rda)[[1]]),
       "Relative exp. variance"=c(1,
                                  RsquareAdj(clim_rda)[[1]]/RsquareAdj(full_rda)[[1]],
                                  RsquareAdj(pgs_rda)[[1]]/RsquareAdj(full_rda)[[1]],
                                  RsquareAdj(geo_rda)[[1]]/RsquareAdj(full_rda)[[1]]),
       "P-value"=c(anova_full_rda[["Pr(>F)"]][[1]],
                   anova_clim_rda[["Pr(>F)"]][[1]],
                   anova_pgs_rda[["Pr(>F)"]][[1]],
                   anova_geo_rda[["Pr(>F)"]][[1]]))

# Export the table in latex
xtable(sum_tab_RDA, type = "latex",digits=2) %>% 
  print(file = paste("tables/VariancePartitioningRDA_",select_clim_var$code,".tex"), include.rownames=FALSE)

return(sum_tab_RDA)
}
```

## Individual-based allele counts{#VarPartInd}

```{r VartPartIndividualLevel, eval=F}
list_sum_var_part <- lapply(c(global_var,drought_var), function(x){

  var_part(df_geno=geno_ind,
          select_clim_var=x,
          df_var=listdf_ind$dfsc, 
          scale_rda=F,center_rda=F)
}) %>% setNames(c(global_var$name,drought_var$name))

saveRDS(list_sum_var_part, file="outputs/RDA/SummaryVartPartIndividualLevel.rds")
```

```{r ShowSummaryVarPartIndividualLevel, eval=F}
list_sum_var_part <- readRDS(file="outputs/RDA/SummaryVartPartIndividualLevel.rds")

# Global-climate variables
kable_mydf(list_sum_var_part[[1]], boldfirstcolumn = T)


# Summer-drought climatic variables
kable_mydf(list_sum_var_part[[2]], boldfirstcolumn = T)
```

## Population-based allele frequencies{#VarPartPop}

```{r VartPartPopLevel, eval=F}
list_sum_var_part <- lapply(list(global_var,drought_var), function(x){
  
  var_part(df_geno=geno_pop,
           select_clim_var=x,
           df_var=listdf_pop$dfsc, 
           scale_rda=F,center_rda=F)
}) %>% setNames(c(global_var$name,drought_var$name))

saveRDS(list_sum_var_part, file="outputs/RDA/SummaryVartPartPopLevel.rds")
```

```{r ShowSummaryVarPartPopLevel, eval=F}
list_sum_var_part <- readRDS(file="outputs/RDA/SummaryVartPartPopLevel.rds")

# Global-climate variables
kable_mydf(list_sum_var_part[[1]], boldfirstcolumn = T)


# Summer-drought climatic variables
kable_mydf(list_sum_var_part[[2]], boldfirstcolumn = T)
```


# Identifying loci under selection

  
## Run the RDA

```{r FunctionToRunRDAmodels, eval=F}
# Functions
# =========

# create a S3 object with the RDA model and some info
new_RDA <- function(form_rda,selected_var,PCs,mod_rda,r2,eigenvalues,model_significance,axis_significance,vif){
  
  structure(
    .Data = list(form_rda=form_rda,
                 selected_var=selected_var,
                 PCs=PCs,
                 mod_rda=mod_rda,
                 r2=r2,
                 eigenvalues=eigenvalues,
                 model_significance=model_significance,
                 axis_significance=axis_significance,
                 vif=vif),
    creation_time = Sys.time(),
    class = "myrda"
  )
  
}

# function to print S3 object of class "myrda"
print.myrda <- function(x,...){

  print_message <- c(
    paste0("  RDA formula: ", x$form_rda),
    paste0("  Creation time: ", format(attr(x, "creation_time"))),
    paste0(c("  List elements:", names(x)),collapse="   ")
    )

  cat(
    print_message,
    sep = "\n"
  )

}

# function to run the RDA models and store the info in a S3 object of class "myrda"
runRDA <- function(df,geno_pop,selected_var,pop_structure_correction){


  
  # write RDA formulas
form_clim_var <- paste(selected_var$variables,collapse= " + ")
if(pop_structure_correction==T) {
  PCs <- colnames(df) %>% stringr::str_subset("^PC")
  form_pgs_var <- PCs %>%  paste(collapse= " + ")
  form_rda <- paste("geno_pop ~ ", form_clim_var,"+ Condition(",paste(c(form_pgs_var),collapse=" + " ), ")")
} else {
  PCs = NULL
  form_rda <- paste("geno_pop ~ ", form_clim_var) 
  }
mod_rda <- rda(as.formula(form_rda), df)
r2 <- RsquareAdj(mod_rda)
eigenvalues <- summary(eigenvals(mod_rda, model = "constrained"))
model_significance <- anova.cca(mod_rda, parallel=getOption("mc.cores")) # default is permutation=999
axis_significance <- anova.cca(mod_rda, by="axis", parallel=getOption("mc.cores"))
vif <- vif.cca(mod_rda)

return(new_RDA(form_rda=form_rda,
               selected_var=selected_var,
               PCs=PCs,
               mod_rda=mod_rda,
               r2=r2,
               eigenvalues=eigenvalues,
               model_significance=model_significance,
               axis_significance=axis_significance,
               vif=vif))
  
}



# function to visualize RDA model outputs 
viz_RDAsummary <- function(x){
  
  # check the class of x
  stopifnot("x is not of class myrda" = class(x)=="myrda")
  
  # Generate R2 table
r2_tab <- x$r2 %>% 
  as.data.frame() %>%
  pivot_longer(everything()) %>%  
  column_to_rownames(var ="name") %>% 
  round(2) %>% 
  ggtexttable(rows = row.names(.),cols = NULL, theme = ttheme("blank"))
  
  # Generate table of eigenvalues and proportion of variance explained
eigenvalues_tab <- x$eigenvalues %>% 
  as.data.frame() %>% 
  round(2) %>% 
  ggtexttable(rows = rownames(.), theme = ttheme("blank")) %>% 
  tab_add_hline(at.row = 1:2, row.side = "top", linewidth = 2)

  # Generate table of model and axis significance
signi_tab <- bind_rows(as.data.frame(x$model_significance[-nrow(x$model_significance),]),
          as.data.frame(x$axis_significance[-nrow(x$axis_significance),])) %>% 
  dplyr::mutate(across(!Df, ~ round(.x,3))) %>% 
  ggtexttable(rows = rownames(.), theme = ttheme("blank")) %>% 
  tab_add_hline(at.row = 1:2, row.side = "top", linewidth = 2) %>% 
  tab_add_hline(at.row = 3, row.side = "top", linewidth = 0.01)

  # Generate table for VIF (Variance Inflation Factors)
vif_tab <- x$vif %>% 
  as.data.frame() %>% 
  round(2) %>% 
  rownames_to_column("Variable") %>%
  pivot_wider(values_from=".", names_from = "Variable") %>% 
  ggtexttable(rows = "VIF", theme = ttheme("blank")) %>% 
  tab_add_hline(at.row = 2, row.side = "top", linewidth = 2) 
  
  # Generate the screeplot of the eigenvalues
ggscreeplot <- x$eigenvalues %>% #
  as.data.frame() %>% 
  dplyr::filter(row.names(.) == "Eigenvalue")  %>% 
  pivot_longer(everything(),names_to="PC",values_to="eigenvalues") %>%
  ggplot(aes(x= PC,
             y=eigenvalues,
             group=1)) +
  geom_point(size=4)+
  geom_line() +
  ylab("Eigen values") + xlab("") + 
  labs(title="Scree plot") + 
  theme_bw()


ggarrange(ggarrange(r2_tab,signi_tab,vif_tab,nrow=3),
           ggarrange(eigenvalues_tab,ggscreeplot,nrow=2), 
           nrow = 1, 
           ncol = 2) %>% 
annotate_figure(top = text_grob(x$form_rda, 
                                size = 16, 
                                color = 'black', 
                                face = 'bold'))
  
}


# function to plot the RDA models
plot_RDA <- function(df,x){
  
  # check the class of x
  stopifnot("x is not of class myrda" = class(x)=="myrda")
  
  # The genotypes points are colored based on the main gene pool the belong to.
  bg <- c("orangered3","gold2","darkorchid3","navyblue","turquoise2","green3") # define the colors
  GPs <- df$mainGPpop %>%  as.factor()
  levels(GPs) <- list("Northern Africa" = "Q1",
                      "Corsica" = "Q2",
                      "Central Spain" = "Q3",
                      "French Atlantic" = "Q4",
                      "Iberian Atlantic" = "Q5",
                      "South-eastern Spain" = "Q6")
  
  if(x$axis_significance %>% as.data.frame() %>% nrow()-1>2) {
  par(mfrow=c(1,2))
  rdaplots <-  lapply(2:3, function(second.axis){
    plot(x$mod_rda, type="n", scaling=3, choices=c(1,second.axis))
    points(x$mod_rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3, choices=c(1,second.axis))
    points(x$mod_rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs], choices=c(1,second.axis))
    text(x$mod_rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,second.axis))
    if(second.axis==2) legend("topleft", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
    recordPlot()
  })} else {
    par(mfrow=c(1,1))
    plot(x$mod_rda, type="n", scaling=3, choices=c(1,2))
    points(x$mod_rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3, choices=c(1,2))
    points(x$mod_rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs], choices=c(1,2))
    text(x$mod_rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,2))
    legend("bottomright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
  }
  
  title(x$form_rda, line=-3,outer = TRUE)
}

```



```{r RunRDAmodels, eval=F}
# Combinations of selected variables and correction or not by population structure
rda_combinations <- list(
  list(selected_var = global_var,
       pop_structure_correction = FALSE),
  list(selected_var = global_var,
       pop_structure_correction = TRUE),
  list(selected_var = drought_var,
       pop_structure_correction = FALSE),
  list(selected_var = drought_var,
       pop_structure_correction = TRUE))


# Run the RDA models and store their information
rda_models <- lapply(rda_combinations, function(x){
  runRDA(df = listdf_pop$dfsc,
         geno_pop = geno_pop,
         selected_var = x$selected_var,
         pop_structure_correction = x$pop_structure_correction)})

# save the RDA models and their information
saveRDS(rda_models, "outputs/RDA/RDAmodels.rds")

# viz RDA models and their summary information
pdf(width = 10, height = 6, "figs/RDA/RDAsummary.pdf")
lapply(rda_models, viz_RDAsummary)
dev.off()


# plot RDA models
pdf(width = 12, height = 8, "figs/RDA/RDAplots.pdf")
lapply(rda_models, function(x) plot_RDA(df=listdf_pop$dfsc,x=x))
dev.off()
```

```{r LoadListRDAModels}
rda_models <- readRDS("outputs/RDA/RDAmodels.rds")
```

## Identify outliers

Two ways of identifying the outliers with the RDA:

  - identifying outliers based on their *extremeness* along a *distribution of Mahalanobis distances* estimated between each locus and the center of the RDA space using a certain number of axes (K). Method used in @capblancq2020climate (see [code](https://github.com/Capblancq/Local-Adaptation-Fagus-sylvatica)) and @capblancq2021redundancy ([code](https://github.com/Capblancq/RDA-landscape-genomics)).

  - identifying RDA outliers is to search for *extreme loadings on each retained axis*. Method used in @forester2018comparing (see [code](https://popgen.nescent.org/2018-03-27_RDA_GEA.html)
  
```{r echo=F}
# !!! Temporary chunk !!!
rda_models <- readRDS("outputs/RDA/RDAmodels.rds")
listdf_pop <- readRDS("outputs/RDA/RDA_explanatorydataframes_PopLevel.rds")
```

  
```{r FunctionToIdentifyOutliers}

identify_outliers <- function(rda_model, explanatory_data, geno_data){

# outlier detection based on  extreme Mahalanobis distances from the RDA center
# =============================================================================

# Genome scan with K = 2 (degrees of freedom of the X2 distribution)
GSout <- rdadapt(rda_model$mod_rda, 2)

# P-values threshold after Bonferroni correction
thres <- 0.01/length(GSout$p.values)

# Identifying the loci that are below the p-value threshold
outliers_maha <- which(GSout$p.values<thres)
outliers_maha <- tibble(snp = colnames(geno_data)[outliers_maha], 
                        maha_meth = TRUE,
                        #pvalue = GSout$p.values[outliers_maha]
                        )

# nb_outliers_maha <- nrow(outliers_maha)

# outlier detection based on  extreme axis loadings
# =================================================

nb_signi_axis <- rda_model$axis_significance %>% 
  as.data.frame() %>% 
  dplyr::rename(pvalue="Pr(>F)") %>% 
  dplyr::filter(pvalue<0.05) %>% 
  nrow()
  
loads <- scores(rda_model$mod_rda, choices=c(1:(nrow(as.data.frame(rda_model$axis_significance))-1)), display="species")
  

outliers_loads <- lapply(1:nb_signi_axis, function(id.axis){
  out <- detectoutliers(loads[,id.axis],3)
  tibble(
    #axis=rep(id.axis,times=length(out)), # we do not keep the information about the axis
    snp = names(out),
    load_meth = TRUE,
    # loading = out # we do not keep the loadings
  )
}) %>% 
  list_rbind() %>% 
  distinct()

 # nb_outliers_loads <- nrow(outliers_loads)


# Merge outliers identified by the two methods
# ============================================

all_outliers <- full_join(outliers_maha,outliers_loads, by="snp") %>% 
  mutate(across(c(maha_meth,load_meth), ~replace_na(.,FALSE)))

all_outliers <- map(all_outliers$snp, function(snp){
 cordf <-  cor(explanatory_data[,names(rda_model$vif)],geno_data[,snp]) %>% 
    as.data.frame() %>% 
    rownames_to_column() %>% 
    pivot_wider(names_from="rowname", values_from = "V1") %>% 
     mutate(max_var = names(which.max(abs(.)))) %>% 
     mutate(max_var_clim = names(which.max(abs(.[,rda_model$selected_var$variables]))))
}) %>%
  setNames(all_outliers$snp) %>% 
  list_rbind(names_to = "snp") %>% 
  inner_join(all_outliers,by="snp")


list(rda_model = rda_model,
     outliers = all_outliers)

}
```

```{r IdentifyOutliers}
rda_outliers <- rda_models %>% 
  lapply(function(x) {
    identify_outliers(rda_model = x, explanatory_data = listdf_pop$dfsc, geno_data = geno_pop)
  })
```


```{r FunctionToPlotRDAoutliers}
# Function to make one RDA plot with different colors for outlier SNPs
make_one_outlier_rda_plot <- function(mod_rda, data_plots, xlim, ylim, second_axis,arrow_length,outline_col){
  
plot(mod_rda, type="n", scaling=3, xlim=xlim, ylim=ylim, choices=c(1,second_axis))
points(mod_rda, display="species", pch=21, cex=1, col=data_plots$allsnps$nooutlier_color, bg=data_plots$allsnps$nooutlier_bg , scaling=3, choices=c(1,second_axis))
points(mod_rda, display="species", pch=21, cex=1, col=data_plots$allsnps$outlier_color, bg=data_plots$allsnps$outlier_bg, scaling=3, choices=c(1,second_axis))
text(mod_rda, scaling=3, display="bp", col="#0868ac", cex=1, arrow.mul=arrow_length, choices=c(1,second_axis))
legend("topleft", legend=data_plots$legend_names, bty="n", col=outline_col, pch=21, cex=1, pt.bg=data_plots$legend_colors,ncol=1,title=data_plots$legend_title) 
recordPlot()

}




# Function that combines two types of plot:
  # plots in which outliers are colored according to their most associated climatic variable
  # plots in which outliers are colored according to the detection method used to identify them:
      # a method based on the Mahalanobis distances from the center of the RDA space
      # a method based on the extreme SNP loadings on each significant axis
combine_rda_outlier_plots <- function(rda_out){

# Storing data and options to generate the plots in a list
list_data_plots <- list(clim=list(), # options/data specific to plots with colors based on the climatic variables
                        meth=list()) # options/data specific to plots with colors based on the detection methods


# Figure options shared between the two types of plot
# ===================================================

nooutliers_bg <- '#f1eef6'
outline_col <- 'gray32'
transparent_col <- rgb(0,1,0, alpha=0)


  
# Fig options/data specific to plots based on the climatic variables
# ==================================================================

# Attribute one color to each climatic variable 
selected_var <- c(global_var$variables, drought_var$variables) %>% unique()
some_colors <- c('#1f78b4','#a6cee3','#6a3d9a','#e31a1c','#33a02c','#ffff33','#fb9a99','#b2df8a')
selected_var_colors <- tibble(max_var_clim = selected_var,
                              outlier_bg = some_colors[1:length(selected_var)]) %>% 
  dplyr::filter(max_var_clim %in% rda_out$rda_model$selected_var$variables)

# Generate a dataframe with color information for outliers
outlier_colors <-  rda_out$outliers %>% 
  dplyr::select(snp, max_var_clim) %>% 
  left_join(selected_var_colors, by="max_var_clim")
 
# Generate a dataframe with color information for all SNPs
list_data_plots$clim$allsnps <- tibble(snp=rownames(rda_out$rda_model$mod_rda$CCA$v)) %>% 
  left_join(outlier_colors, by="snp") %>% 
  mutate(outlier_bg = replace_na(outlier_bg,transparent_col),
         outlier_color = ifelse(outlier_bg == transparent_col, transparent_col, outline_col),
         nooutlier_bg = ifelse(outlier_bg == transparent_col, nooutliers_bg, transparent_col),
         nooutlier_color = ifelse(outlier_bg == transparent_col, outline_col, transparent_col))

# Legend options
list_data_plots$clim$legend_title <- 'Climatic variable'
list_data_plots$clim$legend_names <- selected_var_colors$max_var_clim
list_data_plots$clim$legend_colors <- selected_var_colors$outlier_bg

  
# Fig options/data specific to plots based on the detection methods
# =================================================================

# Attribute one color to each method
method_colors <- c('#FCF926','#3BCD24','#CD24B2') %>% setNames(c("Mahalanobis distance","Axis loadings", "Both"))

# Legend options
list_data_plots$meth$legend_colors <- method_colors
list_data_plots$meth$legend_names <- names(method_colors)
list_data_plots$meth$legend_title <- 'Outlier detection method'


# attribute colors to all SNPs
list_data_plots$meth$allsnps <-  tibble(snp=rownames(rda_out$rda_model$mod_rda$CCA$v)) %>% 
  left_join(rda_out$outliers[,c("snp", "load_meth", "maha_meth")],by="snp") %>%  
  mutate(outlier_bg = case_when(load_meth == TRUE & maha_meth == TRUE ~ method_colors["Both"],
                                load_meth == TRUE & maha_meth == FALSE ~ method_colors["Axis loadings"],
                                load_meth == FALSE & maha_meth == TRUE ~ method_colors["Mahalanobis distance"],
                                is.na(load_meth) & is.na(maha_meth) ~ transparent_col),
         outlier_color = ifelse(outlier_bg == transparent_col, transparent_col, outline_col),
         nooutlier_bg = ifelse(outlier_bg == transparent_col, nooutliers_bg, transparent_col),
         nooutlier_color = ifelse(outlier_bg == transparent_col, outline_col, transparent_col))


# Generate the RDA plots
# =====================

# For RDA models with 2 explanatory variables, we can only plot RDA1 vs RDA2

if(rda_out$rda_model$axis_significance %>% as.data.frame() %>% nrow()-1>2) { # rda models with more than 2 climatic variables
    
par(mfrow=c(2,2))
lapply(2:3, function(second_axis){ # generate two plots: RDA1 vs RDA2 and RDA1 vs RDA3
    lapply(list_data_plots, function(x) make_one_outlier_rda_plot(mod_rda = rda_out$rda_model$mod_rda,
                                                                  data_plots = x,
                                                                  xlim=c(-1,1), 
                                                                  ylim=c(-0.5,0.5),
                                                                  arrow_length=1.25,
                                                                  outline_col=outline_col,
                                                                  second_axis=second_axis))

  })} else {  # rda models with 2 climatic variables

par(mfrow=c(1,2))
    lapply(list_data_plots, function(x) make_one_outlier_rda_plot(mod_rda = rda_out$rda_model$mod_rda,
                                                                  data_plots = x,
                                                                  xlim=c(-0.3,0.3), 
                                                                  ylim=c(-0.5,0.5),
                                                                  outline_col=outline_col,
                                                                  arrow_length=0.6,
                                                                  second_axis=2))
    
  }

  title(rda_out$rda_model$form_rda, line=-3,outer = TRUE) # rda model formula as title
   
}
```



```{r PlotRDAoutliers}
# Plot RDA outliers with different colors based either on the detection method or the most asspciated climatic variable
pdf(width = 12, height = 8, "figs/RDA/RDAplots_outliers.pdf")
lapply(rda_outliers, combine_rda_outlier_plots)
dev.off()
```



```{r OldFunctionsPlotOutliersRDA, eval=F, echo=F}
# Function to plot outliers in RDA plots and color them based on their most associated climatic variable
plot_outliers_clim <- function(rda_out){

# attribute one color to each climatic variable 
selected_var <- c(global_var$variables, drought_var$variables) %>% unique()
some_colors <- c('#1f78b4','#a6cee3','#6a3d9a','#e31a1c','#33a02c','#ffff33','#fb9a99','#b2df8a')
selected_var_colors <- tibble(max_var_clim = selected_var,
                              outlier_bg = some_colors[1:length(selected_var)]) %>% 
  dplyr::filter(max_var_clim %in% rda_out$rda_model$selected_var$variables)


# Some color options for the figures
nooutliers_bg <- '#f1eef6'
outline_col <- 'gray32'
transparent_col <- rgb(0,1,0, alpha=0)
legend_title <- 'Most associated climatic variable'
legend_names <- selected_var_colors$max_var_clim
legend_colors <- selected_var_colors$outlier_bg
  
# attribute colors to the outliers
outliers <- rda_out$outliers %>% 
  dplyr::select(snp, max_var_clim) %>% 
  left_join(selected_var_colors, by="max_var_clim")

# attribute colors to all SNPs
allsnps <- tibble(snp=rownames(rda_out$rda_model$mod_rda$CCA$v)) %>% 
  left_join(outliers, by="snp") %>% 
  mutate(outlier_bg = replace_na(outlier_bg,transparent_col),
         outlier_color = ifelse(outlier_bg == transparent_col, transparent_col, outline_col),
         nooutlier_bg = ifelse(outlier_bg == transparent_col, nooutliers_bg, transparent_col),
         nooutlier_color = ifelse(outlier_bg == transparent_col, outline_col, transparent_col))

# Generate the rda plots
if(rda_out$rda_model$axis_significance %>% as.data.frame() %>% nrow()-1>2) {
par(mfrow=c(1,2))
rdaplots <-  lapply(2:3, function(second.axis){
    
plot(rda_out$rda_model$mod_rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-0.5,0.5), choices=c(1,second.axis))
points(rda_out$rda_model$mod_rda, display="species", pch=21, cex=1, col=allsnps$nooutlier_color, bg=allsnps$nooutlier_bg , scaling=3, choices=c(1,second.axis))
points(rda_out$rda_model$mod_rda, display="species", pch=21, cex=1, col=allsnps$outlier_color, bg=allsnps$outlier_bg, scaling=3, choices=c(1,second.axis))
text(rda_out$rda_model$mod_rda, scaling=3, display="bp", col="#0868ac", cex=1, arrow.mul=1.25, choices=c(1,second.axis))
if(second.axis==2) legend("topleft", legend=legend_names, bty="n", col=outline_col, pch=21, cex=1, pt.bg=legend_colors,ncol=1,title=legend_title)
    recordPlot()
  })} else {
    par(mfrow=c(1,1))

plot(rda_out$rda_model$mod_rda, type="n", scaling=3, xlim=c(-0.3,0.3), ylim=c(-0.5,0.5), choices=c(1,2))
points(rda_out$rda_model$mod_rda, display="species", pch=21, cex=1, col=allsnps$nooutlier_color, bg=allsnps$nooutlier_bg , scaling=3, choices=c(1,2))
points(rda_out$rda_model$mod_rda, display="species", pch=21, cex=1, col=allsnps$outlier_color, bg=allsnps$outlier_bg, scaling=3, choices=c(1,2))
text(rda_out$rda_model$mod_rda, scaling=3, display="bp", col="#0868ac", cex=1, arrow.mul=0.7, choices=c(1,2))
legend("topleft", legend=legend_names, bty="n", col=outline_col, pch=21, cex=1, pt.bg=legend_colors,ncol=1,title=legend_title)    
    
  }

  title(rda_out$rda_model$form_rda, line=-3,outer = TRUE)
}





# Function to plot outliers in RDA plots and color them based on the detection method
plot_outliers_meth <- function(rda_out){

# attribute one color to each climatic variable 
method_colors <- c('#FCF926','#3BCD24','#CD24B2')
names(method_colors) <- c("Mahalanobis distance","Axis loadings", "Both")

# Some color options for the figures
nooutliers_bg <- '#f1eef6'
outline_col <- 'gray32'
transparent_col <- rgb(0,1,0, alpha=0)
legend_title <- 'Outlier detection method'

# attribute colors to the outliers
outliers <- rda_out$outliers %>% 
  dplyr::select(snp, load_meth, maha_meth)

# attribute colors to all SNPs
allsnps <- tibble(snp=rownames(rda_out$rda_model$mod_rda$CCA$v)) %>% 
  left_join(outliers, by="snp") %>% 
  mutate(outlier_bg = case_when(load_meth == TRUE & maha_meth == TRUE ~ method_colors["Both"],
                                load_meth == TRUE & maha_meth == FALSE ~ method_colors["Axis loadings"],
                                load_meth == FALSE & maha_meth == TRUE ~ method_colors["Mahalanobis distance"],
                                is.na(load_meth) & is.na(maha_meth) ~ transparent_col),
         outlier_color = ifelse(outlier_bg == transparent_col, transparent_col, outline_col),
         nooutlier_bg = ifelse(outlier_bg == transparent_col, nooutliers_bg, transparent_col),
         nooutlier_color = ifelse(outlier_bg == transparent_col, outline_col, transparent_col))

# Generate the rda plots
if(rda_out$rda_model$axis_significance %>% as.data.frame() %>% nrow()-1>2) {
par(mfrow=c(2,2))
rdaplots <-  lapply(2:3, function(second.axis){
    
plot(rda_out$rda_model$mod_rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-0.5,0.5), choices=c(1,second.axis))
points(rda_out$rda_model$mod_rda, display="species", pch=21, cex=1, col=allsnps$nooutlier_color, bg=allsnps$nooutlier_bg , scaling=3, choices=c(1,second.axis))
points(rda_out$rda_model$mod_rda, display="species", pch=21, cex=1, col=allsnps$outlier_color, bg=allsnps$outlier_bg, scaling=3, choices=c(1,second.axis))
text(rda_out$rda_model$mod_rda, scaling=3, display="bp", col="#0868ac", cex=1, arrow.mul=1.25, choices=c(1,second.axis))
if(second.axis==2) legend("topleft", legend=names(method_colors), bty="n", col=outline_col, pch=21, cex=1, pt.bg=method_colors,ncol=1, title=legend_title)
    recordPlot()
  })} else {
    par(mfrow=c(1,1))

plot(rda_out$rda_model$mod_rda, type="n", scaling=3, xlim=c(-0.3,0.3), ylim=c(-0.5,0.5), choices=c(1,2))
points(rda_out$rda_model$mod_rda, display="species", pch=21, cex=1, col=allsnps$nooutlier_color, bg=allsnps$nooutlier_bg , scaling=3, choices=c(1,2))
points(rda_out$rda_model$mod_rda, display="species", pch=21, cex=1, col=allsnps$outlier_color, bg=allsnps$outlier_bg, scaling=3, choices=c(1,2))
text(rda_out$rda_model$mod_rda, scaling=3, display="bp", col="#0868ac", cex=1, arrow.mul=0.7, choices=c(1,2))
legend("topleft", legend=names(method_colors), bty="n", col=outline_col, pch=21, cex=1, pt.bg=method_colors,ncol=1, title=legend_title)    
    
  }

  title(rda_out$rda_model$form_rda, line=-3,outer = TRUE)
}


# plot RDA models with outliers
pdf(width = 12, height = 8, "figs/RDA/RDAplots_outliers.pdf")
lapply(rda_outliers, plot_outliers_clim)
lapply(rda_outliers, plot_outliers_meth)
dev.off()

```







# References
