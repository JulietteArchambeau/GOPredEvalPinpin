---
title: "LFMM analysis"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    toc: true
    toc-depth: 4
    code-fold: true
    page-layout: full
embed-resources: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body {
   font-size: 15px;
}
code.r{
  font-size: 11px;
}
pre {
  font-size: 11px
}

table {
  font-size: 10px
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 7,fig.height = 5,cache=F)
options(width = 300)
library(knitr)      # CRAN v1.26
library(tidyverse)  # CRAN v1.3.0
library(readxl)     # CRAN v1.3.1
library(xtable)
library(reshape2)
library(kableExtra)
library(here)
library(LEA)


# my own function for building tables in reports
source(here("scripts/functions/kable_mydf.R"))
```


# Introduction
 
Document based on @gain2021lea and the [LEA tutorial](https://github.com/bcm-uga/SSMPG2022) provided during the summer school *Software and Statistical Methods for Population Genetics* ([SSMPG 2022](https://ssmpg.sciencesconf.org/); Aussois, September 19-23 2022).

The **latent factor mixed model** (LFMM) is a multivariate mixed regression model that estimates *simultaneously* the effects of environmental variables (fixed effects) and unobserved confounders called latent factors [@frichot2013testing; @caye2019lfmm]. The latent factors are computed both from the genomes and from their environment. They are not representing neutral population structure (i.e. they have less direct interpretations than in ancestry estimation methods). Instead, they can be interpreted as the best estimates of the confounding effects of neutral population structure, leading to environmental effect size estimates with minimal bias.

# Population structure

<span style="color: orange;">**COMMENT: this section is not used in the paper (=> can be skipped!).**</span> Indeed, the analyses in this section are only useful if we want to estimate the population structure and impute missing data with the `LEA` package. In our study, we use the population structure estimates (the ancestry coefficients) from @jaramillo2015molecular, and we impute the missing data based on the most common allele in the gene pool. And in the RDA, we do not use the ancestry coefficients to account for population structure; we use PC scores.


From the `LEA` package manual: The function `snmf` of the `lfmm2` package estimates admixture coefficients using sparse Non-Negative Matrix Factorization algorithms, and provides STRUCTURE-like outputs. The input file has to be in the `geno` format, with one row for each SNP. Each row contains 1 character for each individual: 0 means zero copy of the reference allele. 1 means one copy of the reference allele. 2 means two copies of the reference allele. 9 means missing data.


```{r LoadImtGenDataMAF, results="hide"}
geno <-  read.csv(here("data/DryadRepo/FormattedFilteredGenomicData_AlleleCounts_withmaf.csv")) %>% 
  column_to_rownames("snp_ID") %>% 
  dplyr::mutate(across(everything(), ~replace_na(.x, 9))) %>% 
  t() %>% 
  as.data.frame()

geno %>% write.geno(here("data/LEAanalysis/AlleleCounts_GenoFormat.geno"))

kable_mydf(geno[1:10,1:8], boldfirstcolumn = F)
```

From @gain2021lea: 

Assuming $n$ diploid organisms genotyped at $L$ loci, the `snmf` algorithm decomposes the $n × L$ matrix of observed allele frequencies, $P$, in a product of two probabilistic matrices:

$$P \approx QF$$

where the coefficients of $P$ take their values in {0,1/2,1} for diploid organisms (note: ploidy can be modified in `snmf`). The matrix $Q$ is similar to the $Q$ matrix of STRUCTURE, representing ancestry coefficients for individuals originating from $K$ source populations [@pritchard2000inference], and is a $n × K$ matrix. The matrix $F$ contains allele frequencies at each locus for each source population and is a  $K × 3L$ matrix. While $P$ may contain some missing values, the product matrix, $QF$, is always a complete probabilistic matrix. $P$ is a $n × 3L$ matrix.

Comment: The matrix $F$ is called the matrix $G$ in the `LEA` package and in @frichot2013testing.

```{r RunSnmf, eval=F}
proj_snmf <- snmf(here("data/LEAanalysis/AlleleCounts_GenoFormat.geno"), 
                  K=1:10, 
                  repetitions = 10, # nb of repetitions for each K
                  entropy = TRUE,
                  project="new")
```

```{r LoadSnmfProject}
proj_snmf <- load.snmfProject(here("data/LEAanalysis/AlleleCounts_GenoFormat.snmfProject"))
```


We plot the cross-entropy criterion  of all run of the project.

```{r PlotCrossEntropy}
plot(proj_snmf, cex = 1.2, col = "lightblue", pch = 19)
```

We get the cross-entropy of the 10 runs for K = 6 and we select the run with the lowest cross entropy

```{r ExtractLowestCrossEntropy}
ce <- cross.entropy(proj_snmf, K = 6)

best <- which.min(ce)
```

We display the Q-matrix.

```{r Qmatrix, fig.width=10}
gp_colors <- c("orangered3","gold2","darkorchid3","navyblue","turquoise2","green3") # define the colors of the gene pools

bp <- barchart(proj_snmf, K = 6,  run= best,
               border = NA, space = 0, col = gp_colors, 
               xlab = "Individuals", ylab = "Ancestry proportions", 
               main = "Ancestry matrix")
        
axis(1, at = 1:length(bp$order), labels = bp$order, las = 3, cex.axis = .4)
```

We use the `G` function to extract the **ancestral genotype frequency matrix**, $G$, for the 2nd run for K = 6. 

```{r Gmatrix}
Gmatrix <- G(proj_snmf, K = 6, run = best)

Gmatrix[1:5,1:6] %>% 
  as.data.frame() %>% 
  kable_mydf(boldfirstcolumn = F)
```

# Estimating gene-environment associations


## Input data

### Past climatic data{#PastClim}

We load the population-specific climatic information for the climatic variables of interest. To run `lfmm2`, individuals (genotypes in our case) have to be in rows and climatic variables in columns.

```{r LoadClimaticData}
# we load the names of the selected climatic variables
clim_var <- readRDS(here("data/ClimaticData/NamesSelectedVariables.rds")) %>% 
  `[[`(3) # We keep the set 3 of climatic variables (the third list element)

# we load the population-specific data of the climatic variables of interest
clim_past <- read_csv(here("data/DryadRepo/PopulationCoordinatesPastClimateInformation.csv"),
               show_col_types = FALSE) %>% 
  dplyr::select(pop,clim_var$variables) # we keep only the climatic variables of interest
```

We have to scale (i.e. mean-center) the climatic variables, but we have to keep the scaling parameters to scale present and future climatic data with the same parameter values. So we save the mean and standard deviation of the climatic variables in a list.

```{r SaveScalingParams}
scale_params <- lapply(clim_var$variables, function(x){
  
  vec_var <- clim_past[,x] %>% pull()
  
  list(mean = mean(vec_var),
       sd = sd(vec_var))
  
}) %>% setNames(clim_var$variables)
```

Then we mean-center the climatic variables.

```{r ScalingClimaticVariables}
clim_past <- clim_past %>% 
  dplyr::mutate(across(where(is.numeric), ~ (. - mean(.)) / sd(.)))
```

We attribute climatic values to each genotype, i.e. genotypes from the same populations will have the same climatic values.

```{r GenotypeLevelClimaticVariables}
genotypes <- geno %>% 
  rownames_to_column("clon") %>% 
  dplyr::select(clon) %>% 
  as_tibble()

clim_past <- genotypes %>% 
  mutate(pop = str_sub(clon,1,3)) %>% 
  left_join(clim_past, by="pop") %>% 
  dplyr::select(-pop,-clon)
```

### Genomic data

We load the genomic data. The genomic has to be allele counts without missing data, with individuals (genotypes) in rows and SNPs in columns.

```{r LoadImputedAlleleCounts}
# we load the imputed genomic data with allele counts (and without MAF)
geno <-  read.csv(here("data/DryadRepo/ImputedGenomicData_AlleleCounts_withoutmaf.csv")) %>% 
  column_to_rownames("snp_ID") %>% 
  t() %>% 
  as_tibble()
```

## Run lfmm2 and calibration issues


From @caye2019lfmm: LFMMs are regression models combining fixed and latent effects as follows:

$$ \mathbf{Y}  = \mathbf{XB}^T + \mathbf{W} + \mathbf{E}$$

$\mathbf{Y}$ is the response matrix, which records data for $n$ individuals genotyped for $p$ genetic markers. $\mathbf{X}$ is the matrix of the *environmental* or *primary* variables. *Nuisance* variables such as observed confounders can be included in the $\mathbf{X}$ matrix, which dimension is then $n \times d$, where $d$ represents the total number of *primary* and *nuisance* variables.
The fixed effect sizes are recorded in the $\mathbf{B}$ matrix, which has dimension $p \times d$.
The $\mathbf{E}$ matrix represents residual errors, and it has the same dimensions as the response matrix. 
The matrix $\mathbf{W}$ is a “latent matrix” of rank $K$,defined by $K$ latent factors. The $K$ latent factors represent unobserved confounders which are modeled through an $n \times K$ matrix, $\mathbf{U}$.The matrix $\mathbf{U}$ is obtained from a singular value decomposition (SVD) of the matrix $\mathbf{W}$ as follows

$$\mathbf{W} = \mathbf{UV}^T $$$
where $\mathbf{V}$ is a $p \times K$ matrix of loadings. The $\mathbf{U}$ and $\mathbf{V}$ matrices are unique up to arbitrary signs for the factors and loadings.

As there are 6 gene pools in maritime pine (all represented in our population sample), we run the LFMM model with **K=5**.

```{r RunLFMMmodel}
mod_lfmm2 <- lfmm2(input = geno,
                   env = clim_past, 
                   K = 5)
```

The function `lfmm2` returns an object of class `lfmm2Class` that contains the $\mathbf{U}$ and $\mathbf{V}$ matrices.

With the function `lfmm2.test`, we can get a vector of p-values for association between loci and climatic variables adjusted for latent factors computed by `lfmm2`. 

**The `full` option:**

  - If `FALSE`, the function `lfmm2.test` computes significance values (p-values) from *standard Student tests* for each climatic variable.

  - If `TRUE`, the function `lfmm2.test` returns p-values for the full set of climatic variables (a single value at each locus) using *Fisher tests*.


**The `genomic.control` option:**

  - If `TRUE` (**default option**), the p-values are recalibrated by using genomic control after correction for confounding.
  
  - If `FALSE`, the p-values are not recalibrated. 

We can check if the p-values are well calibrated or not with the histograms of the p-values: ideally, they should be flat with a peak close to zero. in the two graphs below, we show the distribution of the non-calibrated (left graph) and calibrated (right graph) p-values. We can see that it is important to set the `genomic.control` to its default value `TRUE` if we want the p-values to be well calibrated. 

```{r HistogramPValues, fig.width=10}
par(mfrow=c(1,2))

# Histogram of non-calibrated p-values
# ------------------------------------
lfmm2.test(object = mod_lfmm2, input = geno, env = clim_past, full = TRUE, genomic.control = FALSE)$pvalues %>% 
hist(col = "orange", 
     main="Histogram of non-calibrated p-values",
     xlab="p-values")

# Histogram of calibrated p-values
# --------------------------------
lfmm2.test(object = mod_lfmm2, input = geno, env = clim_past, full = TRUE, genomic.control = TRUE)$pvalues %>% 
hist(col = "orange", 
     main="Histogram of calibrated p-values",
     xlab="p-values")
```

In the following analyses, we use the default `genomic.control=TRUE` and `full=TRUE`, so all climatic variables are used in the test. 

```{r ComputingPValues}
test_lfmm2 <- lfmm2.test(object = mod_lfmm2,
                       input = geno,
                       env = clim_past, 
                       full = TRUE,
                       genomic.control = TRUE)

pv_lfmm2 <- test_lfmm2$pvalues

plot(-log10(pv_lfmm2 ), 
     cex = .3, 
     col = "blue",
     xlab = "Locus",  
     ylab = "-log10(P)", 
     main="Manhattan plot of log10 p-values")
```

## Multiple testing and calibration issues

We want to use the FDR control algorithm to correct for **multiple testing** and determine which loci have significant levels of association. The **False Discovery Rate (FDR)** is defined as: 

**FDR = prob(False Discovery | Positive test) = *q***.

The FDR algorithm requires that the tests are correctly calibrated, i.e. that the distribution of p-values is uniform when we assume that the null hypothesis, $H0$, is correct. That's ok in our case, we have already checked it above with the histogram of p-values.

<span style="color: red;">**Which FDR level do we use?**</span>

```{r SetFDRlevel}
fdr_level <- 0.1
```

To identify the candidate SNPs, we apply the chosen FDR control to the p-values, which converts them into q-values. And then we identify candidates as those with q-values below a given FDR threshold.

The candidate SNPs at the FDR level of `r fdr_level * 100`% are shown with circles on the Manhattan plot below. The orange line corresponds to the Bonferroni threshold for a type I error of 10%.

```{r FDRcorrection}
# applying FDR control method to obtain q-values
qv_lfmm2  <- qvalue::qvalue(pv_lfmm2, fdr.level = fdr_level)

# Manhattan plot
plot(-log10(pv_lfmm2 ), 
     cex = .3, 
     col = "blue",
     xlab = "Locus",  
     ylab = "-log10(P)", 
     main="Manhattan plot of log10 p-values")

# Show with an orange line the Bonferonni multiple testing threshold for significance
abline(h = -log10(0.1/ncol(geno)), col = "orange")

# Extract the list of candidates
candidates <- which(qv_lfmm2$significant)

# Show with circles the list of candidate loci at the chosen FDR level
points(candidates, -log10(pv_lfmm2)[candidates], cex = .9, col = "brown")
```


```{r NamesCandidateSNPs}
candidates <- names(geno)[candidates]
```

<span style="color: red;">We obtain `r length(candidates)` candidate SNPs.</span>

# Estimating the genetic gap

This part is entirely based on the [LEA tutorial](https://github.com/bcm-uga/SSMPG2022/tree/master/Program%20tutorials/Tutorial%20LEA%203) provided during [SSMPG 2022](https://ssmpg.sciencesconf.org/).

Until now, methods to estimate the genomic offset has defined it as a **distance in the genetic space** (i.e. distance between allele frequencies). In the R packae `LEA`, the genomic offset is alternatively defined as a **distance in the environmental space**, i.e. measures of genomic offset are linked to the geometry of the ecological niche. This new definition of the genomic offset is referred as **genetic gap** and is implemented in the `genetic.gap` function of the `LEA` package.

The genetic gap is based on the estimates of environmental effect sizes obtained from an LFMM. The relationship inferred in the GEA is then used to fit and predict allelic variation at all genomic loci, alleviating the need for a set of candidate loci and the choice of a significance level.

Below, we will estimate the genetic gap for:
  
  - the sets of candidate SNPs
  
  - the control set of SNPs
  
  - all SNPs (as advised by the developers of the `genetic.gap` function) 

## Future climatic data

We load the predicted values of the climatic variables for the years 2041-2070 and we scale them (i.e. mean-center) with the same scaling parameters as the one used to mean-center the annual climatic values across the period 1901-1950 (see section \@ref(PastClim)).

```{r LoadFutureClimate}
# we load the future climatic data of the climatic variables of interest
clim_fut <- read_csv(here("data/DryadRepo/PopulationCoordinatesFutureClimateInformation.csv"),
               show_col_types = FALSE) %>% 
  dplyr::select(pop,clim_var$variables) # we keep only the climatic variables of interest

# We scale the future climatic variables with the scaling parameters of the climatic values from the period 1901-1950
for(i in clim_var$variables){
  clim_fut[,i] <- (clim_fut[,i] - scale_params[[i]]$mean) / scale_params[[i]]$sd
}

# Attribute climatic values for each genotype
clim_fut <- genotypes %>% 
  mutate(pop = str_sub(clon,1,3)) %>% 
  left_join(clim_fut, by="pop") %>% 
  dplyr::select(-pop,-clon)
```


## Genetic gap estimation with all SNPs

We run the `genetic.gap` function.

```{r EstimateGeneticGap}
g_gap <- genetic.gap(input = geno,
                     env = clim_past,
                     pred.env = clim_fut,
                     K = 5)
g_gap
```

The outputs of the `genetic.gap` function are (copy-and-pasted from the `LEA` manual):

  - `offset`: a vector of **genomic offset** values computed for every sample location in `new.env` and `pred.env`. The genomic offset is the genetic gap defined in @gain2023quantitative.
  
  - `distance`: a vector of **environmental distance** values computed for every sample location in `new.env` and `pred.env`. The distances to an estimate of the risk of nonadaptedness that includes correction for confounding factors and analyzes multiple predictors simultaneously (modified version of RONA).
  
  - `eigenvalues`: eigenvalues of the covariance matrix of LFMM effect sizes. They represent the relative importance of combinations of environmental variables described in vectors when the environmental data have similar scales. To be used with `scale == TRUE`.
  
  - `vectors`: eigenvectors of the covariance matrix of LFMM effect sizes representing combinations of environmental variables sorted by importance (eigenvalues).

Note that `distance` and `sqrt(offset)` have a correlation coefficient of `r cor(sqrt(g_gap$offset),g_gap$distance)`.

Below, we plot the **squared root of the genetic gap** (`offset` output) vs **the Euclidean climatic distance**.
  
Euclidean climatic distance:

$$
D_{clim} = \sqrt{\sum_{i=1}^{N} (X_{past,i} - X_{fut,i})^2}
$$

with $N$ the number of selected climatic variables, $X_{past,i}$ the mean value of the climatic variable $i$ across the period 1901-1950 and $X_{fut,i}$ the predicted mean value of the climatic variable $i$ across the period 2041-2070.

```{r CalculateEucliDistance}
# Calculate the Euclidean climatic distance
Delta = clim_past - clim_fut
dist_env = sqrt( rowSums(Delta^2) ) 
```

In the supplementary information of @gain2023quantitative, the authors say that 'If (and only if) the eigenvalues of the covariance matrix are equal, the geometric GO is proportional to the squared Euclidean distance between environmental predictors.' We can check it: the squared root of the Euclidean climatic distance and the genetic gap (`offset` in the outputs) have a correlation coefficient of `r cor(g_gap$offset,dist_env^2)`.

The authors add: 'As a consequence of this result, the geometric GO is maximal in the direction of the first eigenvector of the covariance matrix, and it is minimal in the direction of the last eigenvector of the covariance matrix. For scaled environmental variables, the eigenvalues of the covariance matrix provide insights on the amount of information on local adaptation carried out by combinations of environmental predictors described by corresponding eigenvectors.'

Note: in @gain2023quantitative, the authors use the term 'geometric GO' to refer to the 'genetic gap'.

```{r FunctionEuclideanDistancePlots}
# Function to build the plots 
make_plot <- function(X,Y,colors, color_names, plot_title=NULL, xlim=NULL,ylim=NULL,cex=1.2,pch=19,ylab) {
plot(X, Y, 
     xlab ="Euclidean distance",  ylab =ylab, 
     cex = cex , pch = pch, 
     col = colors,
     xlim = xlim, ylim = ylim,
     main = plot_title)
legend("topleft", 
       legend=unique(color_names),
       col=unique(colors),
       bty="n", pch=pch, cex=cex, ncol=1,
       title="Main gene pools")
recordPlot()
}
```

```{r GenePoolColors}
# Gene pool colors
gps <- read_csv(here("data/DryadRepo/PopulationStructureCorrea2015.csv"), show_col_types = FALSE)
genotypes <- genotypes %>%  left_join(gps, by="clon")
```

```{r PlotAllSNPsEucliDistance}
# par(mfrow=c(1,2))
# plot the climatic distance vs Euclidean environmental distance
# make_plot(X = dist_env,
#           Y = g_gap$distance,
#           ylab = "sqrt(distance)",
#           colors = genotypes$color_main_gp, 
#           color_names = genotypes$main_gp,
#           plot_title = "Climatic distance ~ Euclidean climatic distance")

# plot the squared root of the genetic gap vs Euclidean environmental distance
make_plot(X = dist_env,
          Y = sqrt(g_gap$offset),
          colors = genotypes$color_main_gp, 
          color_names = genotypes$main_gp,
          ylab = "sqrt(genetic gap)",
          plot_title = "All SNPs")
```

The plot below is exactly the same as the previous one except that the x and y axes have been cut to better visualize the populations with lower genetic gap and Euclidean climatic distance.

```{r PlotAllSNPsEucliDistanceAxisLimits}
# par(mfrow=c(1,2))
# make_plot(X = dist_env,
#           Y = g_gap$distance,
#           ylab = "sqrt(distance)",
#           colors = genotypes$color_main_gp, 
#           color_names = genotypes$main_gp,
#           plot_title = "Climatic distance ~ Euclidean climatic distance",
#           xlim=c(0,22),ylim=c(0,1.1))

make_plot(X = dist_env,
          Y = sqrt(g_gap$offset),
          colors = genotypes$color_main_gp, 
          color_names = genotypes$main_gp,
          ylab = "sqrt(genetic gap)",
          plot_title = "All SNPs",
          xlim=c(0,22),ylim=c(0,1.9))
```

We can plot the `eigenvalues` with a barplot to evaluate the relative importance of the climatic variables.

```{r}
barplot(g_gap$eigenvalues, col = "orange", xlab = "Axes", ylab = "Eigenvalues")
```

We see that only two dimensions of the climatic space influence the genetic gap. We can also see it with the loadings for the first two combinations of variables (`vectors` in the outputs of the `genetic.gap` function), which indicate the relative contribution of the variables to local adaptation. We see that the first two variables had increased importance compared to the last ones (the variables are sorted by importance in the `vectors` outputs, so we do not know which variables they are).


## Genetic gap estimation with sets of SNPs

We estimate the genetic gap for two sets of SNPs:

  - the `r length(candidates)` candidate SNPs
  
  - `r length(candidates)` randomly selected SNPs, which were sampled from the list of SNP names that does not include the candidate SNP names. 
  
  
```{r ListSnps}
# we sample random SNPs (same number of random SNPs as the number of candidate SNPs)
# and the random SNPs cannot be among the candidate SNPs (they are sampled from the list of SNP names after having removed the candidate SNP names)
set.seed(44)
rand_snps <- names(geno)[!names(geno) %in% candidates] %>% 
  sample(length(candidates), replace=FALSE)
  
list_ggap <- list(candidates = list(set_name = "Candidate SNPs",
                                    snp_names = candidates,
                                    snp_numbers =  which(names(geno) %in% candidates)),
                  control = list(set_name = "Random SNPs",
                                 snp_names = rand_snps,
                                 snp_numbers = which(names(geno) %in% rand_snps)))
```


```{r RunGeneticGapSetsSNPs}
list_ggap <- lapply(list_ggap, function(x) {
  
x$g_gap <- genetic.gap(input = geno,
                       env = clim_past,
                       pred.env = clim_fut,
                       candidate.loci = x$snp_numbers,
                       K = 5)
return(x)
})
```

```{r PlotSetSNPsEucliDistance, fig.width=12, results="hide"}
par(mfrow=c(1,2))

lapply(list_ggap, function(x) make_plot(
  X = dist_env,
  Y = sqrt(x$g_gap$offset),
  colors = genotypes$color_main_gp,
  color_names = genotypes$main_gp,
  ylab = "sqrt(genetic gap)",
  plot_title = x$set_name))
```

Same plots as above but with the x and y axes cut off to help visualization.

```{r PlotSetSNPsEucliDistanceAxisLimits, fig.width=12, results="hide"}
par(mfrow=c(1,2))

lapply(list_ggap, function(x) make_plot(
  X = dist_env,
  Y = sqrt(x$g_gap$offset),
  colors = genotypes$color_main_gp,
  color_names = genotypes$main_gp,
  ylab = "sqrt(genetic gap)",
  plot_title = x$set_name,
  xlim=c(0,22),ylim=c(0,3)))
```


