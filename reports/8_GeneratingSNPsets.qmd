---
title: "Generating sets of control and candidate SNPs"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    toc: true
    toc-depth: 4
    code-fold: true
    page-layout: full
embed-resources: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body {
   font-size: 15px;
}
code.r{
  font-size: 11px;
}
pre {
  font-size: 11px
}

table {
  font-size: 10px
}
</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 4,fig.height = 4,cache=F)
options(width = 300)
library(knitr)      # CRAN v1.26
library(tidyverse)  # CRAN v1.3.0
library(readxl)     # CRAN v1.3.1
library(xtable)
library(reshape2)
library(kableExtra)
library(here)
library(cowplot)
library(ggVennDiagram)


# my own function for building tables in reports
source(here("scripts/functions/kable_mydf.R"))
```


```{r MakeVennDiagrams}
# function to make the Venn diagrams
make_venndiagram <- function(list_candidates,
                             caption="",
                             label = "both",
                             title=""){

list_candidates %>% 
    ggVennDiagram(lty="solid", size=0.2, label = label) + 
  scale_fill_gradient2(low = "white", high = 'gray40') + 
  scale_color_manual(values = rep("gray80",6)) + 
  guides(fill = "none") + 
  labs(caption=caption) +
  ggtitle(title) +
  theme(text = element_text(size=16),
        plot.caption = element_text(hjust=0.5, size=rel(1.2))) + 
  scale_x_continuous(expand = expansion(mult = .2))
}
```


# GEA methods

Candidate SNPs were identified using different gene-environment association (GEA) methods, which we summarize below.

## Redundancy analysis (RDA)

Two RDA models were fitted:

  - not accounting for population structure, which we will call *<span style="color: orange;">RDA</span>*.
  
  - accounting for population structure by incorporating in the RDA model the three first PCs of the PCA performed on the genomic dataset (not filtered for minor allele frequencies), which we will call *<span style="color: orange;">pRDA</span>*.


RDA candidates are SNPs that have been identified with one of these two methods:

   - based on their *extremeness* along a *distribution of Mahalanobis distances* estimated between each locus and the center of the RDA space using a $K$ number of axes (we used $K=2$). This method was used in @capblancq2020climate (see [code](https://github.com/Capblancq/Local-Adaptation-Fagus-sylvatica)) and @capblancq2021redundancy ([code](https://github.com/Capblancq/RDA-landscape-genomics)). For that, (1) the Mahalanobis distances were calculated, (2) $p$-values and $q$-values were obtained with the `radapt` function from @capblancq2021redundancy, and (3) a FDR (False Discovery Rate) threshold of 5% was applied to the $q$-values to identify the outliers.

  - based on *extreme loadings on each significant axis*. Method used in @forester2018comparing (see [code](https://popgen.nescent.org/2018-03-27_RDA_GEA.html)). We use a 3 standard deviation cutoff (two-tailed $p$-value = 0.0027) to identify the outliers.
  

Below, we only keep the SNPs that have been identified with the Mahalanobis distance method.
 
```{r RDAoutliers, fig.width=12,fig.height=5}
par(mfrow=c(1,2))

rda_outliers <- readRDS(here::here("outputs/RDA/RDA_outliers.rds"))

list_candidates <- list("RDA"=rda_outliers[[3]]$outliers$snp,
                        "pRDA"=rda_outliers[[4]]$outliers$snp,
                        "RDA (mahalanobis)"=rda_outliers[[3]]$outliers %>% dplyr::filter(maha_meth==T) %>% pull(snp),
                        "RDA (loadings)"=rda_outliers[[3]]$outliers %>% dplyr::filter(load_meth==T) %>% pull(snp),
                        "pRDA (mahalanobis)"=rda_outliers[[4]]$outliers %>% dplyr::filter(maha_meth==T) %>% pull(snp),
                        "pRDA (loadings)"=rda_outliers[[4]]$outliers %>% dplyr::filter(load_meth==T) %>% pull(snp))



p <- make_venndiagram(list_candidates[c("RDA","pRDA")], title = "Mahalanobis and loadings methods")


pp <- make_venndiagram(list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)")], title = "Mahalanobis method only")

plot_grid(p,pp,nrow=1)

p <- make_venndiagram(list_candidates[c("RDA (loadings)","pRDA (loadings)")], title = "Loadings method only")


pp <- make_venndiagram(list_candidates[c("RDA (mahalanobis)","RDA (loadings)","pRDA (mahalanobis)","pRDA (loadings)")],
  label="count")

plot_grid(p,pp,nrow=1)
```


## Gradient forest (GF)

GF-based GEA was performed following @fitzpatrick2021experimental and @capblancq2023common, using 'raw' or *uncorrected* allele frequencies. Because the SNPs with the lowest empirical $p$-values were not exactly the same across independent runs of the GF-based GEA, we ran 3 independent runs, identified the 0.5\% SNPs with the lowest empirical $p$-values for each run (i.e. 49 SNPs for each run) and then considered as outlier SNPs the SNPs identified in the three runs.
  
```{r GFoutliers, fig.width=12,fig.height=5}
list_candidates$"GF"= readRDS(here::here("outputs/GF/gf_common_outliers_across_three_runs.rds"))
```


## Latent factor mixed model (LFMM)

We identified the candidate SNPs by applying a FDR threshold of 5% to the p-values from a LFMM. LFMM was corrected for population structure (ie population relatedness) as the population structure should be captured by the $K$ latent factors ($K = 5$ in our case).

```{r LFMMoutliers}
list_candidates$"LFMM" <- readRDS(here::here("outputs/LFMM/candidates.rds"))
```

<span style="color: OrangeRed;">`r length(list_candidates$LFMM)` candidate SNPs</span> were identified with the LFMM approach.


## BayPass


```{r BayPassOutliers}
list_candidates$"BayPass" <- readRDS(here("outputs/BayPass/baypass_outliers.rds"))
```

<span style="color: OrangeRed;">`r length(list_candidates$BayPass)` candidate SNPs</span> were identified with <span style="font-variant:small-caps;">BayPass</span>. SNPs were considered as outliers in BayPass when their Bayes factors were higher than 10.



# Common candidate SNPs

Let's look at the common candidates across the different GEA methods. 


```{r VennDiagramCommoncandidates,fig.height=5,fig.width=8}
# generating the Venn diagrams showing common candidates across GEA methods
make_venndiagram(list_candidates[c("RDA (mahalanobis)","GF")],
                 caption = "GEA methods not correcting for population structure",label="count")
make_venndiagram(list_candidates[c("pRDA (mahalanobis)","LFMM","BayPass")],
                 caption = "GEA methods correcting for population structure",label="count")


# Identifying SNPs identified by at least two GEA methods
common_cand_notcorrected <- list_candidates[c("RDA (mahalanobis)","GF")] %>% unlist() %>% .[duplicated(.)] %>% unique()
common_cand_corrected <- list_candidates[c("pRDA (mahalanobis)","LFMM","BayPass")] %>% unlist() %>% .[duplicated(.)] %>% unique()
common_cand <- list_candidates[c("RDA (mahalanobis)","GF","pRDA (mahalanobis)","LFMM","BayPass")] %>% unlist() %>% .[duplicated(.)] %>% unique()
common_cand_RDA_LFMM <- list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM")] %>% unlist() %>% .[duplicated(.)] %>% unique()
common_cand_RDA_LFMM_BayPass <- list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM","BayPass")] %>% unlist() %>% .[duplicated(.)] %>% unique()

# Identifying SNPs in common between some of the GEA methods
common_cand_RDA_LFMM_intersect <- list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM")] %>% Reduce(intersect, .)
common_cand_RDA_LFMM_BayPass_intersect <- list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM","BayPass")] %>% Reduce(intersect, .)
```


**Possible sets of candidate SNPs:**

  1. SNPs identified by at least two methods [like in @capblancq2023common] => <span style="color: OrangeRed;">`r common_cand %>% length()` SNPs.</span>

  2. SNPs that were identified by at least one GEA method not correcting for population structure, namely *RDA* and *GF* => <span style="color: OrangeRed;">`r common_cand_notcorrected %>% length()` SNPs.</span>
  
  3. SNPs that were identified by at least one GEA method correcting for population structure, namely *pRDA*, *LFMM* and *BayPass* => <span style="color: OrangeRed;">`r common_cand_corrected %>% length()` SNPs.</span>
  
  4. SNPs identified by at least two methods among *RDA*, *pRDA* and *LFMM* => <span style="color: OrangeRed;">`r common_cand_RDA_LFMM %>% length()` SNPs.</span>
  
  5. SNPs identified by at least two methods among *RDA*, *pRDA*, *LFMM* and *BayPass* => <span style="color: OrangeRed;">`r common_cand_RDA_LFMM_BayPass %>% length()` SNPs.</span>
  
  6. SNPs in common between *RDA*, *pRDA* and *LFMM* => <span style="color: OrangeRed;">`r common_cand_RDA_LFMM_intersect %>% length()` SNPs.</span>
  
  7. SNPs in common between *RDA*, *pRDA*, *LFMM* and *BayPass* => <span style="color: OrangeRed;">`r common_cand_RDA_LFMM_BayPass_intersect %>% length()` SNPs.</span>

<span style="color: OrangeRed;">`r length(intersect(common_cand_corrected,common_cand_notcorrected))` SNPs</span> are in common between the sets 2 and 3.

> Our choice

In the following analyses, we use **the set with SNPs identified by at least two methods** (set 1) (**`r common_cand %>% length()` SNPs**). The rationale is that we aim to obtain a set of candidate SNPs that is enriched for loci involved in adaptation to climate, so we tried to find a good balance between not being too conservative (e.g. by selecting SNPs in common across all methods) and not including too many false positives (e.g. by selecting SNPs identified by at least one GEA). We also wanted to give the possibility to select candidates that can only be identified with methods correcting for population structure (pRDA, LFMM, BayPass) or candidates that can only be identified by methods not correcting for population structure (RDA and GF). 

```{r VennDiagrammSelectedMethods,fig.height=7,fig.width=7}
make_venndiagram(list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM","BayPass","GF")],
                 label="count",
                 caption = "Selected methods")
```

 
> Comparison with @capblancq2023common

In @capblancq2023common, they selected the SNPs that were in the top 0.2% for at least two of four genome scans (GF, GF-X, RDA or pRDA), which resulted in the selection of 240 loci (over 335 588 loci exhibiting  MAF > 0.1). They observed substantial overlap between RDA and GF when neutral population structure was not accounted for, with 149 loci (i.e. 22% of each set) found by both methods. On the contrary, congruence was low when correcting for population structure, with only 15 common loci (2%) between methods, and no visible covariation between GF R2 and RDA Mahalanobis distance.

  
# Genome position of candidate SNPs

```{r LoadGenomePositionData}
snppos <- read_excel(here("data/GenomicData/genome_position.xlsx"), sheet = "base_table") %>% 
  dplyr::rename(snp_ID = Juliette_snp_ID,
                original_ID = Original_ID,
                affx_ID = affy_snp_id,
                infinium_ID = Infinium_ID,
                genome_position =`position (bp)`,
                annotation =`Annotation (including alternative names)`) %>% 
  dplyr::select(snp_ID, original_ID, affx_ID, infinium_ID, scaffold, genome_position, annotation)
```

Information on genome position for candidates SNPs identified by at least two GEA methods:

```{r GenomePositionCandidates}
snppos %>% 
  dplyr::filter(snp_ID %in% common_cand) %>% 
  kable_mydf(boldfirstcolumn = F, font_size = 11)
```

SNPs on the same scaffold:

```{r SNPsSameScaffold}
snppos %>% 
  dplyr::filter(snp_ID %in% common_cand) %>% 
  group_by(scaffold) %>% 
  filter(n()>1) %>% 
  kable_mydf(boldfirstcolumn = F, font_size = 11)
```

**Comment:** a scaffold is a set of contigs separated by gaps and for which the relative orientation and distance is known.

If we keep only one SNP per scaffold, we will have:

  - <span style="color: OrangeRed;">`r snppos %>% dplyr::filter(snp_ID %in% common_cand) %>% pull(scaffold) %>% unique() %>% length()` candidate SNPs</span> identified by at least one GEA method among *RDA*, *pRDA*, *LFMM*, *BayPass* and *GF*.

  - <span style="color: OrangeRed;">`r snppos %>% dplyr::filter(snp_ID %in% common_cand_notcorrected) %>% pull(scaffold) %>% unique() %>% length()` candidate SNPs</span> identified by at least one GEA method not correcting for population structure (*RDA* and *GF*).
  
  - <span style="color: OrangeRed;">`r snppos %>% dplyr::filter(snp_ID %in% common_cand_corrected) %>% pull(scaffold) %>% unique() %>% length()` candidate SNPs</span> identified by at least one GEA method correcting for population structure (*pRDA*, *LFMM* and *BayPass*).
  
  
When some SNPs are on the same scaffold, we remove the SNPs with higher $p$-values in the RDA.

```{r rmSNPsSameGenomePosition}
snp_to_remove <- lapply(list(common_cand,common_cand_corrected), function(set){

  snppos %>% 
  dplyr::filter(snp_ID %in% set) %>% 
  group_by(scaffold) %>% 
  filter(n()>1) %>% 
  group_split() %>% 
  lapply(function(x){

rda_outliers[[3]]$GSout %>% 
   filter(snp %in% x$snp_ID) %>% 
   arrange(pvalues) %>%  
   slice(2:nrow(x)) %>% 
   pull(snp)
      }) %>%  
  unlist
  
})


common_cand <- setdiff(common_cand, snp_to_remove[[1]])
common_cand_corrected <- setdiff(common_cand_corrected, snp_to_remove[[2]])
```


# Control SNPs

We *randomly* sample a set of SNPs (the same number as the candidate SNPs) among the SNPs that have been identified by none of the GEA methods. This set of SNPs will be used as **control SNPs**.

```{r ControlSNPs, eval=T}
nb_snps <- common_cand %>% length()

# names of the SNPs that were identified by at least one GEA method
all_candidates <- list_candidates %>% unlist() %>% unique()

# remove the candidates from the set of SNPs used in the GEA analyses
no_candidates <- read.csv(here("data/DryadRepo/FormattedFilteredGenomicData_AlleleCounts_withoutmaf.csv")) %>% 
  pull(snp_ID) %>% 
  setdiff(all_candidates)

# sample the set of control SNPs
set.seed(36)
control_snps <- sample(no_candidates,nb_snps,replace = F)
```


```{r SaveThreeSetsSNPs, eval=T}
snp_sets <- list(cand = list(set_code = "cand",
                             set_name = "Candidate SNPs",
                             set_snps = common_cand),
                 cand_corrected = list(set_code = "cand_corrected",
                                       set_name = "Candidate SNPs (with correction)",
                                       set_snps = common_cand_corrected),
                 control = list(set_code = "control",
                                set_name = "Control SNPs",
                                set_snps = control_snps))

saveRDS(snp_sets,here("outputs/list_snp_sets.rds"))
```



# Session information

```{r SessionInfo}
devtools::session_info()
```

  