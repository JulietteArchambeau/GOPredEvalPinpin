---
title: "Defining the sets of control and candidate SNPs"
subtitle: "Identification of outlier SNPs in common among the different GEAs"
date: last-modified
format: 
  html:
    toc: true
    toc-depth: 4
    code-fold: true
    page-layout: full
embed-resources: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body {
   font-size: 15px;
}
code.r{
  font-size: 11px;
}
pre {
  font-size: 11px
}

table {
  font-size: 10px
}
</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 4,fig.height = 4,cache=F)
options(width = 300)
library(knitr)
library(tidyverse)
library(readxl)
library(xtable)
library(reshape2)
library(kableExtra)
library(here)
library(cowplot)
library(ggVennDiagram)
library(UpSetR)
library(magrittr)

# my own function for building tables in reports
source(here("scripts/functions/kable_mydf.R"))
```


```{r MakeVennDiagrams}
# function to make the Venn diagrams
make_venndiagram <- function(list_candidates,
                             caption="",
                             label="both",
                             title="",
                             title_size = 10,
                             set_size = 4){

list_candidates %>% 
    ggVennDiagram(lty="solid", 
                  ize=0.2, 
                  label = "count", 
                  label_alpha=0, 
                  edge_size = 0.4,
                  set_size = set_size) + 
  scale_fill_gradient2(low = "white", high = 'darkgoldenrod3') + 
  scale_color_manual(values = rep("darkgoldenrod1",6)) + 
  guides(fill = "none") + 
  labs(caption=caption) +
  ggtitle(title) +
  theme(text = element_text(size= 16),
        plot.caption = element_text(hjust=0.5, size=rel(1.2)),
        title = element_text(size = title_size)) + 
  scale_x_continuous(expand = expansion(mult = .2))
}
```


# GEA methods

Candidate SNPs were identified using different gene-environment association (GEA) methods, which we summarize below.

## Redundancy analysis (RDA)

Two RDA models were fitted:

  - not accounting for population structure, which we will call *<span style="color: orange;">RDA</span>*.
  
  - accounting for population structure by incorporating in the RDA model the three first PCs of the PCA performed on the genomic dataset (not filtered for minor allele frequencies), which we will call *<span style="color: orange;">pRDA</span>*.


RDA candidates are SNPs that have been identified with one of these two methods:

   - based on their *extremeness* along a *distribution of Mahalanobis distances* estimated between each locus and the center of the RDA space using a $K$ number of axes (we used $K=2$). This method was used in @capblancq2020climate (see [code](https://github.com/Capblancq/Local-Adaptation-Fagus-sylvatica)) and @capblancq2021redundancy ([code](https://github.com/Capblancq/RDA-landscape-genomics)). For that, (1) the Mahalanobis distances were calculated, (2) $p$-values and $q$-values were obtained with the `radapt` function from @capblancq2021redundancy, and (3) a FDR (False Discovery Rate) threshold of 5% was applied to the $q$-values to identify the outliers.

  - based on *extreme loadings on each significant axis*. Method used in @forester2018comparing (see [code](https://popgen.nescent.org/2018-03-27_RDA_GEA.html)). We use a 3 standard deviation cutoff (two-tailed $p$-value = 0.0027) to identify the outliers.
  

Below, we only keep the SNPs that have been identified with the Mahalanobis distance method.
 
```{r RDAoutliers, fig.width=12,fig.height=5}
par(mfrow=c(1,2))

rda_outliers <- readRDS(here::here("outputs/RDA/RDA_outliers.rds"))

list_candidates <- list("RDA"=rda_outliers[[3]]$outliers$snp,
                        "pRDA"=rda_outliers[[4]]$outliers$snp,
                        "RDA (mahalanobis)"=rda_outliers[[3]]$outliers %>% dplyr::filter(maha_meth==T) %>% pull(snp),
                        "RDA (loadings)"=rda_outliers[[3]]$outliers %>% dplyr::filter(load_meth==T) %>% pull(snp),
                        "pRDA (mahalanobis)"=rda_outliers[[4]]$outliers %>% dplyr::filter(maha_meth==T) %>% pull(snp),
                        "pRDA (loadings)"=rda_outliers[[4]]$outliers %>% dplyr::filter(load_meth==T) %>% pull(snp))



p <- make_venndiagram(list_candidates[c("RDA","pRDA")], title = "Mahalanobis and loadings methods")


pp <- make_venndiagram(list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)")], title = "Mahalanobis method only")

plot_grid(p,pp,nrow=1)

p <- make_venndiagram(list_candidates[c("RDA (loadings)","pRDA (loadings)")], title = "Loadings method only")


pp <- make_venndiagram(list_candidates[c("RDA (mahalanobis)","RDA (loadings)","pRDA (mahalanobis)","pRDA (loadings)")],
  label="count")

plot_grid(p,pp,nrow=1)
```


## Gradient forest (GF)

GF-based GEA was performed following @fitzpatrick2021experimental and @capblancq2023common, using *raw* or *uncorrected* allele frequencies. Because the SNPs with the lowest empirical $p$-values (i.e. the highest $R^2$) were not exactly the same across independent runs of the GF-based GEA, we ran 3 independent runs, identified the 0.5\% SNPs with the lowest empirical $p$-values for each run (i.e. 49 SNPs for each run) and then considered as outlier SNPs the SNPs identified in the three runs.
  
```{r GFoutliers, fig.width=12,fig.height=5}
list_candidates$"GF"= readRDS(here::here("outputs/GF/GFCommonOutliers_ThreeRuns_RawAlleleFrequencies.rds"))
```


## Latent factor mixed model (LFMM)

We identified the candidate SNPs by applying a FDR threshold of 5% to the p-values from a LFMM. LFMM was corrected for population structure (ie population relatedness) as the population structure should be captured by the $K$ latent factors ($K = 5$ in our case).

```{r LFMMoutliers}
list_candidates$"LFMM" <- readRDS(here::here("outputs/LFMM/candidates.rds"))
```

<span style="color: OrangeRed;">`r length(list_candidates$LFMM)` candidate SNPs</span> were identified with the LFMM approach.


## BayPass


```{r BayPassOutliers}
list_candidates$"BayPass" <- readRDS(here("outputs/BayPass/baypass_outliers.rds"))
```

<span style="color: OrangeRed;">`r length(list_candidates$BayPass)` candidate SNPs</span> were identified with <span style="font-variant:small-caps;">BayPass</span>. SNPs were considered as outliers in BayPass when their Bayes factors were higher than 10.



# Defining the sets of candidate SNPs

Let's look at the common candidates across the different GEA methods and define which sets of candidates we will use for genomic offset predictions.


```{r VennDiagramCommoncandidates,fig.height=5,fig.width=5}
# generating the Venn diagrams showing common candidates across GEA methods
make_venndiagram(list_candidates[c("RDA (mahalanobis)","GF")],
                 caption = "GEA methods not correcting for population structure",
                 label="count",
                 title_size = 10)
make_venndiagram(list_candidates[c("pRDA (mahalanobis)","LFMM","BayPass")],
                 caption = "GEA methods correcting for population structure",
                 label="count",
                 title_size = 10)

# All candidate SNPs (ie SNPs identified by at least one GEA)
all_cand <- list_candidates[c("RDA (mahalanobis)","GF","pRDA (mahalanobis)","LFMM","BayPass")] %>% unlist() %>% unique()

# Candidate SNPs identified by GEAs correcting for population genetic structure
corrected_cand <- list_candidates[c("pRDA (mahalanobis)","LFMM","BayPass")] %>% unlist() %>% unique()

# Identifying SNPs identified by at least two GEA methods
common_cand_notcorrected <- list_candidates[c("RDA (mahalanobis)","GF")] %>% unlist() %>% .[duplicated(.)] %>% unique()
common_cand_corrected <- list_candidates[c("pRDA (mahalanobis)","LFMM","BayPass")] %>% unlist() %>% .[duplicated(.)] %>% unique()
common_cand <- list_candidates[c("RDA (mahalanobis)","GF","pRDA (mahalanobis)","LFMM","BayPass")] %>% unlist() %>% .[duplicated(.)] %>% unique()
common_cand_RDA_LFMM <- list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM")] %>% unlist() %>% .[duplicated(.)] %>% unique()
common_cand_RDA_LFMM_BayPass <- list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM","BayPass")] %>% unlist() %>% .[duplicated(.)] %>% unique()

# Identifying SNPs in common between some of the GEA methods
common_cand_RDA_LFMM_intersect <- list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM")] %>% Reduce(intersect, .)
common_cand_RDA_LFMM_BayPass_intersect <- list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM","BayPass")] %>% Reduce(intersect, .)
```


**Possible sets of candidate SNPs:**

  1. SNPs identified by at least one method  => <span style="color: OrangeRed;">`r all_cand %>% length()` SNPs.</span>
  
  2. SNPs identified by at least two methods [like in @capblancq2023common] => <span style="color: OrangeRed;">`r common_cand %>% length()` SNPs.</span>
  
  3. SNPs identified by at least one method correcting for population structure, namely *pRDA*, *LFMM* and *BayPass* => <span style="color: OrangeRed;">`r corrected_cand %>% length()` SNPs.</span>

  4. SNPs identified by at least two methods not correcting for population structure, namely *RDA* and *GF* => <span style="color: OrangeRed;">`r common_cand_notcorrected %>% length()` SNPs.</span>
  
  5. SNPs identified by at least two methods correcting for population structure, namely *pRDA*, *LFMM* and *BayPass* => <span style="color: OrangeRed;">`r common_cand_corrected %>% length()` SNPs.</span>
  
  6. SNPs identified by at least two methods among *RDA*, *pRDA* and *LFMM* => <span style="color: OrangeRed;">`r common_cand_RDA_LFMM %>% length()` SNPs.</span>
  
  7. SNPs identified by at least two methods among *RDA*, *pRDA*, *LFMM* and *BayPass* => <span style="color: OrangeRed;">`r common_cand_RDA_LFMM_BayPass %>% length()` SNPs.</span>
  
  8. SNPs in common between *RDA*, *pRDA* and *LFMM* => <span style="color: OrangeRed;">`r common_cand_RDA_LFMM_intersect %>% length()` SNPs.</span>
  
  9. SNPs in common between *RDA*, *pRDA*, *LFMM* and *BayPass* => <span style="color: OrangeRed;">`r common_cand_RDA_LFMM_BayPass_intersect %>% length()` SNPs.</span>

<span style="color: OrangeRed;">`r length(intersect(common_cand_corrected,common_cand_notcorrected))` SNPs</span> are in common between the sets 4 and 5.

> Our choice

In the first version of the study, we used **the set with SNPs identified by at least two methods** (set 2) (**`r common_cand %>% length()` SNPs**). The rationale is that we aim to obtain a set of candidate SNPs that is enriched for loci involved in adaptation to climate, so we tried to find a good balance between not being too conservative (e.g. by selecting SNPs in common across all methods) and not including too many false positives (e.g. by selecting SNPs identified by at least one GEA). We also wanted to give the possibility to select candidates that can only be identified with methods correcting for population structure (pRDA, LFMM, BayPass) or candidates that can only be identified by methods not correcting for population structure (RDA and GF). 

After the first round of review, we also included the set of SNPs identified by at least one method (set 1; `r all_cand %>% length()` SNPs), as a reviewer expressed concern that the initial set of candidate SNPs was too small. And we also included the set of SNPs identified by at least one method correcting for population genetic structure (set 3; `r corrected_cand %>% length()` SNPs).

```{r VennDiagrammSelectedMethods,fig.height=7,fig.width=7}
make_venndiagram(list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM","BayPass","GF")],
                 label="count",
                 caption = "Selected methods")
```

 
> Comparison with @capblancq2023common

In @capblancq2023common, they selected the SNPs that were in the top 0.2% for at least two of four genome scans (GF, GF-X, RDA or pRDA), which resulted in the selection of 240 loci (over 335 588 loci exhibiting  MAF > 0.1). They observed substantial overlap between RDA and GF when neutral population structure was not accounted for, with 149 loci (i.e. 22% of each set) found by both methods. On the contrary, congruence was low when correcting for population structure, with only 15 common loci (2%) between methods, and no visible covariation between GF R2 and RDA Mahalanobis distance.
  

### Figure 2 of the manuscript

We generate the figure for the main manuscript (Figure 2).

#### Venn diagram (first version)

```{r GeneratingFigure2ManuscriptVennDiagram}
selected_methods <- list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM","BayPass","GF")]
names(selected_methods) <- c("RDA (nc)", "pRDA (c)", "LFMM (c)", "BayPass (c)", "GF (nc)")

make_venndiagram(selected_methods,
                 label="count") %>% 
ggsave(filename = here("figs/VennDiagram_CommonOutliers.pdf"), device = "pdf", width = 6.5, height = 6.5)
```

#### Upset plot

Following a reviewer’s comment, we updated Figure 2 from a Venn diagram to a more comprehensive [upset plot](https://r-graph-gallery.com/upset-plot.html). 

Figure in which SNPs identified with at least two methods are shown in a different color than SNPs identified by only one method.

```{r GeneratingFigure2ManuscriptUpsetPlotTwoColors, fig.width=9, fig.height=7, results="hide"}
color_two_methods_snps <- "orange"
color_one_method_snps <- "cyan"  # "gray60"

p <- upset(fromList(selected_methods),order.by = "freq",  point.size = 3.1, 
      main.bar.color = c(rep(color_one_method_snps,4),rep(color_two_methods_snps,3),color_one_method_snps,rep(color_two_methods_snps, 11)),
      matrix.color = color_two_methods_snps,
      
      queries = list(list(query = intersects, params=names(selected_methods)[1], active=T, color=color_one_method_snps),
                     list(query = intersects, params=names(selected_methods)[2], active=T, color=color_one_method_snps),
                     list(query = intersects, params=names(selected_methods)[3], active=T, color=color_one_method_snps),
                     list(query = intersects, params=names(selected_methods)[4], active=T, color=color_one_method_snps),
                     list(query = intersects, params=names(selected_methods)[5], active=T, color=color_one_method_snps)))

pdf(file=here("figs/UpsetPlot_AllOutliers_TwoColors.pdf"), onefile=FALSE, width = 5.5, height = 5.5)
p
dev.off()

p

```

Figure in which all SNPs are shown with the same color.

```{r GeneratingFigure2ManuscriptUpsetPlotOneColor, fig.width=9, fig.height=7, results="hide"}

# Manuscript
color_two_methods_snps <- "gray50"
color_one_method_snps <- "gray50"  # "gray50"

p <- upset(fromList(selected_methods),order.by = "freq",  point.size = 3.1, 
      main.bar.color = c(rep(color_one_method_snps,4),rep(color_two_methods_snps,3),color_one_method_snps,rep(color_two_methods_snps, 11)),
      matrix.color = color_two_methods_snps,
      
      queries = list(list(query = intersects, params=names(selected_methods)[1], active=T, color=color_one_method_snps),
                     list(query = intersects, params=names(selected_methods)[2], active=T, color=color_one_method_snps),
                     list(query = intersects, params=names(selected_methods)[3], active=T, color=color_one_method_snps),
                     list(query = intersects, params=names(selected_methods)[4], active=T, color=color_one_method_snps),
                     list(query = intersects, params=names(selected_methods)[5], active=T, color=color_one_method_snps)))

pdf(file=here(paste0("figs/UpsetPlot_AllOutliers_OneColor",color_one_method_snps,".pdf")), onefile=FALSE, width = 8, height = 5)
p
dev.off()

p

# Presentations
color_two_methods_snps <- "skyblue"
color_one_method_snps <- "skyblue"  # "gray50"

p <- upset(fromList(selected_methods),order.by = "freq",  point.size = 3.1, 
      main.bar.color = c(rep(color_one_method_snps,4),rep(color_two_methods_snps,3),color_one_method_snps,rep(color_two_methods_snps, 11)),
      matrix.color = color_two_methods_snps,
      
      queries = list(list(query = intersects, params=names(selected_methods)[1], active=T, color=color_one_method_snps),
                     list(query = intersects, params=names(selected_methods)[2], active=T, color=color_one_method_snps),
                     list(query = intersects, params=names(selected_methods)[3], active=T, color=color_one_method_snps),
                     list(query = intersects, params=names(selected_methods)[4], active=T, color=color_one_method_snps),
                     list(query = intersects, params=names(selected_methods)[5], active=T, color=color_one_method_snps)))

pdf(file=here(paste0("figs/UpsetPlot_AllOutliers_OneColor_",color_one_method_snps,".pdf")), onefile=FALSE, width = 6, height = 6)
p
dev.off()

p
```

# SNP pruning based on physical proximity

## Genome position of candidate SNPs

We load the dataset `genome_position.xlsx` containing information about the scaffold/contig of each SNP. In the DRYAD repository, this information is available in the `ListSNPs_withoutmaf.csv` and `ListSNPs_withmaf.csv` datasets.

```{r LoadGenomePositionData}
snppos <- read_excel(here("data/GenomicData/genome_position.xlsx"), sheet = "base_table") %>% 
  dplyr::rename(snp_ID = Juliette_snp_ID,
                original_ID = Original_ID,
                affx_ID = affy_snp_id,
                infinium_ID = Infinium_ID,
                genome_position =`position (bp)`,
                annotation =`Annotation (including alternative names)`) %>% 
  dplyr::select(snp_ID, original_ID, affx_ID, infinium_ID, scaffold, genome_position, annotation)
```

Information on genome position for candidates SNPs identified by at least two GEA methods:

```{r GenomePositionCandidates}
snppos %>% 
  dplyr::filter(snp_ID %in% common_cand) %>% 
  kable_mydf(boldfirstcolumn = F, font_size = 11)
```

SNPs on the same scaffold:

```{r SNPsSameScaffold}
snppos %>% 
  dplyr::filter(snp_ID %in% common_cand) %>% 
  group_by(scaffold) %>% 
  filter(n()>1) %>% 
  kable_mydf(boldfirstcolumn = F, font_size = 11)
```

**Comment:** a scaffold is a set of contigs separated by gaps and for which the relative orientation and distance is known.

If we keep only one SNP per scaffold, we will have:

  - <span style="color: OrangeRed;">`r snppos %>% dplyr::filter(snp_ID %in% all_cand) %>% pull(scaffold) %>% unique() %>% length()` candidate SNPs</span> identified by at least one GEA among *RDA*, *pRDA*, *LFMM*, *BayPass* and *GF*.

  - <span style="color: OrangeRed;">`r snppos %>% dplyr::filter(snp_ID %in% common_cand) %>% pull(scaffold) %>% unique() %>% length()` candidate SNPs</span> identified by at least one GEA method among *RDA*, *pRDA*, *LFMM*, *BayPass* and *GF*.

  - <span style="color: OrangeRed;">`r snppos %>% dplyr::filter(snp_ID %in% corrected_cand) %>% pull(scaffold) %>% unique() %>% length()` candidate SNPs</span> identified by at least one GEA method correcting for population structure (*pRDA*, *LFMM* and *BayPass*).
  
  
## Position on a reference genome

In 2024, the SNPs were mapped into the *Pinus tabuliformis* genome. We explore in this section of position of the candidate SNPs on this reference genome.

```{r TableMappingBeforePruning, fig.height=8, fig.width=14}
# SNPs position on the reference genome
gen_coord <- read_delim("~/Documents/Projects/GOPredEvalPinpin/data/GenomicData/maritime_pine_coord.txt", show_col_types = FALSE) %>% 
  mutate(chrom_names = if_else(CHROM %in% paste0("chr",1:12), paste0("Chromosome ", CHROM %>% str_sub(4,-1)), paste0("Contig ",CHROM)))

# All SNPs
all_snps_id <- read.csv(here("data/DryadRepo/FormattedFilteredGenomicData_AlleleCounts_withoutmaf.csv")) %>% .[[1]]

# Sets of candidate SNPs
snp_sets_bf_pruning <- list(all = list(set_code = "all",
                                       set_name = paste0("All SNPs (", length(all_snps_id),")"),
                                       set_snps = all_snps_id), 
                            all_cand = list(set_code = "all_cand",
                                            set_name = paste0("All candidate SNPs (", length(all_cand),")"),
                                            set_snps = all_cand),
                            common_cand = list(set_code = "common_cand",
                                               set_name = paste0("Common candidate SNPs (", length(common_cand),")"),
                                               set_snps = common_cand),
                            corrected_cand = list(set_code = "corrected_cand",
                                                  set_name = paste0("Candidate SNPs with pop. struct. correction (", length(corrected_cand),")"),
                                                  set_snps = corrected_cand))

# Counting the number of candidate SNPs per chromosome
nb_per_chr_list <- lapply(snp_sets_bf_pruning, function(x){
  
  df <- snppos %>% dplyr::filter(snp_ID %in% x$set_snps) 
  
  gen_coord %>% 
    filter(AxiomID %in% df$affx_ID) %>% 
    group_by(chrom_names) %>% 
    summarise(n = n()) %>% 
    set_colnames(c("Chromosome / contig", x$set_name))

}) 


# Merging the counts in one table
nb_per_chr_df <- nb_per_chr_list[[1]] %>%
  full_join(nb_per_chr_list[[2]], by = "Chromosome / contig") %>%
  full_join(nb_per_chr_list[[3]], by = "Chromosome / contig") %>%
  full_join(nb_per_chr_list[[4]], by = "Chromosome / contig") %>%
  # Replace NA values with 0 across all numeric columns
  mutate(across(where(is.numeric), ~replace_na(., 0))) 

# Sum the total of SNPs mapped on the reference genome for each set of SNPs
nb_per_chr_df <- nb_per_chr_df %>% summarise(
  `Chromosome / contig` = "TOTAL",
  across(where(is.numeric), \(x) sum(x, na.rm = TRUE))) %>% 
  bind_rows(nb_per_chr_df,.) 

# for the text below
all_contig <- nb_per_chr_df %>% filter(str_detect(`Chromosome / contig`, 'Contig')) %>% summarise(sum_column = sum(.[[2]], na.rm = TRUE)) %>% pull
all_cand_contig <- nb_per_chr_df %>% filter(str_detect(`Chromosome / contig`, 'Contig')) %>% summarise(sum_column = sum(.[[3]], na.rm = TRUE)) %>% pull
common_cand_contig <- nb_per_chr_df %>% filter(str_detect(`Chromosome / contig`, 'Contig')) %>% summarise(sum_column = sum(.[[4]], na.rm = TRUE)) %>% pull
corrected_cand_contig <- nb_per_chr_df %>% filter(str_detect(`Chromosome / contig`, 'Contig')) %>% summarise(sum_column = sum(.[[5]], na.rm = TRUE)) %>% pull


# show the table
nb_per_chr_df %>%  kable_mydf()
```

Among the `r length(all_snps_id)` SNPs, `r nb_per_chr_df[nrow(nb_per_chr_df),2][[1]]` SNPs were mapped on the reference genome, including `r all_contig` on contigs not assembled on the chromosomes.

Among the `r length(all_cand)` candidate SNPs identified by at least one GEA (all candidate SNPs), `r nb_per_chr_df[nrow(nb_per_chr_df),3][[1]]` SNPs were mapped on the reference genome, including `r all_cand_contig` on contigs not assembled on the chromosomes.

Among the `r length(common_cand)` candidate SNPs identified by at least two GEAs (common candidate SNPs), `r nb_per_chr_df[nrow(nb_per_chr_df),4][[1]]` SNPs were mapped on the reference genome, including `r common_cand_contig` on contigs not assembled on the chromosomes.

Among the `r length(corrected_cand)` candidate SNPs identified by at least one GEA not correcting for population genetic structure (Candidate SNPs with population structure correction), `r nb_per_chr_df[nrow(nb_per_chr_df),5][[1]]` SNPs were mapped on the reference genome, including `r corrected_cand_contig` on contigs not assembled on the chromosomes.

```{r FigureMappingBeforePruning, fig.height=8, fig.width=14}
# Formatting gen_coord for the figure
gen_coord <- gen_coord %>%
  filter(CHROM %in% paste0("chr", 1:12)) %>%
  mutate(chrom_names = factor(chrom_names, levels=paste0("Chromosome ", 1:12)))
  
# create a list of df for each set of SNPs
snp_sets_bf_pruning <- lapply(snp_sets_bf_pruning, function(x){
  
  df <- snppos %>% dplyr::filter(snp_ID %in% x$set_snps) 

  x$gen_pos <- gen_coord %>% 
    filter(AxiomID %in% df$affx_ID) %>% 
    filter(CHROM %in% paste0("chr", 1:12))
  
  return(x)
  
})


# PLOT
#=====
legend_levels <- c(snp_sets_bf_pruning$all$set_name,
                   snp_sets_bf_pruning$all_cand$set_name,
                   snp_sets_bf_pruning$corrected_cand$set_name,
                   snp_sets_bf_pruning$common_cand$set_name)



plot_chrm <- gen_coord %>%
  ggplot() +
  
  # All SNPs (gray lines)
  geom_segment(data = snp_sets_bf_pruning$all$gen_pos, aes(x = Absolute_POS, xend = Absolute_POS, y = 0, yend = 0.2, 
                                                           col= factor(snp_sets_bf_pruning$all$set_name, levels = legend_levels)), linewidth = 0.6, alpha=0.3) + 
  
  # All candidate SNPs (red lines)
  geom_segment(data = snp_sets_bf_pruning$all_cand$gen_pos, aes(x = Absolute_POS, xend = Absolute_POS, y = 0.22, yend = 0.35, 
                                                                col = factor(snp_sets_bf_pruning$all_cand$set_name, levels = legend_levels)), linewidth = 0.6, alpha=0.6) + 
  
  # Common candidate SNPs (green lines)
  geom_segment(data = snp_sets_bf_pruning$common_cand$gen_pos, aes(x = Absolute_POS, xend = Absolute_POS, y = 0.37, yend = 0.50, 
                                                                   col = factor(snp_sets_bf_pruning$common_cand$set_name, levels = legend_levels)), linewidth = 0.6, alpha=0.6) + 
  
  # Candidate SNPs with correction (blue lines)
  geom_segment(data = snp_sets_bf_pruning$corrected_cand$gen_pos, aes(x = Absolute_POS, xend = Absolute_POS, y = 0.52, yend = 0.65, 
                                                                      col = factor(snp_sets_bf_pruning$corrected_cand$set_name, levels = legend_levels)), linewidth = 0.6, alpha=0.6) + 
  ylim(0,0.7) +
  facet_wrap(~chrom_names, scales = "free_x", ncol=3) +
  xlab("SNP positions on the reference genome") +
  ylab("") +
  theme_bw(base_size = 11) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "right",
    legend.background = element_blank(),
    panel.grid = element_blank(),
    legend.box.background = element_blank(),
    plot.background = element_blank(),
    panel.background = element_blank(),
    legend.text = element_text(size = rel(0.8)),
    strip.text = element_text(size = 11)
  ) +
  # Define colors and labels for the legend
  scale_color_manual(values = c("gray50","red", "green", "blue"), name="Sets of SNPs (before pruning)")

plot_chrm
 
ggsave(plot_chrm, filename=here("figs/GenomePosition_BeforePruning.pdf"), device="pdf", height=8, width=14)
```


## Pruning the SNPs
  
When some SNPs are on the same scaffold, we remove the SNPs with higher $p$-values in the RDA.

```{r rmSNPsSameGenomePosition}
snp_to_remove <- lapply(list(common_cand, corrected_cand, all_cand), function(set){

  snppos %>% 
  dplyr::filter(snp_ID %in% set) %>% 
  group_by(scaffold) %>% 
  filter(n()>1) %>% 
  group_split() %>% 
  lapply(function(x){

rda_outliers[[3]]$GSout %>% 
   filter(snp %in% x$snp_ID) %>% 
   arrange(pvalues) %>%  
   slice(2:nrow(x)) %>% 
   pull(snp)
      }) %>%  
  unlist
  
})


common_cand <- setdiff(common_cand, snp_to_remove[[1]])
corrected_cand <- setdiff(corrected_cand, snp_to_remove[[2]])
all_cand <- setdiff(all_cand, snp_to_remove[[3]])
```


# Control SNPs

## with random frequencies

We *randomly* sample a set of SNPs (the same number as the set with all candidate SNPs) among the SNPs that have been identified by none of the GEA methods. This set of SNPs will be used as **control SNPs**.

```{r ControlSNPsRandomFrequencies, eval=T}
nb_snps <- all_cand %>% length()

# names of the SNPs that were identified by at least one GEA method
all_candidates <- list_candidates %>% unlist() %>% unique()

# remove the candidates from the set of SNPs used in the GEA analyses
no_candidates <- all_snps_id %>% setdiff(all_candidates)

# sample the set of control SNPs
set.seed(36)
control_snps <- sample(no_candidates,nb_snps,replace = F)
```

## with frequency-matched allele frequencies

We select control SNPs randomly among the SNPs non identified by a gene-environment association methods, and with similar allele frequencies that the candidate SNPs (i.e., frequencies that matched those of the candidate SNPs).

```{r ControlSNPsMatchedFrequencies, eval=T}
# Set a seed for reproducibility
set.seed(96)

# Load the allele counts
geno <- read.csv(here("data/DryadRepo/FormattedFilteredGenomicData_AlleleCounts_withoutmaf.csv"), row.names = 1)

# Calculate the SNP frequencies by summing alleles for each SNP across all samples
# This is done by transposing the data, summing non-missing values, and dividing by 2 * (number of samples - missing values)
snp_freq <- geno %>% 
  t() %>% 
  as.data.frame() %>% 
  summarise_all(~sum(., na.rm = TRUE)/((n()-sum(is.na(.)))*2)) %>% 
  t() %>% 
  as.data.frame() %>% 
  rownames_to_column() %>% 
  set_colnames(c("snps","freq")) %>% 
  as_tibble()

# Filter for SNPs that were identified in none of the GEAs (a dataset of non-candidate SNPs)
no_candidates_freq <- snp_freq %>%  
  dplyr::filter(snps %in% no_candidates)

# Initialize an empty list to store random SNPs with matched frequencies
list_random_snps_with_matched_freq <- list()

# Loop through each SNP in the "all_cand" list
  for (i in all_cand) {
    
    # Extract the frequency of the current SNP
    freq_i <- snp_freq %>%  
      dplyr::filter(snps == i) %>% 
      .[["freq"]]
    
    # Find SNPs from the non-candidate dataset that have a frequency close to the frequency of the candidate SNP
    # A threshold of ± 0.001 is used to find SNPs with matched frequencies
    snps_with_matched_freq <-  no_candidates_freq %>% 
      dplyr::filter(!freq >freq_i + 0.002) %>% 
      dplyr::filter(!freq <freq_i - 0.002) 
  
    # Randomly select one SNP from the list of SNPs with matched frequencies
    selected_snp <- sample(snps_with_matched_freq$snps, 1)
    
    # Remove the selected SNP from the non-candidate dataset to avoid re-selecting it
    no_candidates_freq <- no_candidates_freq %>% 
      dplyr::filter(!snps == selected_snp)

    # Add the selected SNP to the list of random SNPs for this candidate SNP
    list_random_snps_with_matched_freq[[i]] <- selected_snp
  }
  
# Combine the list into a vector of randomly selected SNPs with matched frequencies
random_snps_with_matched_freq <- list_random_snps_with_matched_freq %>% unlist(use.names = F)

# Check for duplicated SNPs in the final list of random SNPs (there shouldn't be any, but we check just in case)
dups <- duplicated(random_snps_with_matched_freq)
random_snps_with_matched_freq[dups]
```


# Exporting the sets of SNPs

We save six sets of SNPs: 

  - `r length(all_cand)` candidate SNPs, i.e., SNPs identified by at least one GEA method among *RDA*, *pRDA*, *LFMM*, *BayPass* and *GF*.
  
  - `r length(corrected_cand)`  candidate SNPs with correction for population structure, i.e., SNPs identified by at least one GEA method correcting for population structure (*pRDA*, *LFMM* and *BayPass*).
  
  - `r length(common_cand)`  common candidate SNPs, i.e. SNPs identified by at least two GEA methods among *RDA*, *pRDA*, *LFMM*, *BayPass* and *GF*.
  
  - `r length(control_snps)` control SNPs with random frequencies and the same number of candidate SNPs as in the set with all candidate SNPs.
  
  - `r length(random_snps_with_matched_freq)` control SNPs with matched frequencies (i.e., similar frequencies to the frequencies of the set with all candidate SNPs), and with the same number of candidate SNPs as in the set with all candidate SNPs.
  
  - All SNPs, i.e. `r length(all_snps_id)` SNPs.


```{r SaveThreeSetsSNPs, eval=T}
snp_sets <- list(all_cand = list(set_code = "all_cand",
                                 set_name = paste0("All candidate SNPs (", length(all_cand),")"),
                                 set_snps = all_cand),
                 common_cand = list(set_code = "common_cand",
                                    set_name = paste0("Common candidate SNPs (", length(common_cand),")"),
                                    set_snps = common_cand),
                 corrected_cand = list(set_code = "corrected_cand",
                                       set_name = paste0("Candidate SNPs considering pop. struct. correction (", length(corrected_cand),")"),
                                       set_snps = corrected_cand),
                 randomfreq_control = list(set_code = "randomfreq_control",
                                           set_name = paste0("Control SNPs unmatching allele frequencies (", length(control_snps),")"),
                                           set_snps = control_snps),
                 simfreq_control = list(set_code = "simfreq_control", 
                                        set_name = paste0("Control SNPs matching allele frequencies (", length(random_snps_with_matched_freq),")"),
                                        set_snps = random_snps_with_matched_freq),
                 all = list(set_code = "all",
                            set_name = paste0("All SNPs (", length(all_snps_id),")"),
                            set_snps = all_snps_id))



saveRDS(snp_sets,here("outputs/list_snp_sets.rds"))
```

*<span style="color: orange;">Comment regarding the DRYAD repository: </span>* We update the dataset `data/GenomicData/SNPsInformation.csv` containing information of SNP position on the genome and the different SNP IDs used across studies/assays (see report `1_FormattingGenomicData.Rmd`) with information on outlier SNPs. This updated dataset is exported in the DRYAD repository: file `SNPsInformation_WithOutliers.csv`.
Meaning of the columns:

  1. `snp_ID`: SNP ID used in the present study.
  2. `original_ID`: Original ID of the SNP.
  3. `affx_ID`: SNP ID in the Axiom assay.
  4. `infinium_ID`: SNP ID in the Infinium assay.
  5. `scaffold/contig`: contig on which the SNP is located. The term scaffold is also used as some SNPs were obtained from the alignment of NGS short-reads from a pseudoreference genome in *Pinus pinaster* that were called scaffolds (even though there are not really scaffolds).
  6. `genome_position`: position of the SNP on the scaffold/contig (in bp).
  7. `annotation`: SNP name (including possible alternative names).
  8. `MAF_filtering`: `REMOVED` for SNPs with minor allele frequencies, which are removed for GEAs analyses but not for estimating the neutral population genetic structure; `KEPT` otherwise.
  9. `RDA_outliers`: `TRUE` if the SNP was identified as an outlier in the RDA; `FALSE` otherwise.
  10. `pRDA_outliers`: `TRUE` if the SNP was identified as an outlier in the pRDA; `FALSE` otherwise.
  11. `GF_outliers`: `TRUE` if the SNP was identified as an outlier with the GF algorithm; `FALSE` otherwise.
  12. `LFMM_outliers`: `TRUE` if the SNP was identified as an outlier woth LFMM; `FALSE` otherwise.
  13. `BayPass_outliers`: `TRUE` if the SNP was identified as an outlier with BayPass; `FALSE` otherwise.
  14. `all_candidate_SNPs`: `TRUE` if the SNP was an outlier identified by at least one GEA method among RDA, pRDA, LFMM, BayPass and GF; `FALSE` otherwise.
  15. `common_candidate_SNPs`: `TRUE` if the SNP was an outlier identified by at least two GEA methods among RDA, pRDA, LFMM, BayPass and GF; `FALSE` otherwise.
  16. `candidate_SNPs_corrected_pop_structure`: `TRUE` if the SNP was an outlier identified by at least one GEA method correcting for population genetic structure (i.e., pRDA, LFMM or BayPass); `FALSE` otherwise.
  17. `random_control_SNPs`: `TRUE` if the SNP was a control SNP randomly sampled among the SNPs not identified by any GEA method; `FALSE` otherwise.
  18. `control_SNPs_matching_allele_freq`: `TRUE` if the SNP was a control SNP sampled among the SNPs not identified by any GEA method, and has a similar allele frequency to a candidate SNP; `FALSE` otherwise.

Below are shown the first 10 rows of the dataset.

```{r ExportDRYADrepoListSNPsWithInformation}
listsnps <- read_csv2(here("data/GenomicData/SNPsInformation.csv"),show_col_types = FALSE) %>%  
  mutate(RDA_outliers = ifelse(snp_ID %in% list_candidates$`RDA (mahalanobis)`, TRUE, FALSE),
         pRDA_outliers = ifelse(snp_ID %in% list_candidates$`pRDA (mahalanobis)`, TRUE, FALSE),
         GF_outliers = ifelse(snp_ID %in% list_candidates$GF, TRUE, FALSE),
         LFMM_outliers = ifelse(snp_ID %in% list_candidates$LFMM, TRUE, FALSE),
         BayPass_outliers = ifelse(snp_ID %in% list_candidates$BayPass, TRUE, FALSE),
         all_candidate_SNPs = ifelse(snp_ID %in% all_cand, TRUE, FALSE),
         common_candidate_SNPs = ifelse(snp_ID %in% common_cand, TRUE, FALSE),
         candidate_SNPs_corrected_pop_structure = ifelse(snp_ID %in% corrected_cand, TRUE, FALSE),
         random_control_SNPs = ifelse(snp_ID %in% control_snps, TRUE, FALSE),
         control_SNPs_matching_allele_freq = ifelse(snp_ID %in% random_snps_with_matched_freq, TRUE, FALSE))


listsnps %>% write_csv2(here("data/DryadRepo/SNPsInformation_WithOutliers.csv"),append=FALSE)

listsnps[1:10,] %>% kable_mydf()
```

# Genome position of all sets of SNPs

## Table

```{r TableMappingAfterPruning, fig.height=8, fig.width=14}
# SNPs position on the reference genome
gen_coord <- read_delim("~/Documents/Projects/GOPredEvalPinpin/data/GenomicData/maritime_pine_coord.txt", show_col_types = FALSE) %>% 
  mutate(chrom_names = if_else(CHROM %in% paste0("chr",1:12), paste0("Chromosome ", CHROM %>% str_sub(4,-1)), paste0("Contig ",CHROM)))


# Counting the number of candidate SNPs per chromosome
nb_per_chr_list <- lapply(snp_sets, function(x){
  
  df <- snppos %>% dplyr::filter(snp_ID %in% x$set_snps) 
  
  gen_coord %>% 
    filter(AxiomID %in% df$affx_ID) %>% 
    group_by(chrom_names) %>% 
    summarise(n = n()) %>% 
    set_colnames(c("Chromosome / contig", x$set_name))

}) 


# Merging the counts in one table
nb_per_chr_df <- nb_per_chr_list[[1]] %>%
  full_join(nb_per_chr_list[[2]], by = "Chromosome / contig") %>%
  full_join(nb_per_chr_list[[3]], by = "Chromosome / contig") %>%
  full_join(nb_per_chr_list[[4]], by = "Chromosome / contig") %>%
  full_join(nb_per_chr_list[[5]], by = "Chromosome / contig") %>%
  full_join(nb_per_chr_list[[6]], by = "Chromosome / contig") %>%
  # Replace NA values with 0 across all numeric columns
  mutate(across(where(is.numeric), ~replace_na(., 0))) 

# Sum the total of SNPs mapped on the reference genome for each set of SNPs
nb_per_chr_df <- nb_per_chr_df %>% summarise(
  `Chromosome / contig` = "Total",
  across(where(is.numeric), \(x) sum(x, na.rm = TRUE))) %>% 
  bind_rows(nb_per_chr_df,.) 

# for the text below
all_cand_contig <- nb_per_chr_df %>% filter(str_detect(`Chromosome / contig`, 'Contig')) %>% summarise(sum_column = sum(.[[2]], na.rm = TRUE)) %>% pull
common_cand_contig <- nb_per_chr_df %>% filter(str_detect(`Chromosome / contig`, 'Contig')) %>% summarise(sum_column = sum(.[[3]], na.rm = TRUE)) %>% pull
corrected_cand_contig <- nb_per_chr_df %>% filter(str_detect(`Chromosome / contig`, 'Contig')) %>% summarise(sum_column = sum(.[[4]], na.rm = TRUE)) %>% pull
randomfreq_control_contig <- nb_per_chr_df %>% filter(str_detect(`Chromosome / contig`, 'Contig')) %>% summarise(sum_column = sum(.[[5]], na.rm = TRUE)) %>% pull
simfreq_control_contig <- nb_per_chr_df %>% filter(str_detect(`Chromosome / contig`, 'Contig')) %>% summarise(sum_column = sum(.[[6]], na.rm = TRUE)) %>% pull
all_contig <- nb_per_chr_df %>% filter(str_detect(`Chromosome / contig`, 'Contig')) %>% summarise(sum_column = sum(.[[7]], na.rm = TRUE)) %>% pull

# show the table
nb_per_chr_df %>%  kable_mydf()
```

Among the `r length(all_cand)` candidate SNPs identified by at least one GEA (all candidate SNPs), `r nb_per_chr_df[nrow(nb_per_chr_df),2][[1]]` SNPs were mapped on the reference genome, including `r all_contig` on contigs not assembled on the chromosomes.

Among the `r length(common_cand)` candidate SNPs identified by at least two GEAs (common candidate SNPs), `r nb_per_chr_df[nrow(nb_per_chr_df),3][[1]]` SNPs were mapped on the reference genome, including `r corrected_cand_contig` on contigs not assembled on the chromosomes.

Among the `r length(corrected_cand)` candidate SNPs identified by at least one GEA not correcting for population genetic structure (Candidate SNPs with population structure correction), `r nb_per_chr_df[nrow(nb_per_chr_df),4][[1]]` SNPs were mapped on the reference genome, including `r corrected_cand_contig` on contigs not assembled on the chromosomes.

Among the `r length(control_snps)` control SNPs with random frequencies, `r nb_per_chr_df[nrow(nb_per_chr_df),5][[1]]` SNPs were mapped on the reference genome, including `r randomfreq_control_contig` on contigs not assembled on the chromosomes.

Among the `r length(random_snps_with_matched_freq)` control SNPs with similar frequencies than the candidate SNPs, `r nb_per_chr_df[nrow(nb_per_chr_df),6][[1]]` SNPs were mapped on the reference genome, including `r simfreq_control_contig` on contigs not assembled on the chromosomes.

Among the `r length(all_snps_id)` SNPs, `r nb_per_chr_df[nrow(nb_per_chr_df),7][[1]]` SNPs were mapped on the reference genome, including `r all_contig` on contigs not assembled on the chromosomes.

```{r TableGenPos}
nb_per_chr_df_SI <- nb_per_chr_df %>% 
  filter(str_detect(`Chromosome / contig`, 'Contig')) %>% 
  summarise(
  `Chromosome / contig` = "Unassembled contigs",
  across(where(is.numeric), \(x) sum(x, na.rm = TRUE))) %>% 
  bind_rows(nb_per_chr_df,.) %>% 
  filter(!str_detect(`Chromosome / contig`, 'Contig')) %>% 
  mutate(`Chromosome / contig` = factor(`Chromosome / contig`, levels = c(paste0("Chromosome ", 1:12), "Unassembled contigs","Total"))) %>%
  arrange(`Chromosome / contig`)

nb_per_chr_df_SI %>% saveRDS(here("tables/GenomePositionReferenceGenome.rds"))

nb_per_chr_df_SI %>% kable_mydf()
```

## Figure 

```{r FigureMappingAfterPruning, fig.height=8, fig.width=14}
# Formatting gen_coord for the figure
gen_coord <- gen_coord %>%
  filter(CHROM %in% paste0("chr", 1:12)) %>%
  mutate(chrom_names = factor(chrom_names, levels=paste0("Chromosome ", 1:12)))
  
# create a list of df for each set of SNPs
snp_sets <- lapply(snp_sets, function(x){
  
  df <- snppos %>% dplyr::filter(snp_ID %in% x$set_snps) 

  x$gen_pos <- gen_coord %>% 
    filter(AxiomID %in% df$affx_ID) %>% 
    filter(CHROM %in% paste0("chr", 1:12))
  
  return(x)
  
})


# PLOT
#=====
legend_levels <-  c(snp_sets$all$set_name,
                    snp_sets$all_cand$set_name,
                    snp_sets$corrected_cand$set_name,
                    snp_sets$common_cand$set_name,
                    snp_sets$randomfreq_control$set_name,
                    snp_sets$simfreq_control$set_name)
  
alpha_snp_sets <- 0.7

plot_chrm <- gen_coord %>%
  ggplot() +
  # All SNPs of the reference genome 
  #geom_segment(aes(x = Absolute_POS, xend = Absolute_POS, y = 0, yend = 0.2, col = factor(legend_levels[[1]], levels = legend_levels)), size = 0.6, alpha=0.3) + 
  
   # All SNPs (red lines)
  geom_segment(data = snp_sets$all$gen_pos, aes(x = Absolute_POS, xend = Absolute_POS, y = 0, yend = 0.18, col = factor(snp_sets$all$set_name, 
                                                                levels = legend_levels)), linewidth = 0.6, alpha = alpha_snp_sets) + 
  # All candidate SNPs (red lines)
  geom_segment(data = snp_sets$all_cand$gen_pos, aes(x = Absolute_POS, xend = Absolute_POS, y = 0.2, yend = 0.38, col = factor(snp_sets$all_cand$set_name, 
                                                                levels = legend_levels)), linewidth = 0.6, alpha=alpha_snp_sets) + 
  # Common candidate SNPs (green lines)
  geom_segment(data = snp_sets$common_cand$gen_pos, aes(x = Absolute_POS, xend = Absolute_POS, y = 0.4, yend = 0.58, col = factor(snp_sets$common_cand$set_name, 
                                                                levels = legend_levels)), linewidth = 0.6, alpha=alpha_snp_sets) + 
  # Candidate SNPs with correction (blue lines)
  geom_segment(data = snp_sets$corrected_cand$gen_pos, aes(x = Absolute_POS, xend = Absolute_POS, y = 0.6, yend = 0.78, col = factor(snp_sets$corrected_cand$set_name, 
                                                                levels = legend_levels)), linewidth = 0.6, alpha=alpha_snp_sets) + 
  # Control SNPs with random frequencies
  geom_segment(data = snp_sets$randomfreq_control$gen_pos, aes(x = Absolute_POS, xend = Absolute_POS, y = 0.8, yend = 0.98, 
                                                               col = factor(snp_sets$randomfreq_control$set_name, 
                                                                levels = legend_levels)), linewidth = 0.6, alpha=alpha_snp_sets) + 
  # Control SNPs with matched frequencies
  geom_segment(data = snp_sets$simfreq_control$gen_pos, aes(x = Absolute_POS, xend = Absolute_POS, y = 1, yend = 1.18, col = factor(snp_sets$simfreq_control$set_name, 
                                                                levels = legend_levels)), linewidth = 0.6, alpha=alpha_snp_sets) + 
  
  ylim(0,1.2) +
  facet_wrap(~chrom_names, scales = "free_x", ncol=3) +
  xlab("SNP positions on the reference genome") +
  ylab("") +
  theme_bw(base_size = 11) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "right",
    legend.background = element_blank(),
    panel.grid = element_blank(),
    legend.box.background = element_blank(),
    plot.background = element_blank(),
    panel.background = element_blank(),
    legend.text = element_text(size = rel(0.8)),
    strip.text = element_text(size = 11)
  ) +
  # Define colors and labels for the legend
  scale_color_manual(values = c("gray50","red", "green", "blue","orange","purple"), name="Sets of SNPs (after pruning)")

plot_chrm
 
ggsave(plot_chrm, filename=here("figs/GenomePosition_AfterPruning.pdf"), device="pdf", height=8, width=14)
```




# Session information

```{r SessionInfo}
devtools::session_info()
```

  