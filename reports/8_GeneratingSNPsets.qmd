---
title: "Generating sets of control and candidate SNPs"
subtitle: "Identification of outlier SNPs in common among the different GEAs"
date: last-modified
format: 
  html:
    toc: true
    toc-depth: 4
    code-fold: true
    page-layout: full
embed-resources: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body {
   font-size: 15px;
}
code.r{
  font-size: 11px;
}
pre {
  font-size: 11px
}

table {
  font-size: 10px
}
</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 4,fig.height = 4,cache=F)
options(width = 300)
library(knitr)
library(tidyverse)
library(readxl)
library(xtable)
library(reshape2)
library(kableExtra)
library(here)
library(cowplot)
library(ggVennDiagram)
library(UpSetR)
library(magrittr)

# my own function for building tables in reports
source(here("scripts/functions/kable_mydf.R"))
```


```{r MakeVennDiagrams}
# function to make the Venn diagrams
make_venndiagram <- function(list_candidates,
                             caption="",
                             label="both",
                             title=""){

list_candidates %>% 
    ggVennDiagram(lty="solid", size=0.2, label = "count", label_alpha=0, edge_size = 0.4) + 
  scale_fill_gradient2(low = "white", high = 'darkgoldenrod3') + 
  scale_color_manual(values = rep("darkgoldenrod1",6)) + 
  guides(fill = "none") + 
  labs(caption=caption) +
  ggtitle(title) +
  theme(text = element_text(size=16),
        plot.caption = element_text(hjust=0.5, size=rel(1.2))) + 
  scale_x_continuous(expand = expansion(mult = .2))
}
```


# GEA methods

Candidate SNPs were identified using different gene-environment association (GEA) methods, which we summarize below.

## Redundancy analysis (RDA)

Two RDA models were fitted:

  - not accounting for population structure, which we will call *<span style="color: orange;">RDA</span>*.
  
  - accounting for population structure by incorporating in the RDA model the three first PCs of the PCA performed on the genomic dataset (not filtered for minor allele frequencies), which we will call *<span style="color: orange;">pRDA</span>*.


RDA candidates are SNPs that have been identified with one of these two methods:

   - based on their *extremeness* along a *distribution of Mahalanobis distances* estimated between each locus and the center of the RDA space using a $K$ number of axes (we used $K=2$). This method was used in @capblancq2020climate (see [code](https://github.com/Capblancq/Local-Adaptation-Fagus-sylvatica)) and @capblancq2021redundancy ([code](https://github.com/Capblancq/RDA-landscape-genomics)). For that, (1) the Mahalanobis distances were calculated, (2) $p$-values and $q$-values were obtained with the `radapt` function from @capblancq2021redundancy, and (3) a FDR (False Discovery Rate) threshold of 5% was applied to the $q$-values to identify the outliers.

  - based on *extreme loadings on each significant axis*. Method used in @forester2018comparing (see [code](https://popgen.nescent.org/2018-03-27_RDA_GEA.html)). We use a 3 standard deviation cutoff (two-tailed $p$-value = 0.0027) to identify the outliers.
  

Below, we only keep the SNPs that have been identified with the Mahalanobis distance method.
 
```{r RDAoutliers, fig.width=12,fig.height=5}
par(mfrow=c(1,2))

rda_outliers <- readRDS(here::here("outputs/RDA/RDA_outliers.rds"))

list_candidates <- list("RDA"=rda_outliers[[3]]$outliers$snp,
                        "pRDA"=rda_outliers[[4]]$outliers$snp,
                        "RDA (mahalanobis)"=rda_outliers[[3]]$outliers %>% dplyr::filter(maha_meth==T) %>% pull(snp),
                        "RDA (loadings)"=rda_outliers[[3]]$outliers %>% dplyr::filter(load_meth==T) %>% pull(snp),
                        "pRDA (mahalanobis)"=rda_outliers[[4]]$outliers %>% dplyr::filter(maha_meth==T) %>% pull(snp),
                        "pRDA (loadings)"=rda_outliers[[4]]$outliers %>% dplyr::filter(load_meth==T) %>% pull(snp))



p <- make_venndiagram(list_candidates[c("RDA","pRDA")], title = "Mahalanobis and loadings methods")


pp <- make_venndiagram(list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)")], title = "Mahalanobis method only")

plot_grid(p,pp,nrow=1)

p <- make_venndiagram(list_candidates[c("RDA (loadings)","pRDA (loadings)")], title = "Loadings method only")


pp <- make_venndiagram(list_candidates[c("RDA (mahalanobis)","RDA (loadings)","pRDA (mahalanobis)","pRDA (loadings)")],
  label="count")

plot_grid(p,pp,nrow=1)
```


## Gradient forest (GF)

GF-based GEA was performed following @fitzpatrick2021experimental and @capblancq2023common, using *raw* or *uncorrected* allele frequencies. Because the SNPs with the lowest empirical $p$-values (i.e. the highest $R^2$) were not exactly the same across independent runs of the GF-based GEA, we ran 3 independent runs, identified the 0.5\% SNPs with the lowest empirical $p$-values for each run (i.e. 49 SNPs for each run) and then considered as outlier SNPs the SNPs identified in the three runs.
  
```{r GFoutliers, fig.width=12,fig.height=5}
list_candidates$"GF"= readRDS(here::here("outputs/GF/GFCommonOutliers_ThreeRuns_RawAlleleFrequencies.rds"))
```


## Latent factor mixed model (LFMM)

We identified the candidate SNPs by applying a FDR threshold of 5% to the p-values from a LFMM. LFMM was corrected for population structure (ie population relatedness) as the population structure should be captured by the $K$ latent factors ($K = 5$ in our case).

```{r LFMMoutliers}
list_candidates$"LFMM" <- readRDS(here::here("outputs/LFMM/candidates.rds"))
```

<span style="color: OrangeRed;">`r length(list_candidates$LFMM)` candidate SNPs</span> were identified with the LFMM approach.


## BayPass


```{r BayPassOutliers}
list_candidates$"BayPass" <- readRDS(here("outputs/BayPass/baypass_outliers.rds"))
```

<span style="color: OrangeRed;">`r length(list_candidates$BayPass)` candidate SNPs</span> were identified with <span style="font-variant:small-caps;">BayPass</span>. SNPs were considered as outliers in BayPass when their Bayes factors were higher than 10.



# Common candidate SNPs

Let's look at the common candidates across the different GEA methods. 


```{r VennDiagramCommoncandidates,fig.height=5,fig.width=8}
# generating the Venn diagrams showing common candidates across GEA methods
make_venndiagram(list_candidates[c("RDA (mahalanobis)","GF")],
                 caption = "GEA methods not correcting for population structure",label="count")
make_venndiagram(list_candidates[c("pRDA (mahalanobis)","LFMM","BayPass")],
                 caption = "GEA methods correcting for population structure",label="count")


# Identifying SNPs identified by at least two GEA methods
common_cand_notcorrected <- list_candidates[c("RDA (mahalanobis)","GF")] %>% unlist() %>% .[duplicated(.)] %>% unique()
common_cand_corrected <- list_candidates[c("pRDA (mahalanobis)","LFMM","BayPass")] %>% unlist() %>% .[duplicated(.)] %>% unique()
common_cand <- list_candidates[c("RDA (mahalanobis)","GF","pRDA (mahalanobis)","LFMM","BayPass")] %>% unlist() %>% .[duplicated(.)] %>% unique()
common_cand_RDA_LFMM <- list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM")] %>% unlist() %>% .[duplicated(.)] %>% unique()
common_cand_RDA_LFMM_BayPass <- list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM","BayPass")] %>% unlist() %>% .[duplicated(.)] %>% unique()

# Identifying SNPs in common between some of the GEA methods
common_cand_RDA_LFMM_intersect <- list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM")] %>% Reduce(intersect, .)
common_cand_RDA_LFMM_BayPass_intersect <- list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM","BayPass")] %>% Reduce(intersect, .)
```


**Possible sets of candidate SNPs:**

  1. SNPs identified by at least two methods [like in @capblancq2023common] => <span style="color: OrangeRed;">`r common_cand %>% length()` SNPs.</span>

  2. SNPs that were identified by at least one GEA method not correcting for population structure, namely *RDA* and *GF* => <span style="color: OrangeRed;">`r common_cand_notcorrected %>% length()` SNPs.</span>
  
  3. SNPs that were identified by at least one GEA method correcting for population structure, namely *pRDA*, *LFMM* and *BayPass* => <span style="color: OrangeRed;">`r common_cand_corrected %>% length()` SNPs.</span>
  
  4. SNPs identified by at least two methods among *RDA*, *pRDA* and *LFMM* => <span style="color: OrangeRed;">`r common_cand_RDA_LFMM %>% length()` SNPs.</span>
  
  5. SNPs identified by at least two methods among *RDA*, *pRDA*, *LFMM* and *BayPass* => <span style="color: OrangeRed;">`r common_cand_RDA_LFMM_BayPass %>% length()` SNPs.</span>
  
  6. SNPs in common between *RDA*, *pRDA* and *LFMM* => <span style="color: OrangeRed;">`r common_cand_RDA_LFMM_intersect %>% length()` SNPs.</span>
  
  7. SNPs in common between *RDA*, *pRDA*, *LFMM* and *BayPass* => <span style="color: OrangeRed;">`r common_cand_RDA_LFMM_BayPass_intersect %>% length()` SNPs.</span>

<span style="color: OrangeRed;">`r length(intersect(common_cand_corrected,common_cand_notcorrected))` SNPs</span> are in common between the sets 2 and 3.

> Our choice

In the following analyses, we use **the set with SNPs identified by at least two methods** (set 1) (**`r common_cand %>% length()` SNPs**). The rationale is that we aim to obtain a set of candidate SNPs that is enriched for loci involved in adaptation to climate, so we tried to find a good balance between not being too conservative (e.g. by selecting SNPs in common across all methods) and not including too many false positives (e.g. by selecting SNPs identified by at least one GEA). We also wanted to give the possibility to select candidates that can only be identified with methods correcting for population structure (pRDA, LFMM, BayPass) or candidates that can only be identified by methods not correcting for population structure (RDA and GF). 

```{r VennDiagrammSelectedMethods,fig.height=7,fig.width=7}
make_venndiagram(list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM","BayPass","GF")],
                 label="count",
                 caption = "Selected methods")
```

 
> Comparison with @capblancq2023common

In @capblancq2023common, they selected the SNPs that were in the top 0.2% for at least two of four genome scans (GF, GF-X, RDA or pRDA), which resulted in the selection of 240 loci (over 335 588 loci exhibiting  MAF > 0.1). They observed substantial overlap between RDA and GF when neutral population structure was not accounted for, with 149 loci (i.e. 22% of each set) found by both methods. On the contrary, congruence was low when correcting for population structure, with only 15 common loci (2%) between methods, and no visible covariation between GF R2 and RDA Mahalanobis distance.
  

### Figure 2 of the manuscript


#### Venn diagram (first version)

We generate the figure for the main manuscript (Figure 2).

```{r GeneratingFigure2ManuscriptVennDiagram}
selected_methods <- list_candidates[c("RDA (mahalanobis)","pRDA (mahalanobis)","LFMM","BayPass","GF")]
names(selected_methods) <- c("RDA (nc)", "pRDA (c)", "LFMM (c)", "BayPass (c)", "GF (nc)")

make_venndiagram(selected_methods,
                 label="count") %>% 
ggsave(filename = here("figs/VennDiagram_CommonOutliers.pdf"), device = "pdf", width = 6.5, height = 6.5)
```

#### Upset plot

Following a reviewer’s comment, we updated Figure 2 from a Venn diagram to a more comprehensive [upset plot](https://r-graph-gallery.com/upset-plot.html). 


```{r GeneratingFigure2ManuscriptUpsetPlot, fig.width=7, fig.height=7}
pdf(file=here("figs/UpsetPlot_CommonOutliers.pdf"), onefile=FALSE, width = 5, height = 5)
upset(fromList(selected_methods),order.by = "freq",  point.size = 3.1)
dev.off()

upset(fromList(selected_methods),order.by = "freq")
```

# Genome position of candidate SNPs

We load the dataset `genome_position.xlsx` containing information about the genome positions of the SNPs. In the DRYAD repository, this information is available in the `ListSNPs_withoutmaf.csv` and `ListSNPs_withmaf.csv` datasets.

```{r LoadGenomePositionData}
snppos <- read_excel(here("data/GenomicData/genome_position.xlsx"), sheet = "base_table") %>% 
  dplyr::rename(snp_ID = Juliette_snp_ID,
                original_ID = Original_ID,
                affx_ID = affy_snp_id,
                infinium_ID = Infinium_ID,
                genome_position =`position (bp)`,
                annotation =`Annotation (including alternative names)`) %>% 
  dplyr::select(snp_ID, original_ID, affx_ID, infinium_ID, scaffold, genome_position, annotation)
```

Information on genome position for candidates SNPs identified by at least two GEA methods:

```{r GenomePositionCandidates}
snppos %>% 
  dplyr::filter(snp_ID %in% common_cand) %>% 
  kable_mydf(boldfirstcolumn = F, font_size = 11)
```

SNPs on the same scaffold:

```{r SNPsSameScaffold}
snppos %>% 
  dplyr::filter(snp_ID %in% common_cand) %>% 
  group_by(scaffold) %>% 
  filter(n()>1) %>% 
  kable_mydf(boldfirstcolumn = F, font_size = 11)
```

**Comment:** a scaffold is a set of contigs separated by gaps and for which the relative orientation and distance is known.

If we keep only one SNP per scaffold, we will have:

  - <span style="color: OrangeRed;">`r snppos %>% dplyr::filter(snp_ID %in% common_cand) %>% pull(scaffold) %>% unique() %>% length()` candidate SNPs</span> identified by at least one GEA method among *RDA*, *pRDA*, *LFMM*, *BayPass* and *GF*.

  - <span style="color: OrangeRed;">`r snppos %>% dplyr::filter(snp_ID %in% common_cand_notcorrected) %>% pull(scaffold) %>% unique() %>% length()` candidate SNPs</span> identified by at least one GEA method not correcting for population structure (*RDA* and *GF*).
  
  - <span style="color: OrangeRed;">`r snppos %>% dplyr::filter(snp_ID %in% common_cand_corrected) %>% pull(scaffold) %>% unique() %>% length()` candidate SNPs</span> identified by at least one GEA method correcting for population structure (*pRDA*, *LFMM* and *BayPass*).
  
  
When some SNPs are on the same scaffold, we remove the SNPs with higher $p$-values in the RDA.

```{r rmSNPsSameGenomePosition}
snp_to_remove <- lapply(list(common_cand,common_cand_corrected), function(set){

  snppos %>% 
  dplyr::filter(snp_ID %in% set) %>% 
  group_by(scaffold) %>% 
  filter(n()>1) %>% 
  group_split() %>% 
  lapply(function(x){

rda_outliers[[3]]$GSout %>% 
   filter(snp %in% x$snp_ID) %>% 
   arrange(pvalues) %>%  
   slice(2:nrow(x)) %>% 
   pull(snp)
      }) %>%  
  unlist
  
})


common_cand <- setdiff(common_cand, snp_to_remove[[1]])
common_cand_corrected <- setdiff(common_cand_corrected, snp_to_remove[[2]])
```

# Control SNPs

## with random frequencies

We *randomly* sample a set of SNPs (the same number as the candidate SNPs) among the SNPs that have been identified by none of the GEA methods. This set of SNPs will be used as **control SNPs**.

```{r ControlSNPs, eval=T}
nb_snps <- common_cand %>% length()

# names of the SNPs that were identified by at least one GEA method
all_candidates <- list_candidates %>% unlist() %>% unique()

# remove the candidates from the set of SNPs used in the GEA analyses
no_candidates <- read.csv(here("data/DryadRepo/FormattedFilteredGenomicData_AlleleCounts_withoutmaf.csv")) %>% 
  pull(snp_ID) %>% 
  setdiff(all_candidates)

# sample the set of control SNPs
set.seed(36)
control_snps <- sample(no_candidates,nb_snps,replace = F)
```

## with similar allele frequencies

We select control SNPs randomly but with similar allele frequencies that the candidate SNPs.

```{r}
# Set a seed for reproducibility
set.seed(96)

# Load the allele counts
geno <- read.csv(here("data/DryadRepo/FormattedFilteredGenomicData_AlleleCounts_withoutmaf.csv"), row.names = 1)

# Calculate the SNP frequencies by summing alleles for each SNP across all samples
# This is done by transposing the data, summing non-missing values, and dividing by 2 * (number of samples - missing values)
snp_freq <- geno %>% 
  t() %>% 
  as.data.frame() %>% 
  summarise_all(~sum(., na.rm = TRUE)/((n()-sum(is.na(.)))*2)) %>% 
  t() %>% 
  as.data.frame() %>% 
  rownames_to_column() %>% 
  set_colnames(c("snps","freq")) %>% 
  as_tibble()

# Filter for SNPs that were identified in none of the GEAs (a dataset of non-candidate SNPs)
no_candidates_freq <- snp_freq %>%  
  dplyr::filter(snps %in% no_candidates)

# Initialize an empty list to store random SNPs with similar frequencies
list_random_snps_with_similar_freq <- list()

# Loop through each SNP in the "common_cand" list
  for (i in common_cand) {
    
    # Extract the frequency of the current SNP
    freq_i <- snp_freq %>%  
      dplyr::filter(snps == i) %>% 
      .[["freq"]]
    
    # Find SNPs from the non-candidate dataset that have a frequency similar to the current SNP
    # A threshold of ± 0.001 is used to find SNPs with similar frequencies
    snps_with_similar_freq <-  no_candidates_freq %>% 
      dplyr::filter(!freq >freq_i + 0.001) %>% 
      dplyr::filter(!freq <freq_i - 0.001) 
  
    # Randomly select one SNP from the list of SNPs with similar frequencies
    selected_snp <- sample(snps_with_similar_freq$snps, 1)
    
    # Remove the selected SNP from the non-candidate dataset to avoid re-selecting it
    no_candidates_freq <- no_candidates_freq %>% 
      dplyr::filter(!snps == selected_snp)

    # Add the selected SNP to the list of random SNPs for this candidate SNP
    list_random_snps_with_similar_freq[[i]] <- selected_snp
  }
  
# Combine the list into a vector of randomly selected SNPs with similar frequencies to the candidate SNPs
random_snps_with_similar_freq <- list_random_snps_with_similar_freq %>% unlist(use.names = F)

# Check for duplicated SNPs in the final list of random SNPs (there shouldn't be any, but we check just in case)
dups <- duplicated(random_snps_with_similar_freq)
random_snps_with_similar_freq[dups]
```


# Exporting the sets of SNPs

We save three sets of SNPs: 

  - the candidate SNPs, i.e., SNPs identified by at least one GEA method among *RDA*, *pRDA*, *LFMM*, *BayPass* and *GF*.
  
  - the candidate SNPs with correction for population structure, i.e., SNPs identified by at least one GEA method correcting for population structure (*pRDA*, *LFMM* and *BayPass*).
  
  - the control SNPs.
  
::: {.callout-note}
In the paper and in the validation steps, we only use the candidate (i.e., those identified by at least one GEA method among *RDA*, *pRDA*, *LFMM*, *BayPass* and *GF*) and control SNPs.
:::


```{r SaveThreeSetsSNPs, eval=T}
snp_sets <- list(cand = list(set_code = "cand",
                             set_name = "Candidate SNPs",
                             set_snps = common_cand),
                 cand_corrected = list(set_code = "cand_corrected",
                                       set_name = "Candidate SNPs (with correction)",
                                       set_snps = common_cand_corrected),
                 control = list(set_code = "control",
                                set_name = "Control SNPs",
                                set_snps = control_snps),
                 control_simfreq = list(set_code = "control_simfreq", 
                                        set_name = "Control SNPs with similar frequencies",
                                        set_snps = random_snps_with_similar_freq))

saveRDS(snp_sets,here("outputs/list_snp_sets.rds"))
```

::: {.callout-note}
##### DRYAD repository

We update the dataset `data/GenomicData/SNPsInformation.csv` containing information of SNP position on the genome and the different SNP IDs used across studies/assays (see report `1_FormattingGenomicData.Rmd`) with information on outlier SNPs. This updated dataset is exported in the DRYAD repository: file `SNPsInformation_WithOutliers.csv`.
:::

Meaning of the columns:

  1. `snp_ID`: SNP ID used in the present study.
  2. `original_ID`: Original ID of the SNP.
  3. `affx_ID`: SNP ID in the Axiom assay.
  4. `infinium_ID`: SNP ID in the Infinium assay.
  5. `scaffold/contig`: contig on which the SNP is located. The term scaffold is also used as some SNPs were obtained from the alignment of NGS short-reads from a pseudoreference genome in *Pinus pinaster* that were called scaffolds (even though there are not really scaffolds).
  6. `genome_position`: position of the SNP on the scaffold/contig (in bp).
  7. `annotation`: SNP name (including possible alternative names).
  8. `MAF_filtering`: `REMOVED` for SNPs with minor allele frequencies, which are removed for GEAs analyses but not for estimating the neutral population genetic structure; `KEPT` otherwise.
  9. `RDA_outliers`: `TRUE` if the SNP was identified as an outlier in the RDA; `FALSE` otherwise.
  10. `pRDA_outliers`: `TRUE` if the SNP was identified as an outlier in the pRDA; `FALSE` otherwise.
  11. `GF_outliers`: `TRUE` if the SNP was identified as an outlier with the GF algorithm; `FALSE` otherwise.
  12. `LFMM_outliers`: `TRUE` if the SNP was identified as an outlier woth LFMM; `FALSE` otherwise.
  13. `BayPass_outliers`: `TRUE` if the SNP was identified as an outlier with BayPass; `FALSE` otherwise.
  14. `common_outliers`: `TRUE` if the SNP was a common outlier, i.e. an outlier identified by at least one GEA method among RDA, pRDA, LFMM, BayPass and GF; `FALSE` otherwise. These SNPs were used for GO predictions.
  15. `control_snps`: `TRUE` if the SNP was included in the set of control SNPs; `FALSE` otherwise.
  

Below are shown the first 10 rows of the dataset.

```{r ExportDRYADrepoListSNPsWithInformation}
listsnps <- read_csv2(here("data/GenomicData/SNPsInformation.csv"),show_col_types = FALSE) %>%  
  mutate(RDA_outliers = ifelse(snp_ID %in% list_candidates$`RDA (mahalanobis)`, TRUE, FALSE),
         pRDA_outliers = ifelse(snp_ID %in% list_candidates$`pRDA (mahalanobis)`, TRUE, FALSE),
         GF_outliers = ifelse(snp_ID %in% list_candidates$GF, TRUE, FALSE),
         LFMM_outliers = ifelse(snp_ID %in% list_candidates$LFMM, TRUE, FALSE),
         BayPass_outliers = ifelse(snp_ID %in% list_candidates$BayPass, TRUE, FALSE),
         common_outliers = ifelse(snp_ID %in% common_cand, TRUE, FALSE),
         control_snps = ifelse(snp_ID %in% control_snps, TRUE, FALSE))


listsnps %>% write_csv2(here("data/DryadRepo/SNPsInformation_WithOutliers.csv"),append=FALSE)

listsnps[1:10,] %>% kable_mydf()
```



# Session information

```{r SessionInfo}
devtools::session_info()
```

  