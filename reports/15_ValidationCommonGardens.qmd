---
title: "Evaluation of genomic offset predictions in common gardens"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
number-sections: true
format: 
  html:
    toc: true
    toc-depth: 4
    code-fold: true
    page-layout: full
embed-resources: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body {
   font-size: 15px;
}
code.r{
  font-size: 11px;
}
pre {
  font-size: 11px
}

table {
  font-size: 10px
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(dev.args = list(png = list(type = "cairo")))
knitr::opts_chunk$set(fig.width = 7,fig.height = 5,cache=F)
options(width = 300)
library(knitr)
library(tidyverse)
library(readxl)
library(xtable)
library(reshape2)
library(kableExtra)
library(magrittr)
library(cowplot)
library(rnaturalearth)
library(raster)
library(RColorBrewer)
library(here)
library(rstan)
library(tidybayes)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
library(bayesplot)
color_scheme_set("green")
library(paletteer)
library(latex2exp)
library(RCurl)
library(ggpubr)
library(png)
library(RCurl)
library(grid)

# my own function for building tables in reports
source(here("scripts/functions/kable_mydf.R"))

# Colors for the coefficients
colors_coeff <- c("#004586FF","#FF7F0FFF","#FFD320FF","#579D1CFF","#7E0021FF","#83CAFFFF","#87D180FF","#FEB5A2FF","#F02720FF")

# Images for the SI
cloudpng <- readPNG(here('reports/cloud.png'))
# sunpng <- readPNG(here('reports/sun.png'))


#################################################
# Full method and site names to use in the plots
#################################################

cg_names <- list(caceres = "Cáceres",
                 asturias = "Asturias",
                 madrid = "Madrid",
                 portugal = "Fundão",
                 bordeaux = "Bordeaux")

methods <- list(LFMM_all = "GO predictions from LFMM and all SNPs",
                LFMM_cand = "GO predictions from LFMM and candidate SNPs",
                LFMM_control = "GO predictions from LFMM and control SNPs",
                RDA_cand = "GO predictions from RDA and candidate SNPs",
                RDA_control = "GO predictions from RDA and control SNPs",
                GDM_cand = "GO predictions from GDM and candidate SNPs",
                GDM_control = "GO predictions from GDM and control SNPs",
                GF_cand = "GO predictions from GF and candidate SNPs",
                GF_control = "GO predictions from GF and control SNPs",
                CTD_bio1 = "CTD for mean annual temperature (bio1, °C)",
                CTD_bio12 = "CTD for annual precipitation (bio12, mm)",
                CTD_bio15 = "CTD for precipitation seasonality (bio15, index)",
                CTD_bio3 = "CTD for isothermality (bio3, index)",
                CTD_bio4 = "CTD for temperature seasonality (bio4, °C)",
                CTD_SHM = "CTD for summer heat moisture index (SHM, °C/mm)")



###################
# Correlation plots
###################

source(here("scripts/functions/corpmat.R")) # to compute the matrix of p-value

# Function to generate a corrplot in pdf
make_corrplot_pdf <- function(df,variables,fig_options){
  
  # correlation matrix
  cor <- cor(df[,variables]) 
  
  # matrix of the p-value of the correlation
  pmat <- corpmat(cor)

  # Generate a correlation plot
  pdf(file=fig_options$path,
      width=fig_options$width,
      height=fig_options$height)
  corrplot::corrplot(cor, 
                     method="color", 
                     col=colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))(200),
                     type="upper", 
                     order="hclust",
                     addCoef.col = "black", # Add coefficient of correlation
                     tl.col="black", 
                     tl.srt=45, #Text label color and rotation
                   
                     # Combine with significance
                     p.mat = pmat, 
                     sig.level = 0.01, 
                     mar=c(0,0,0,0),
                     insig = "blank",
                     
                     # hide correlation coefficient on the principal diagonal
                     diag=FALSE,
                     number.cex=0.6)
  dev.off()
  
}
```



# Introduction

In this report, we evaluate whether genomic offset (GO) predictions from the different GEA methods (LFMM, GF, GDM and RDA) and SNP sets (control, candidate and all SNPs for LFMM) are good predictors of fitness proxies (height and mortality data) from five clonal common gardens located in Spain (Asturias, Madrid, Cáceres), Portugal (Fundão) and France (Pierroton). For that, we predicted the genomic offset of each population when transplanted in the environment of the common garden (so instead of predicting the genomic offset into future climates, we predict it in the new environment of the common garden, i.e. space-for-time approach). The rational is that populations with higher genomic offset in a given common garden are expected to have lower relative fitness in the common garden.

We also calculate the climatic transfer distances (CTD) between the climate-of-origin of the populations and the climate of the common garden (i.e. the absolute value of the difference between the climate of origin of the populations and the climate in the common garden between the tree planting date and the measurement date). We then estimate the association between tree height and mortality and the climatic transfer distances. The climatic transfer distances are calculated for the same set of climatic variables as the one used to calculate the genomic offset (one CTD per climatic variable).


# Data

## Genomic offset predictions

We load the genomic offset predictions estimated from the different GEAs.

```{r LoadGOpredictions}
df <- lapply(c("control","cand"), function(x){

list_snps <- list()

list_snps[[x]]$GDM <- readRDS(file=here("outputs/GDM/go_predictions.rds"))[[x]][["go_cg"]]
list_snps[[x]]$GF <- readRDS(file=here("outputs/GF/go_predictions.rds"))[[x]][["go_cg"]]
list_snps[[x]]$RDA <- readRDS(file=here("outputs/RDA/go_predictions.rds"))[[x]][["go_cg"]]
list_snps[[x]]$LFMM <- readRDS(file=here("outputs/LFMM/go_predictions_snpsets.rds"))[[x]][["go_cg"]]


list_snps <- list_snps[[x]] %>% 
  bind_rows(.id="method_type") %>% 
  mutate(method_input = x)

return(list_snps)
}) %>% bind_rows()


df <- readRDS(file=here("outputs/LFMM/go_predictions_allsnps.rds"))[["go_cg"]] %>% 
   mutate(method_type = "LFMM",
          method_input = "all") %>% 
  bind_rows(df) %>% 
  pivot_longer(cols=c(readRDS(here("data/ClimaticData/CommonGardens/ClimateCG.rds"))[["cg"]]),names_to="cg",values_to="varX") %>% 
  mutate(method = paste0(method_type, "_",method_input))
```

## Climatic transfer distances

We calculate the climatic transfer distances.

```{r CalculateCTD}
# selected climatic variables
clim_var <- readRDS(here("data/ClimaticData/NamesSelectedVariables.rds"))

# climatic data in the common gardens (btw planting and measurement dates)
cg_clim <-readRDS(here("data/ClimaticData/CommonGardens/ClimateCG.rds")) %>% 
  dplyr::select(cg,any_of(clim_var)) 

# Loading point estimate climatic data
adj <- "noADJ"  # not adjusted for elevation
ref_period <- "ref_1901_1950" # reference period 1901-1950
clim_past <- readRDS(here(paste0("data/ClimaticData/MaritimePinePops/ClimatePopulationLocationPointEstimates_ReferencePeriods_",adj,".rds")))[[ref_period]]$ref_means %>%
  dplyr::select(pop,any_of(clim_var))


df <- lapply(cg_clim[["cg"]], function(x){
  
for(var in clim_var){
  
  clim_past[[var]] <- ( clim_past[[var]] - cg_clim %>% filter(cg == x) %>%  pull(var) ) %>% abs()
} 
  
return(clim_past)
}) %>%  
  setNames(cg_clim[["cg"]]) %>% 
  bind_rows(.id="cg") %>% 
  pivot_longer(cols=any_of(clim_var),names_to="method_input",values_to="varX") %>% 
  mutate(method_type="CTD",
         method=paste0("CTD_",method_input)) %>% 
  bind_rows(df)
```

## Correlation CTDs vs GO predictions

We calculate the correlations among GO predictions and climatic transfer distances in the common gardens.

```{r CorrGOPredsCTDs, results='hide'}
lapply(unique(df$cg), function(site_i){
  
df_corr <- df %>% 
  dplyr::filter(cg==site_i) %>% 
  dplyr::select(-starts_with("method_")) %>% 
  pivot_wider(values_from = varX, names_from = method)

fig_options <- list(
  path = here(paste0("figs/ValidationCommonGarden/Corrplot_GOpreds_CTDs_",site_i,".pdf")),
  width=10,
  height=8)

make_corrplot_pdf(df = df_corr,
                  variables = colnames(df_corr)[-c(1:2)],
                  fig_options = fig_options)
  
})
```


## Phenotypic data

We load the survival and mortality data from the five common gardens.

```{r HeightMeasurements}
pheno_data <- readRDS(file=here("data/CommonGardenData/PhenoDataNovember2019_AnnualTraits_UpdatedSept2021_AllSites.rds")) %>% dplyr::rename(pop=prov)

no_nas <- sapply(pheno_data, function(x) length(x)-sum(is.na(x)))

list_pheno <- list()

list_pheno$`Asturias, Spain (37 months)` <- table(pheno_data$site,pheno_data$AST_survmar14)["asturias",]
list_pheno$`Bordeaux, France (85 months)` <- table(pheno_data$site,pheno_data$BDX_surv18)["bordeaux",]
list_pheno$`Cáceres, Spain (8 months)` <- table(pheno_data$site,pheno_data$CAC_survdec11)["caceres",]
list_pheno$`Madrid, Spain (13 months)` <- table(pheno_data$site,pheno_data$MAD_survdec11)["madrid",]
list_pheno$`Fundão, Portugal (27 months)` <- table(pheno_data$site,pheno_data$POR_survmay13)["portugal",]

df_exp_design <- list_pheno %>% 
  bind_rows(.id="cg") %>% 
  setNames(c("Common garden (tree age)",
             "Number of dead trees",
             "Number of trees alive")) %>% 
  mutate("Number of height measurements"=c(no_nas[["AST_htmar14"]],
                                           no_nas[["BDX_htnov18"]],
                                           no_nas[["CAC_htdec11"]],
                                           no_nas[["MAD_htdec11"]],
                                           no_nas[["POR_htmay13"]]))

saveRDS(df_exp_design, file = here("tables/ExpDesign_CG.rds"))

df_exp_design  %>% kable_mydf
```

Height and survival measurements in each common garden:

  - **Asturias** (Spain) in **March 2014** when the trees were 37 month-old (trees were planted in **February 2011**).
  
  - **Bordeaux** (France) in **November 2018** when the trees were 85 month-old (trees were planted in **October 2011**).
  
  - **Cáceres** (Spain) in **December 2011** when the trees were 8 month-old (trees were planted in **April 2011**). Note that for this common garden, we calculate the bioclimatic variables for the entire year 2011 (instead of calculating the variables only for months between April and December). Indeed, the calculation of the annual bioclimatic variables will be wrong if we do not account for some months, e.g. the mean annual temperature will be higher than expected because we do not account for some winter months.  
  
  - **Madrid** (Spain) in **December 2011** when the trees were 13 month-old (trees were planted in **November 2010**).
  
  - **Fundão** (Portugal) in **May 2013** when the trees were 27 month-old (trees were planted in **February 2011**)




# Mortality models

In this section, we want to determine whether **genomic offset (GO)** or **climate transfer distances (CTD)** are associated with the **proportion of dead trees in the populations**, independently in the five common gardens. We build a model that assumes that **the initial sapling height acts as a confounder**. Indeed, trees that were higher at the time of planting have a higher probability of survival. This is particularly true in Madrid and Cáceres (Spain) where the seedlings experienced an extreme drought event the same year they were planted, resulting in very high mortality rates.
Here is the model:
  
\begin{align*} 
a_{p} &\sim \text{Binomial} (N_{p},p_{p}) \\
\text{logit}(p_{p}) &= \beta_{0} +  \beta_{H}H_{p} + \beta_{X}X_{p}\\
\end{align*}


with $a_{p}$ the count of individuals that died in the population $p$, $N_{p}$ the total number of individuals in the population $p$ (=number of individuals that were initially planted in the common garden), $p_p$ is the estimated probability of mortality in the population $p$, $X_{p}$ is the genomic offset or climatic transfer distance for the population $p$ and $H_{p}$ is the BLUPs for height of the population $p$ [population varying intercepts calculated across all common gardens in the model 1 of @archambeau2022combining]. $H_{p}$ is used as a proxy of the initial tree height.

We used the following weakly informative priors:

  
\begin{align*} 
\begin{bmatrix}  \beta_{0,c} \\ \beta_{H} \\ \beta_{X} \end{bmatrix} &\sim \mathcal{N}(0,5)
\end{align*}



## The variables

### Initial tree height (confounder)

We load the population-specific intercepts from the model 1 of @archambeau2022combining.

```{r ExtractHeightInterceptsModel1Archambeauetal2022,message=F,warning=F}
mod_arch2022 <- readRDS(file=here("data/Archambeauetal2022_MOD1.rds"))
pop_heights <- mod_arch2022$fit %>% 
  broom.mixed::tidyMCMC(estimate.method = "mean",conf.int = T) %>% # we take the mean of the prov random intercepts
  filter(str_detect(term, "^(r_prov\\[)")) %>% 
  dplyr::rename(height=estimate,pop=term) %>% 
  mutate(pop=str_sub(pop,8,-12))

pop_heights[1:5,] %>% kable_mydf
```

We export the height intercepts from @archambeau2022combining to the DRYAD repository.

```{r HeightInterceptsInDryadRepo}
pop_heights %>% write_csv(here("data/DryadRepo/HeightIntercepts_Archambeauetal2023.csv"))
```

### Survival data 

The response variable is counts of dead trees. To calculate these counts, we load the survival data in the common gardens, in which `0` corresponds to dead trees and `1` to survivors.

```{r LoadSurvData}
surv_measurements <- c("AST_survmar14","BDX_surv18","CAC_survdec11","MAD_survdec11","POR_survmay13")
survival_data <- pheno_data %>% 
  dplyr::select(site,block,pop,clon,tree,any_of(surv_measurements)) %>% 
  pivot_longer(cols=any_of(surv_measurements), names_to = NULL, values_to = "survival") %>% 
  drop_na(survival) 

survival_data[1:5,] %>% kable_mydf
```


## Run the models

Stan code of the mortality model:

```{r CompileMortalityModel, message=F,warning=F}
stancode = stan_model(here("scripts/StanModels/ValidationCommonGarden_BinomialMortalityModel.stan"))
print(stancode)
```

We run the models for each common garden and each genomic offset predictions/climatic transfer distances, so a total of 5 * 15 = 75 models runs.

```{r RunMortalityModels, eval=F}
coefftab <- lapply(unique(survival_data$site),function(site_i){
  
lapply(unique(df$method), function(method_i){
  
# Subset the data for the site i and method i
sub_data <- survival_data %>% 
  filter(site == site_i) %>% 
  group_by(pop) %>% 
  dplyr::summarise(nb_dead=n()-sum(survival),nb_tot=n()) # transform survival data into mortality data
    
sub_data <- df %>% 
  filter(method == method_i & cg == site_i) %>% 
  inner_join(sub_data, by="pop") %>% 
  inner_join(pop_heights %>% dplyr::select(any_of(c("height", "pop"))), by="pop") %>% 
  arrange(pop)
      
# Data in a list for Stan 
stanlist <- list(N = nrow(sub_data),
                 nb_dead = sub_data$nb_dead,
                 nb_tot=sub_data$nb_tot,
                 H=(sub_data$height-mean(sub_data$height))/sd(sub_data$height),
                 X=(sub_data$varX -mean(sub_data$varX))/sd(sub_data$varX))
    
# Running the model
mod <- sampling(stancode, data = stanlist, iter = 2000, chains = 4, cores = 4, save_warmup = FALSE) 
    
# Save the model and the stanlist
list(mod = mod, stanlist = stanlist) %>% 
  saveRDS(file=here(paste0("outputs/ValidationCommonGarden/MortalityModels/stan_models/",
                                                           site_i,"_",method_i,".rds")))
  
  
# Save coefficients
broom.mixed::tidyMCMC(mod,
                      droppars = NULL, 
                      robust = FALSE, # give mean and standard deviation
                      ess = F, 
                      rhat = F, 
                      conf.int = T,
                      conf.level = 0.95) %>% 
  filter(str_detect(term, c('beta'))) %>% 
  dplyr::rename(mean=estimate,
                std_deviation=std.error,
                conf_low=conf.low,
                conf_high=conf.high) %>% 
  mutate(cg=site_i,
         method=method_i,
         .before=1)
    
  }) %>% bind_rows()
  
}) %>% bind_rows()

coefftab %>% saveRDS(file=here("outputs/ValidationCommonGarden/MortalityModels/coefftab.rds"))
```


## Model coefficients

We load the model coefficients: 

```{r LookTablePosteriorsMortalityModels, eval=T}
coefftab <- readRDS(file=here("outputs/ValidationCommonGarden/MortalityModels/coefftab.rds"))
coefftab[1:5,] %>% kable_mydf()
```

Below, we plot the mean and 95% credible intervals of:

  - the **$\beta_X$ coefficients**, which stand for the association between the counts of dead trees and the genomic offset predictions (i.e. capturing the potential maladaptation of the populations when transplanted in the new environment of the common gardens) or the climatic transfer distances.
  
  - the $\beta_H$ coefficients, which stand for the association between the counts of dead trees and the BLUPs for height in the five common gardens, used as a proxy of the initial seedling height (a confounder in the model).
  
Graph titles include the time in months corresponding to the age at which height and survival were recorded. Coefficients in the green area have the expected sign, reflecting higher mortality rates in populations with higher GO predictions.

```{r CoeffPlotsMortalityModels, fig.height=9, fig.width=12, eval=T}
coeff_match <- list(beta_H="Regression coefficients $\\beta_H$",
                    beta_X="Regression coefficients $\\beta_X$")
  
p <- lapply(c("beta_X","beta_H"), function(coeff){
  
p <- coefftab %>% 
  filter(term==coeff) %>% 
  left_join(distinct(df[,c("method_type","method_input","cg","method")]), by=c("method","cg")) %>% 
  mutate(cg=case_when(cg=="asturias"~"Asturias, Spain (37 months)",
                      cg=="bordeaux"~"Bordeaux, France (85 months)",
                      cg=="caceres"~"Cáceres, Spain (8 months)",
                      cg=="madrid"~"Madrid, Spain (13 months)",
                      cg=="portugal"~"Fundão, Portugal (27 months)"),
         method_input=case_when(method_input=="all" ~ "All SNPs",
                                method_input=="bio1" ~ "Mean annual temperature (°C)",
                                method_input=="bio12" ~ "Annual precipitation (mm)",
                                method_input=="bio15" ~ "Precipitation seasonality (index)",
                                method_input=="bio3" ~ "Isothermality (index)",
                                method_input=="bio4" ~ "Temperature seasonality (°C)",
                                method_input=="cand" ~ "Candidate SNPs",
                                method_input=="control" ~ "Control SNPs",
                                method_input=="SHM" ~ "Summer heat moisture index (°C/mm)")) %>% 
  mutate(method_input=factor(method_input, levels=c("All SNPs",
                                                    "Candidate SNPs",
                                                    "Control SNPs",
                                                    "Mean annual temperature (°C)",
                                                    "Annual precipitation (mm)",
                                                    "Precipitation seasonality (index)",
                                                    "Isothermality (index)",
                                                    "Temperature seasonality (°C)",
                                                    "Summer heat moisture index (°C/mm)")),
         method_type=factor(method_type, levels=c("GDM","GF","LFMM","RDA","CTD")),
         cg=factor(cg, levels=c("Asturias, Spain (37 months)",
                                "Madrid, Spain (13 months)",
                                "Bordeaux, France (85 months)",
                                "Cáceres, Spain (8 months)",
                                "Fundão, Portugal (27 months)")))

# Plots with CTD and SNP sets
# ===========================
p_allvar <- p %>% ggplot(aes(x = method_type,
                             y = mean,
                             ymin = conf_low, 
                             ymax = conf_high,
                             color=method_input,
                             shape=method_input)) +
  {if(coeff=="beta_X")  geom_rect(inherit.aes=FALSE, aes(xmin=-Inf, xmax=Inf, ymin=0, ymax=Inf), color="transparent", fill="green", alpha=0.01)} + 
  geom_hline(yintercept = 0,color="gray") +
  geom_pointinterval(position = position_dodge(width = 0.6),
                     point_size=3.5, size=3) +
  facet_wrap(~cg, ncol=2) + 
  ylab(TeX(coeff_match[[coeff]])) + xlab("") +
  scale_color_manual(values=colors_coeff)+
  scale_shape_manual(values = c(rep(17,3),rep(16,6))) +
  theme_bw() +
  labs(color="",shape="") +
  theme(axis.text.x =  element_text(size=13),
        axis.text.y = element_text(size=13),
        axis.title.y = element_text(size=16),
        axis.title.x = element_text(size=1),
        legend.title=element_text(size=13), 
        strip.text.x = element_text(size = 16),
        strip.background = element_blank(),
        legend.position = c(0.77,0.15),
        legend.text=element_text(size=12),
        panel.grid.minor.x=element_blank(),
        panel.grid.major.x=element_blank()) +
  guides(color=guide_legend(ncol=1),
         shape = guide_legend(override.aes = list(size =2 )))

# save in pdf and png
ggsave(p_allvar,
       file=here(paste0("figs/ValidationCommonGarden/MortalityModels/",coeff,"_SNPsandCTD.pdf")),
       device="pdf",
       height=9,
       width=12)

ggsave(p_allvar,
       file=here(paste0("figs/ValidationCommonGarden/MortalityModels/",coeff,"_SNPsandCTD.png")),
       height=9,
       width=12)


# Plots with SNPs only
# ====================
p_SNPs <- p %>% 
  filter(!method_type == "CTD") %>% 
  ggplot(aes(x = method_type,
             y = mean,
             ymin = conf_low, 
             ymax = conf_high,
             color=method_input,
             shape=method_input)) +
  {if(coeff=="beta_X")  geom_rect(inherit.aes=FALSE, aes(xmin=-Inf, xmax=Inf, ymin=0, ymax=Inf), color="transparent", fill="green", alpha=0.01)} + 
  geom_hline(yintercept = 0,color="gray") +
  geom_pointinterval(position = position_dodge(width = 0.45),
                     point_size=3.5, size=3) + # 
  facet_wrap(~cg, ncol=2) +
  ylab(TeX(coeff_match[[coeff]])) + xlab("") +
  scale_color_manual(values=colors_coeff) +
  scale_shape_manual(values = c(rep(17,3),rep(16,6))) +
  theme_bw() +
  labs(color="",shape="") +
  theme(axis.text.x =  element_text(size=13),
        axis.text.y = element_text(size=13),
        axis.title.y = element_text(size=16),
        axis.title.x = element_text(size=1),
        legend.title=element_text(size=13), 
        strip.text.x = element_text(size = 16),
        strip.background = element_blank(),
        legend.position = c(0.77,0.15),
        legend.text=element_text(size=18),
        panel.grid.minor.x=element_blank(),
        panel.grid.major.x=element_blank()) +
  guides(color=guide_legend(ncol=1),
         shape = guide_legend(override.aes = list(size =2 )))

# save in pdf and png
ggsave(p_SNPs,
       file=here(paste0("figs/ValidationCommonGarden/MortalityModels/",coeff,"_SNPsets.pdf")),
       device="pdf",
       height=7,
       width=8)

ggsave(p_SNPs,
       file=here(paste0("figs/ValidationCommonGarden/MortalityModels/",coeff,"_SNPsets.png")),
       height=7,
       width=8)

# Figure in the main manuscript
###############################

# We want to add some images to represent the climatic differences among common gardens

if(coeff=="beta_X"){
annotation_custom2 <- function (grob, xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, data){ layer(data = data, stat = StatIdentity, position = PositionIdentity, 
        geom = ggplot2:::GeomCustomAnn,
        inherit.aes = TRUE, params = list(grob = grob, 
                                          xmin = xmin, xmax = xmax, 
                                          ymin = ymin, ymax = ymax))}
df_coord_png <- p %>% 
  dplyr::select(cg) %>%
  distinct %>% 
  dplyr::mutate(x_min = case_when(cg == "Asturias, Spain (37 months)" ~ 4.02,
                                  cg == "Bordeaux, France (85 months)" ~ 4.02,
                                  cg == "Cáceres, Spain (8 months)" ~ 4.25,
                                  cg == "Madrid, Spain (13 months)" ~ 4.23,
                                  cg == "Fundão, Portugal (27 months)" ~ 4.09),
                y_max = case_when(cg == "Asturias, Spain (37 months)" ~ -0.28,
                                  cg == "Bordeaux, France (85 months)" ~ -0.28,
                                  cg == "Cáceres, Spain (8 months)" ~ -0.45,
                                  cg == "Madrid, Spain (13 months)" ~ -0.43,
                                  cg == "Fundão, Portugal (27 months)" ~ -0.38))

list_pngs <- lapply(unique(p$cg), function(cg_i){
  
sub <-  p %>% 
  filter(cg==cg_i) %>%
  filter(!method_type == "CTD") %>% 
  slice(1)

png_cg = annotation_custom2(rasterGrob(cloudpng,interpolate=TRUE), 
                            ymin = -0.56,
                            ymax= df_coord_png[df_coord_png$cg==cg_i,"y_max"][[1]],
                            xmin =df_coord_png[df_coord_png$cg==cg_i,"x_min"][[1]],
                            xmax =4.55, 
                            data=sub)
})

p_SNPs <- p_SNPs + list_pngs[[1]]+ list_pngs[[2]]+ list_pngs[[3]]+ list_pngs[[4]]+ list_pngs[[5]]

# save in pdf and png
ggsave(p_SNPs,
       file=here(paste0("figs/ValidationCommonGarden/MortalityModels/",coeff,"_SNPsets_WithCloudImage.pdf")),
       device="pdf",
       height=7,
       width=8)

}

return(p_allvar)

})

p
```

<span style="color: orange;">Interpretation</span>

As expected, the association between mortality rates and the initial tree height was particularly strong in Madrid and Cáceres (Spain) where the seedlings experienced an extreme drought event the same year they were planted, resulting in very high mortality rates. More surprisingly, this association was also osberved in Fundão, Portugal. However, the initial tree height was not associated with mortality rates in Bordeaux (France) and Asturias (Spain), which benefit from the favorable climates of the Atlantic region and in which the mortality rates were very low.

In Fundão, Cáceres and Madrid, for most genomic offset predictions, populations experiencing higher mortality rates also showed higher genomic offset. The most consistent associations across the three common gardens were obtained with:

  - <span style="color: orange;">**Gradient Forest (GF)** with both candidate and control SNPs.</span>
  
  - <span style="color: orange;">**Redundancy analysis (RDA)** with both candidate and control SNPs.</span>
  
  - <span style="color: orange;">**Latent factor mixed model (LFMM)** with all SNPs or control SNPs.</span>


Interestingly, climatic transfer distances generally explain mortality probability less well than genomic offset predictions, and none of them show a consistent association with the number of dead trees across the three common gardens. Note that it is almost the case for the climatic transfer distance calculated based on the temperature seasonality, which shows a positive association with the counts of dead trees in Madrid and Fundão, and almost in Cáceres.

In Asturias, no association was detected between genomic offset predictions and mortality rates, which may be due to the favorable climatic conditions of this common garden and the associated low mortality rates (only 206 dead trees). Therefore, in this common garden, mortality events are likely to be mostly random events due to other factors than climate. However, we can note that an association was detected between mortality rates and isothermality: populations from areas with high isothermality tend to die more in the common garden of Asturias, Spain.

In Bordeaux, there were even less dead trees than in Asturias (119 dead trees). However, the two nonparametric approach used to predict the genomic offset (GDM and GF) detected a positive association between mortality rates and the genomic offset predictions obtained with both the candidate and the control SNPs. A positive association was also detected with the genomic offset predictions obtained with candidate SNPs with the LFMM approach. On the other hand, none of the genomic offset predictions from the RDA approach were associated with the mortality rates. Interestingly, the only association with a climatic transfer distance was with the temperature seasonality (`bio4`), which was the most important variable to explain the turnover in allele frequency in the GF and GDM approaches.


## Predictions of tree mortality probability

### Plots

Let's visualize the uncertainty around the estimation of the probability of tree mortality $p$.

```{r MortalityPredictions, message=F,warning=F, fig.height=6, fig.width=6, eval=F}
####################################################################################################
# Visualizing the relationships between GO predictions or CTDs and mortality probability predictions
####################################################################################################

lapply(names(cg_names), function(site_i){

list(CTDs=names(methods) %>% str_subset("^CTD"),
     go_methods=names(methods) %>% str_subset("^CTD", negate=T)) %>% 
    
    lapply(function(method_group_i){
      
myplots <- lapply(method_group_i, function(method_i){

# We load the stanlist
stanlist <- readRDS(file = here(paste0("outputs/ValidationCommonGarden/MortalityModels/stan_models/",
                                       site_i,"_",method_i,".rds")))$stanlist

# We load the model
mod <- readRDS(file = here(paste0("outputs/ValidationCommonGarden/MortalityModels/stan_models/",
                                  site_i,"_",method_i,".rds")))$mod

# We extract the posterior distributions of all parameters
post <- as.data.frame(mod)

# Vector of predictor values (based on the min and max of the GO predictions)
x_vec <- seq(min(stanlist$X),max(stanlist$X),0.05)

# Function to predict the mortality probability p with the initial tree height fixed to the mean
f_p <- function(x) 1 / (exp(-(post$`beta_0` + post$`beta_H` * mean(stanlist$H) + post$`beta_X` * x)) + 1)

p_pred <- 
  sapply(x_vec, f_p) %>% 
  tibble::as_tibble() %>%
  rename_all(function(x) x_vec) %>%
  mutate(Iter = row_number()) %>%
  gather(x, p, -Iter) %>%
  group_by(x) %>%
  mutate(hpdi_l = HDInterval::hdi(p, credMass = 0.90)[1],
         hpdi_h = HDInterval::hdi(p, credMass = 0.90)[2],
         p_mean = mean(p)) %>%
  ungroup() %>%
  mutate(x = as.numeric(x))

# Keep mean and 90% HDPI of p (one value for each iteration)
p_mean_df <- p_pred %>%
  dplyr::select(x,hpdi_l,hpdi_h,p_mean) %>% 
  dplyr::distinct()


# Plots
#=======

# Plot options 
y_limits <- c(0,1)
if(grepl("CTD",method_group_i[[1]]) == T){x_axis <- "Mean-centered CTD"} else {
  x_axis <- "Mean-centered GO predictions"}
y_axis <- "Probability of tree mortality"

p <- ggplot() +
  ylim(y_limits) +
  labs(y=y_axis, x=x_axis) +
  theme_bw()

# First 100 posterior draws of the mortality probability p
p1 <- p +
  geom_point(data = p_pred %>% filter(Iter < 101),
             aes(x, p), alpha = .2, color = 'dodgerblue')
  
# Mean (line) and 90% HPDI (shaded region) of the mortality probability p
p2 <- p +
  geom_ribbon(data = p_mean_df,
              aes(x = x, ymin = hpdi_l, ymax = hpdi_h),
              alpha = .2,
              fill='dodgerblue') +
  geom_line(data = p_mean_df,
              aes(x=x, y=p_mean), col="dodgerblue4")

p1_p2 <- ggarrange(p1, p2 + labs(y=""), nrow = 1)

# Title
title <- ggdraw() + 
  draw_label(paste0(cg_names[[site_i]]," - ",methods[[method_i]]),
             fontface = 'bold',
             x = 0, hjust = 0) +   
  theme(plot.margin = margin(0, 0, 0, 7))

# merge title and plots
p1_p2 <- plot_grid(title, p1_p2, ncol = 1, rel_heights = c(0.1, 1))

p2 <- p2 + labs(subtitle = methods[[method_i]])

ggsave(p1_p2,
       file=here(paste0("figs/ValidationCommonGarden/MortalityModels/MortalityProbabilityPredictions_UncertaintyIntervals/",
                        method_i,"_",site_i,".pdf")),
       device="pdf",
       height=6,
       width=11)


return(p2)

})

if(grepl("CTD",method_group_i[[1]]) == T){
  
  group_name <- "CTDs"
  
  p <- plot_grid(myplots[[1]] + labs(x=""),
                 myplots[[2]] + labs(y="",x=""),
                 myplots[[3]] + labs(x=""),
                 myplots[[4]] + labs(y="",x=""),
                 myplots[[5]],
                 myplots[[6]] + labs(y=""),
                 ncol=2)
  
  fig_width <- 10
  
} else {
  
  group_name <- "GOpred"
  
  p <- plot_grid(myplots[[1]] + labs(x=""),
                 myplots[[2]] + labs(y="",x=""),
                 myplots[[3]] + labs(y="",x=""),
                 myplots[[4]] + labs(x=""),
                 myplots[[5]] + labs(y="",x=""),
                 myplots[[6]] + labs(y="",x=""),
                 myplots[[7]],
                 myplots[[8]] + labs(y=""),
                 myplots[[9]] + labs(y=""),
                 ncol=3)
  
    fig_width <- 12
    
    }

ggsave(p,
       file=here(paste0("figs/ValidationCommonGarden/MortalityModels/MortalityProbabilityPredictions_",group_name,"_",site_i,".pdf")),
       device="pdf",
       height=12,
       width=fig_width)

})
  
})
```

### Table

In the table below:

  - mean and 90% credible intervals (highest posterior density intervals) of $p$ for $x=\{-1, 0, 1\}$.
  
  - percent change in $p$ associated with a one-unit increase in $x$ (which corresponds to a one-standard deviation increase).

```{r MortalityPredictionsTable, message=F,warning=F, fig.height=6, fig.width=6, eval=F}
p_pred <- lapply(names(cg_names), function(site_i){
      
lapply(names(methods), function(method_i){

# We load the stanlist
stanlist <- readRDS(file = here(paste0("outputs/ValidationCommonGarden/MortalityModels/stan_models/",
                                       site_i,"_",method_i,".rds")))$stanlist

# We load the model
mod <- readRDS(file = here(paste0("outputs/ValidationCommonGarden/MortalityModels/stan_models/",
                                  site_i,"_",method_i,".rds")))$mod

# We extract the posterior distributions of all parameters
post <- as.data.frame(mod)

# Vector of predictor values (based on the min and max of the GO predictions)
x_vec <- c(-1,0,1)

# Function to predict the mortality probability p with the initial tree height fixed to the mean
f_p <- function(x) 1 / (exp(-(post$`beta_0` + post$`beta_H` * mean(stanlist$H) + post$`beta_X` * x)) + 1)

p_pred <- 
  sapply(x_vec, f_p) %>% 
  tibble::as_tibble() %>%
  rename_all(function(x) x_vec) %>%
  mutate(Iter = row_number()) %>%
  gather(x, p, -Iter) %>%
  group_by(x) %>%
  mutate(hpdi_l = HDInterval::hdi(p, credMass = 0.90)[1], # Highest posterior density intervals
         hpdi_h = HDInterval::hdi(p, credMass = 0.90)[2]
         # pi_l = rethinking::PI(p, prob = 0.90)[1], # Highest posterior percentile intervals
         # pi_h = rethinking::PI(p, prob = 0.90)[2]
         ) %>%
  mutate(p_mean = mean(p)) %>%
  ungroup() %>%
  mutate(x = as.numeric(x)) %>% 
  dplyr::select(x,p_mean,hpdi_l,hpdi_h) %>% 
  distinct() %>% 
  round(3)

delta_p_pos <- (p_pred$p_mean[p_pred$x==1] * 100 / p_pred$p_mean[p_pred$x==0])-100
delta_p_neg <- (p_pred$p_mean[p_pred$x==-1] * 100 / p_pred$p_mean[p_pred$x==0])-100

tibble(Site = cg_names[[site_i]],
       "Method" = methods[[method_i]],
       "p(x=-1)"=paste0(p_pred$p_mean[p_pred$x==-1], " [",
                       p_pred$hpdi_l[p_pred$x==-1],";",
                       p_pred$hpdi_h[p_pred$x==-1],"]"),
       "p(x=0)"=paste0(p_pred$p_mean[p_pred$x==0], " [",
                       p_pred$hpdi_l[p_pred$x==0],";",
                       p_pred$hpdi_h[p_pred$x==0],"]"),
       "p(x=1)"=paste0(p_pred$p_mean[p_pred$x==1], " [",
                       p_pred$hpdi_l[p_pred$x==1],";",
                       p_pred$hpdi_h[p_pred$x==1],"]"),
       "+Δp"=paste0(round(delta_p_pos,3),"%"),
       "-Δp"=paste0(round(delta_p_neg,3),"%"))

}) %>% bind_rows()

}) %>% bind_rows()


p_pred %>% saveRDS(file = here("tables/MortalityPredCGs.rds"))
```

```{r ShowMortalityPredictionsTable}
readRDS(file = here("tables/MortalityPredCGs.rds"))  %>% kable_mydf()
```


## Experimental design

We export in a table with the number and proportion of dead trees for each population in each common garden.

```{r ExpDesignMortalityModels, eval=T}
ExpDesignTab <- lapply(unique(survival_data$site),function(site_i){
  
survival_data %>% 
    filter(site==site_i) %>% 
    dplyr::select(pop,survival) %>% 
    drop_na() %>% 
    group_by(pop) %>% 
    dplyr::summarise(nb_dead=n()-sum(survival),nb_tot=n()) %>% 
    mutate(prop_dead=nb_dead*100/nb_tot)
  
}) %>% 
  setNames(unique(survival_data$site)) %>% 
  bind_rows(.id="cg") %>% 
  pivot_wider(names_from=cg,values_from = c(nb_dead, nb_tot,prop_dead),names_sep="_") %>% 
  dplyr::select(pop,contains("asturias"),contains("bordeaux"),contains("caceres"),contains("madrid"),contains("portugal"))

# To generate a latex table
# =========================
# print(xtable(ExpDesignTab, type = "latex",digits=2), 
#       file = paste0(here("tables/ExpDesignMortalityModelsPerPopCG.tex")), 
#       include.rownames=FALSE)

# Export the table for the Supplemetary Information
# =================================================
ExpDesignTab %>% 
  dplyr::select(-contains("prop_dead")) %>% 
  saveRDS(here("tables/ExpDesignMortalityModelsPerPopCG.rds"))


# Show table
# ==========
ExpDesignTab %>% kable_mydf()

# Information used in the manuscript
ExpDesignTab[,-1] %>% 
  dplyr::summarise_all(mean) %>% 
  kable_mydf
```




# Height models

In this section, we estimate the association between **genomic offset (GO) predictions** or **climate transfer distances (CTD)** and **tree height**, independently in the five common gardens. We compare four different mathematical models.

We first subset height measurements from the dataset (below the first five rows of the dataset are shown).

```{r LoadHeigthData}
height_measurements <- c("AST_htmar14","BDX_htnov18","CAC_htdec11","MAD_htdec11","POR_htmay13")

height_data <- pheno_data %>% 
  dplyr::rename(cg = site) %>% 
  dplyr::select(cg,block,pop,clon,tree,any_of(height_measurements)) %>% 
  pivot_longer(cols=any_of(height_measurements), names_to=NULL,values_to="height",values_drop_na = TRUE)

height_data[1:5,] %>% kable_mydf
```


We write a function to plot the model coefficients :

```{r FunctionPlotCoefficients, eval=T}
coeff_y_axis <- list(beta_X1="Regression coefficients $\\beta_{X_1}$",
                     beta_X2="Regression coefficients $\\beta_{X_2}$",
                     beta_H="Regression coefficients $\\beta_H$",
                     R_squared="Proportion of variance explained ($R^2$)",
                     classic_R2="Classic $R^2$",
                     bayes_R2_res="Residual-based Bayes $R^2$",
                     bayes_R2_mod="Model-based Bayes $R^2$")

generate_interval_plots <- function(model_i){

coefftab <- readRDS(file=here(paste0("outputs/ValidationCommonGarden/HeightModels/coefftab_",model_i,".rds")))

params <-  coefftab$term %>% unique() %>% str_subset("^beta|squared|R2")

p <- lapply(params, function(coeff){

p <- coefftab %>% 
  filter(term==coeff) %>% 
  left_join(distinct(df[,c("method_type","method_input","cg","method")]), by=c("method","cg")) %>% 
  mutate(cg=case_when(cg=="asturias"~"Asturias, Spain (37 months)",
                      cg=="bordeaux"~"Bordeaux, France (85 months)",
                      cg=="caceres"~"Cáceres, Spain (8 months)",
                      cg=="madrid"~"Madrid, Spain (13 months)",
                      cg=="portugal"~"Fundão, Portugal (27 months)"),
         method_input=case_when(method_input=="all" ~ "All SNPs",
                                method_input=="bio1" ~ "Mean annual temperature (°C)",
                                method_input=="bio12" ~ "Annual precipitation (mm)",
                                method_input=="bio15" ~ "Precipitation seasonality (index)",
                                method_input=="bio3" ~ "Isothermality (index)",
                                method_input=="bio4" ~ "Temperature seasonality (°C)",
                                method_input=="cand" ~ "Candidate SNPs",
                                method_input=="control" ~ "Control SNPs",
                                method_input=="SHM" ~ "Summer heat moisture index (°C/mm)")) %>% 
  mutate(method_input=factor(method_input, levels=c("All SNPs",
                                                    "Candidate SNPs",
                                                    "Control SNPs",
                                                    "Mean annual temperature (°C)",
                                                    "Annual precipitation (mm)",
                                                    "Precipitation seasonality (index)",
                                                    "Isothermality (index)",
                                                    "Temperature seasonality (°C)",
                                                    "Summer heat moisture index (°C/mm)")),
         method_type=factor(method_type, levels=c("GDM","GF","LFMM","RDA","CTD")))
  


if(coeff %in% c("classic_R2", "bayes_R2_mod", "bayes_R2_res") & model_i=="M2"){
  nullR2 <- readRDS(file = here("outputs/ValidationCommonGarden/HeightModels/coefftab_M2_WithoutPredictor.rds")) %>% 
    filter(term==coeff) %>% 
    mutate(cg=case_when(cg=="asturias"~"Asturias, Spain (37 months)",
                      cg=="bordeaux"~"Bordeaux, France (85 months)",
                      cg=="caceres"~"Cáceres, Spain (8 months)",
                      cg=="madrid"~"Madrid, Spain (13 months)",
                      cg=="portugal"~"Fundão, Portugal (27 months)"))
}


# Plots with CTD and SNP sets
# ===========================
p_allvar <- p %>% 
   ggplot(aes(x = method_type,
              y = mean,
              ymin = conf_low, 
              ymax = conf_high,
              color=method_input,
              shape=method_input)) +
  #{if(coeff=="beta_X1")  geom_rect(inherit.aes=FALSE, aes(xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=0), color="transparent", fill="green", alpha=0.01)} + 
  {if(coeff %in% c("classic_R2", "bayes_R2_mod", "bayes_R2_res") & model_i=="M2")  geom_rect(data=nullR2,inherit.aes=FALSE, aes(xmin=-Inf, xmax=Inf, ymin=conf_low, ymax=conf_high), color="transparent", fill="brown", alpha=0.2)} + 
  {if(coeff %in% c("classic_R2", "bayes_R2_mod", "bayes_R2_res") & model_i=="M2")  geom_hline(data=nullR2,aes(yintercept=mean), color="brown")} + 
  geom_hline(yintercept = 0,color="gray") +
  geom_pointinterval(position = position_dodge(width = .4),point_size=3.5,size=3) + # 
  facet_wrap(~cg, ncol=2) + #, scales="free_x", space = "free" 
  ylab(TeX(coeff_y_axis[[coeff]])) + xlab("") +
  scale_color_manual(values=colors_coeff) +
  scale_shape_manual(values = c(rep(16,6),rep(17,3))) +
  theme_bw() +
  labs(color="",shape="") +
  theme(axis.text.x =  element_text(size=13),
        axis.text.y = element_text(size=13),
        axis.title.y = element_text(size=16),
        axis.title.x = element_text(size=1),
        legend.title=element_text(size=13), 
        strip.text.x = element_text(size = 16),
        strip.background = element_blank(),
        legend.position = c(0.77,0.15),
        legend.text=element_text(size=12),
        panel.grid.minor.x=element_blank(),
        panel.grid.major.x=element_blank()) +
  guides(color=guide_legend(ncol=1),
         shape = guide_legend(override.aes = list(size =2 )))

p_allvar 

# save in pdf
ggsave(p_allvar,
       file=here(paste0("figs/ValidationCommonGarden/HeightModels/",coeff,"_",model_i,"_SNPsandCTD.pdf")),
       device="pdf",
       height=9,
       width=12)

# save in png
# ggsave(p_allvar,
#        file=here(paste0("figs/ValidationCommonGarden/HeightModels/",coeff,"_",model_i,"_SNPsandCTD.png")),
#        height=9,
#        width=12)


# Plots only SNP sets
# ===================
p_SNPs <- p %>% 
  filter(!method_type == "CTD") %>% 
  ggplot(aes(x = method_type,
             y = mean,
             ymin = conf_low, 
             ymax = conf_high,
             color=method_input,
             shape=method_input)) +
  #{if(coeff=="beta_X1")  geom_rect(inherit.aes=FALSE, aes(xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=0), color="transparent", fill="green", alpha=0.01)} + 
  {if(coeff %in% c("classic_R2", "bayes_R2_mod", "bayes_R2_res") & model_i=="M2")  geom_rect(data=nullR2,inherit.aes=FALSE, aes(xmin=-Inf, xmax=Inf, ymin=conf_low, ymax=conf_high), color="transparent", fill="brown", alpha=0.2)} + 
  {if(coeff %in% c("classic_R2", "bayes_R2_mod", "bayes_R2_res") & model_i=="M2")  geom_hline(data=nullR2,aes(yintercept=mean), color="brown")} + 
  geom_hline(yintercept = 0,color="gray") +
  geom_pointinterval(position = position_dodge(width = .4),point_size=3.5,size=3) + # 
  facet_wrap(~cg, ncol=2) + #, scales="free_x", space = "free" 
  ylab(TeX(coeff_y_axis[[coeff]])) + xlab("") +
  scale_color_manual(values=colors_coeff) +
  scale_shape_manual(values = c(rep(16,6),rep(17,3))) +
  theme_bw() +
  labs(color="",shape="") +
  theme(axis.text.x =  element_text(size=13),
        axis.text.y = element_text(size=13),
        axis.title.y = element_text(size=16),
        axis.title.x = element_text(size=1),
        legend.title=element_text(size=13), 
        strip.text.x = element_text(size = 16),
        strip.background = element_blank(),
        legend.position = c(0.77,0.15),
        legend.text=element_text(size=18),
        panel.grid.minor.x=element_blank(),
        panel.grid.major.x=element_blank()) +
  guides(color=guide_legend(ncol=1),
         shape = guide_legend(override.aes = list(size =2 )))


# save in pdf
ggsave(p_SNPs,
       file=here(paste0("figs/ValidationCommonGarden/HeightModels/",coeff,"_",model_i,"_SNPsets.pdf")),
       device="pdf",
       height=7,
       width=8)

# save in png
# ggsave(p_SNPs,
#        file=here(paste0("figs/ValidationCommonGarden/HeightModels/",coeff,"_",model_i,"_SNPsets.png")),
#        height=7,
#        width=8)

return(p_allvar)

})

return(p)
}
```

We write a function to plot the quadratic relationships between tree height and the GO predictions / CTD.

```{r MakePolyPlots, fig.width=12, fig.height=7, eval=T}
generate_poly_plots <- function(model_i){

coefftab <- readRDS(file=here(paste0("outputs/ValidationCommonGarden/HeightModels/coefftab_",model_i,".rds")))

x <- seq(-2,2,0.01)
poly_function <- function(a,b,x) {a * x^2 + b * x}

ggtab <- coefftab %>% 
  filter(term %in% c("beta_X1","beta_X2")) %>% 
  left_join(distinct(df[,c("method_type","method_input","cg","method")]), by=c("method","cg")) %>% 
  mutate(cg_legend =case_when(cg=="asturias"~"Asturias (37 months)",
                      cg=="bordeaux"~"Bordeaux (85 months)",
                      cg=="caceres"~"Cáceres (8 months)",
                      cg=="madrid"~"Madrid (13 months)",
                      cg=="portugal"~"Fundão (27 months)"),
         method_input=case_when(method_input=="all" ~ "All SNPs",
                                method_input=="bio1" ~ "Mean annual temperature (°C)",
                                method_input=="bio12" ~ "Annual precipitation (mm)",
                                method_input=="bio15" ~ "Precipitation seasonality (index)",
                                method_input=="bio3" ~ "Isothermality (index)",
                                method_input=="bio4" ~ "Temperature seasonality (°C)",
                                method_input=="cand" ~ "Candidate SNPs",
                                method_input=="control" ~ "Control SNPs",
                                method_input=="SHM" ~ "Summer heat moisture index (°C/mm)")) %>%
  mutate(method_input=factor(method_input, levels=c("All SNPs",
                                                    "Candidate SNPs",
                                                    "Control SNPs",
                                                    "Mean annual temperature (°C)",
                                                    "Annual precipitation (mm)",
                                                    "Precipitation seasonality (index)",
                                                    "Isothermality (index)",
                                                    "Temperature seasonality (°C)",
                                                    "Summer heat moisture index (°C/mm)"))) %>% 
  pivot_wider(names_from="term", values_from = c("mean","std_deviation","conf_low","conf_high"))

ggtab <- lapply(unique(ggtab$cg), function(cg_i){
lapply(unique(ggtab$method), function(method_i){
  
  subggtab <- ggtab %>% filter(method == method_i & cg == cg_i)
  
  poly_function(a=subggtab$mean_beta_X2, b=subggtab$mean_beta_X1,x=x)
  }) %>% 
    setNames(unique(ggtab$method)) %>% 
    bind_rows(.id="method") %>% 
    mutate(x_axis = x)
}) %>% 
  setNames(unique(ggtab$cg)) %>% 
  bind_rows(.id="cg") %>% 
  pivot_longer(cols=any_of(unique(ggtab$method)),names_to="method",values_to="predictions") %>% 
  left_join(ggtab[,c("method","method_type", "method_input")] %>% distinct(), by="method")
  

# Below, you can use unique(ggtab$cg) or unique(ggtab$cg_legend)
ggplots <- lapply(unique(ggtab$cg), function(cg_i){
  
p_go <- ggtab %>%
  filter(cg %in% cg_i & method_type %in% unique(ggtab$method_type)[!unique(ggtab$method_type) == "CTD"]) %>% 
  mutate(method_input = factor(method_input, levels=c("Candidate SNPs", "Control SNPs", "All SNPs"))) %>% 
  ggplot(aes(x=x_axis,y=predictions,col=method_type,linetype=method_input)) +
  geom_hline(yintercept=0,color="black") +
  geom_line(linewidth=1) +
  ylab('Standardized tree height') + 
  #ylab(paste0('Standardized tree height - ',cg_i)) + 
  xlab(TeX("Standardized predictor")) +
  ylim(c(min(ggtab$predictions),max(ggtab$predictions))) +
  scale_color_manual(values=c("#FCA315FF", "#00FF00FF","#172869FF", "#FF00FFFF"), name = "GEA method") +
  scale_linetype_manual(values=c("solid","dashed","dotted"), name = "SNP set") +
  theme_bw() + 
  theme(axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=13),
        axis.title = element_text(size=16),
        legend.box="horizontal",
        legend.key.width = unit(1,"cm"),
        legend.background = element_blank(),
        legend.box.background = element_blank(),
        legend.key = element_blank(),
        legend.position = c(0.73,0.89)) + 
  guides(color=guide_legend(ncol=1))

#if(!cg_i==unique(ggtab$cg)[1])  p_go <- p_go + theme(legend.position = "none")
#if(!cg_i==unique(ggtab$cg)[length(unique(ggtab$cg))])  p_go <- p_go + xlab("")

p_ctd <- ggtab %>% 
  filter(cg %in% cg_i & method_type %in% "CTD") %>%
  ggplot(aes(x=x_axis,y=predictions,col=method_input)) +
  geom_hline(yintercept=0,color="black") +
  #geom_segment(aes(x = min(x_axis), y = 0, xend = max(x_axis), yend = 0), color="black") +
  geom_line(linewidth=1.2) +
  ylab('') + 
  xlab(TeX("Standardized predictor")) +
  ylim(c(min(ggtab$predictions),max(ggtab$predictions))) +
  scale_color_manual(values=colors_coeff[4:length((colors_coeff))], 
                     name = "Climatic transfer distance") +
    theme_bw() + 
    theme(axis.text.x = element_text(size=13),
          axis.text.y = element_text(size=13),
          axis.title = element_text(size=16),
          legend.box="horizontal",
          legend.background = element_blank(),
          legend.box.background = element_blank(),
          legend.key = element_blank(),
          legend.position = c(0.55,0.91)) + 
  guides(color=guide_legend(ncol=2))

#if(!cg_i==unique(ggtab$cg)[1])  p_ctd <- p_ctd + theme(legend.position = "none")
#if(!cg_i==unique(ggtab$cg)[length(unique(ggtab$cg))])  p_ctd <- p_ctd + xlab("")

pp <- plot_grid(p_go,p_ctd)

ggsave(filename = here(paste0("figs/ValidationCommonGarden/HeightModels/ScatterPlotsPredictedRelationships_",model_i,"_",cg_i,".pdf")), device="pdf", width=12,height=7)

pp

}) %>% setNames(unique(ggtab$cg))

return(ggplots)
}
```
  
  
  
```{r MakePolyPlotsV2, fig.width=12, fig.height=7, eval=F, echo=F}
generate_poly_plots <- function(model_i){

coefftab <- readRDS(file=here(paste0("outputs/ValidationCommonGarden/HeightModels/coefftab_",model_i,".rds")))

ggtab <- coefftab %>% 
  filter(term %in% c("beta_X1","beta_X2")) %>% 
  filter(!grepl("CTD",method)) %>% 
  left_join(distinct(df[,c("method_type","method_input","cg","method")]), by=c("method","cg")) %>% 
  mutate(cg_legend =case_when(cg=="asturias"~"Asturias (37 months)",
                      cg=="bordeaux"~"Bordeaux (85 months)",
                      cg=="caceres"~"Cáceres (8 months)",
                      cg=="madrid"~"Madrid (13 months)",
                      cg=="portugal"~"Fundão (27 months)"),
         method_input=case_when(method_input=="all" ~ "All SNPs",
                                method_input=="cand" ~ "Candidate SNPs",
                                method_input=="control" ~ "Control SNPs")) %>% 
  pivot_wider(names_from="term", values_from = c("mean","std_deviation","conf_low","conf_high"))



lapply(unique(ggtab$cg), function(cg_i){
lapply(unique(ggtab$method), function(method_i){
  
  
  ######
    df_sub <- df %>% filter(method == method_i & cg == cg_i)
    
    sub_data <- height_data %>% 
      filter(cg == cg_i) %>% 
      left_join(df_sub, by = c("cg","pop")) %>% 
      mutate(varX_sdt = (varX -mean(varX))/sd(varX))
    
    
    x <- unique(sub_data$varX_sdt)
    poly_function <- function(a,b,x) {a * x^2 + b * x}
    
    #######
    
    
    
  subggtab <- ggtab %>% filter(method == method_i & cg == cg_i)
  
  tibble(mean=poly_function(a=subggtab$mean_beta_X2, b=subggtab$mean_beta_X1,x=x),
         low=poly_function(a=subggtab$conf_low_beta_X2, b=subggtab$conf_low_beta_X1,x=x),
         high=poly_function(a=subggtab$conf_high_beta_X2, b=subggtab$conf_high_beta_X1,x=x),
         x=x) %>%
    pivot_longer(cols=c("mean","low","high"),names_to="group",values_to="y") %>% 
    
    
  ggplot(aes(x=x,y=y,col=group)) +
  geom_hline(yintercept=0,color="black") +
  geom_line(linewidth=1) +
  geom_point(size=3) +
  ylab('Standardized tree height') + 
  #ylab(paste0('Standardized tree height - ',cg_i)) + 
  xlab(TeX("Standardized predictor")) +
  ylim(-2.5,1.7) +
  #scale_color_manual(values=c("#FCA315FF", "#00FF00FF","#172869FF", "#FF00FFFF"), name = "GEA method") +
  #scale_linetype_manual(values=c("solid","dashed","dotted"), name = "SNP set") +
  theme_bw() + 
  ggtitle(paste0(subggtab$cg_legend," - GO predictions from ",subggtab$method_type," and ",subggtab$method_input)) +
  theme(axis.text.x = element_text(size=13),
        axis.text.y = element_text(size=13),
        axis.title = element_text(size=16),
        legend.box="horizontal",
        legend.key.width = unit(1,"cm"),
        legend.background = element_blank(),
        legend.box.background = element_blank(),
        legend.key = element_blank(),
        legend.position = c(0.73,0.89)) + 
  guides(color=guide_legend(ncol=1))
  
  
  }) 
}) 


}
```
## Model 1

### Model equation and code 


\begin{align*}
Y_{ipb}  &\sim \mathcal{N}(\mu_{pb},\sigma^{2}) \\
\mu_{pb} &= B_b + \beta_{X1}X_p + \beta_{X2}X^2_p\\
\sigma &\sim \text{Exp}(1) \\
\begin{bmatrix} B_b  \\ \beta_{X1} \\ \beta_{X2} \end{bmatrix} &\sim \mathcal{N}(0,1) \\
\end{align*}

  - $Y_{ipb}$ is the height of the individual $i$ in the population $p$ and block $b$.
  - $\sigma^{2}$ is the residual variance of the model.
  - $B_b$ are the block intercepts.
  - $X_p$ is the GO or CTD of the population $p$, with $\beta_{X1}$ and $\beta_{X2}$ being its linear and quadratic coefficients, respectively. The quadratic term was included to allow for potential nonlinearity in the response, following @fitzpatrick2021experimental.


```{r CompileHeightModelM1,message=F,warning=F}
stancode = stan_model(here("scripts/StanModels/ValidationCommonGarden_HeightModel_M1.stan"))
print(stancode)

params_to_estimate <- c("beta_X1","beta_X2","R_squared","sigma","alpha_bloc")
```

```{r RunHeightModelM1, eval=F}
coefftab <- lapply(unique(height_data$cg), function(site_i){
  
  lapply(unique(df$method), function(method_i){
  
    df_sub <- df %>% filter(method == method_i & cg == site_i)
    
    sub_data <- height_data %>% 
      filter(cg == site_i) %>% 
      left_join(df_sub, by = c("cg","pop"))
      
    stanlist <- list(N = nrow(sub_data),
                     Y=(sub_data$height-mean(sub_data$height))/sd(sub_data$height),
                     X=(sub_data$varX -mean(sub_data$varX))/sd(sub_data$varX),
                     nb_bloc = length(unique(sub_data$block)),
                     bloc = as.numeric(as.factor(sub_data$block)))

    mod <- sampling(stancode, data = stanlist, iter = 2000, chains = 4, cores = 4, save_warmup = FALSE,
                    pars=params_to_estimate) 
  
# Model coefficients
    broom.mixed::tidyMCMC(mod,
                          pars=params_to_estimate,
                          droppars = NULL, 
                          robust = FALSE, # give mean and standard deviation
                          ess = F, 
                          rhat = F, 
                          conf.int = T,
                          conf.level = 0.95) %>% 
    dplyr::rename(mean=estimate,
                  std_deviation=std.error,
                  conf_low=conf.low,
                  conf_high=conf.high) %>% 
    mutate(cg=site_i,
           method=method_i,
           .before=1)
    
    
  }) %>% bind_rows()
  
}) %>% bind_rows()

coefftab %>% saveRDS(file=here("outputs/ValidationCommonGarden/HeightModels/coefftab_M1.rds"))
```


### Model coefficients

We plot the mean and 95% credible intervals of the $\beta_{X_1}$ and $\beta_{X_2}$ coefficients. Graph titles include the time in months corresponding to the age at which height and survival were recorded. Coefficients in the green area have the expected sign, reflecting lower height in populations with higher GO predictions.

```{r ModelCoeffM1, fig.height=9, fig.width=12}
generate_interval_plots(model_i = "M1")
```

### Predicted quadratic relationships

We plot the predicted quadratic relationships between tree height and GO predictions / CTD.

```{r MakePolyPlotsM1, fig.width=12, fig.height=7, eval=T}
generate_poly_plots(model_i="M1")
```

### Interpretation

<span style="color: orange;">Interpretation</span>

Higher genomic offset predictions are consistently associated with lower tree height only in Asturias. Most genomic offset predictions are also associated with lower tree height in Bordeaux.

In Fundão, Cáceres and Madrid, the association between genomic offset predictions and tree height are often in the opposite direction as expected. 

Interestingly, the climatic transfer distances based in the mean annual temperature and the annual precipitation are negatively associated with tree height in all common gardens (except Cáceres for the CTD based on annual precipitation). These CTD may therefore be better predictors of tree height in common gardens than the genomic offset predictions. 

Finally, I think that using tree height as a proxy for fitness to evaluate genomic offset predictions in common gardens may not be appropriate in maritime pine because this trait has a very low genetic-by-environment interaction (see previous papers). 
Therefore, the association between genomic offset predictions and tree height in Asturias and Bordeaux may not be due to a higher fitness of the trees that are best adapted to the climate in these common gardens, but more probably to height differences that are common across all environments (i.e. populations from Atlantic climates are generally taller).
This is confirmed by the models below in which the population-specific BLUPs for height across all common gardens was included as a confounder. When included, the association between genomic offset predictions and tree height in Asturias almost disappears and either disappears or goes in the opposite direction as expected in Bordeaux. Except the genomic offset predictions based on the RDA remain negatively associated with tree height in Bordeaux and Asturias. 

Therefore, I am not sure we can go very far in this validation step. We may retain that genomic offset predictions seem to show the most consistent association with tree height when generated with the RDA, and that this association is robust (though smaller) even when the fixed genetic differences across populations are included as confounder. 



## Model 2

### Model equation and code 

Model 2 = Model 1 + Initial height as a confounder.

\begin{align*}
Y_{ipb}  &\sim \mathcal{N}(\mu_{pb},\sigma^{2}) \\
\mu_{pb} &= B_b + \beta_{X1}X_p + \beta_{X2}X^2_p + \beta_H H_p\\
\sigma &\sim \text{Exp}(1) \\
\begin{bmatrix} B_b  \\ \beta_{X1} \\ \beta_{X2} \\ \beta_H \end{bmatrix} &\sim \mathcal{N}(0,1) \\
\end{align*}

  - $Y_{ipb}$ is the height of the individual $i$ in the population $p$ and block $b$.
  - $\sigma^{2}$ is the residual variance of the model.
  - $B_b$ are the block intercepts.
  - $X_p$ is the GO or CTD of the population $p$, with $\beta_{X1}$ and $\beta_{X2}$ being its linear and quadratic coefficients, respectively. The quadratic term was included to allow for potential nonlinearity in the response, following @fitzpatrick2021experimental.
  - $H_p$ is a proxy of the initial height of the trees from population $p$, i.e. when trees were planted. For that, we used the population varying intercepts calculated across all common gardens in the model 1 of @archambeau2022combining.


```{r CompileHeightModelM2, message=F,warning=F}
stancode = stan_model(here("scripts/StanModels/ValidationCommonGarden_HeightModel_M2.stan"))
print(stancode)

params_to_estimate <- c("beta_X1","beta_X2","beta_H","sigma","alpha_bloc",
                        "classic_R2","bayes_R2_mod","bayes_R2_res")
```


```{r RunHeightModelM2, eval=F}
coefftab <- lapply(unique(height_data$cg), function(site_i){
  
  lapply(unique(df$method), function(method_i){
  
    # Subset the data
    df_sub <- df %>% filter(method == method_i & cg == site_i)
    
    sub_data <- height_data %>% 
      filter(cg == site_i) %>% 
      left_join(df_sub, by = c("cg","pop")) %>% 
      left_join(pop_heights %>% dplyr::select(any_of(c("height", "pop"))) %>% dplyr::rename(init_height=height), by="pop")
      
    # Data in a list for Stan
    stanlist <- list(N = nrow(sub_data),
                     Y=(sub_data$height-mean(sub_data$height))/sd(sub_data$height),
                     X=(sub_data$varX -mean(sub_data$varX))/sd(sub_data$varX),
                     H=(sub_data$init_height -mean(sub_data$init_height))/sd(sub_data$init_height),
                     nb_bloc = length(unique(sub_data$block)),
                     bloc = as.numeric(as.factor(sub_data$block)))

    # Run the models
    mod <- sampling(stancode, data = stanlist, iter = 2000, chains = 4, cores = 4, save_warmup = FALSE,
                    pars = params_to_estimate) 
    
    # Save the models
    mod %>% saveRDS(file=here(paste0("outputs/ValidationCommonGarden/HeightModels/stan_models/M2_",site_i,"_",method_i,".rds")))
    
    
    # Extract coefficients
    broom.mixed::tidyMCMC(mod,
                          pars=params_to_estimate,
                          droppars = NULL, 
                          robust = FALSE, # give mean and standard deviation
                          ess = F, 
                          rhat = F, 
                          conf.int = T,
                          conf.level = 0.95) %>% 
    dplyr::rename(mean=estimate,
                  std_deviation=std.error,
                  conf_low=conf.low,
                  conf_high=conf.high) %>% 
    mutate(cg=site_i,
           method=method_i,
           .before=1)
    
    
  }) %>% bind_rows()
  
}) %>% bind_rows()

coefftab %>% saveRDS(file=here("outputs/ValidationCommonGarden/HeightModels/coefftab_M2.rds"))
```

### Proportion of variance explained



The proportion of variance explained by the height models was estimated with the classical $\mathcal{R}^{2}$, the residual-based Bayesian $\mathcal{R}^{2}$ and the model-based Bayesian $\mathcal{R}^{2}$.

The classical $\mathcal{R}^{2}$ is calculated as follows:
 
 $$\mathcal{R}^{2}=1 - \frac{Var(Y-\mu)}{Var(Y)} = \frac{Var(\mu)}{Var(Y)}$$

where $\mu$ is the linear predictor of the model and $Y$ the observed data (tree height).

The Bayesian version of $\mathcal{R}^{2}$ introduced in \citet{gelmanRsquaredBayesianRegression2019} is calculated as follows:

$$\mathcal{R}^{2}=Var_\mu/(Var_\mu + Var_ {res})$$

where $Var_\mu$ is the variance of the modelled predictive means and $Var_{res}$ is the residual variance. 

In the residual-based Bayesian $\mathcal{R}^{2}$, $Var_{res}$ comes from draws from the residual distribution: $Var_{res} = Var(Y-\mu)$. In the model-based Bayesian $\mathcal{R}^{2}$, $Var_{res}$ comes from the posterior quantities of the fitted model such as $Var_{res} = \sigma^2$. As stated in \cite{gelmanRsquaredBayesianRegression2019}, this Bayesian version of $\mathcal{R}^{2}$ can be considered as `a data-based estimate of the proportion of variance explained for new data`.

More information on the Bayesian $\mathcal{R}^{2}$ can also be found in the following vignette: [Bayesian R2 and LOO-R2 by Aki Vehtari, Andrew Gelman, Ben Goodrich and Jonah Gabry](https://avehtari.github.io/bayes_R2/bayes_R2.html).

In the main manuscript, we report results from the model-based Bayesian $\mathcal{R}^{2}$.

### Running model without predictor

```{r M2WithoutPredictor, eval=F}
stancode = stan_model(here("scripts/StanModels/ValidationCommonGarden_HeightModel_M2_WithoutPredictor.stan"))
print(stancode)

params_to_estimate <- c("beta_H","sigma","alpha_bloc",
                        "classic_R2","bayes_R2_mod","bayes_R2_res")

coefftab <- lapply(unique(height_data$cg), function(site_i){
  
    # Subset the data
    df_sub <- df %>% filter(method == "CTD_bio1" & cg == site_i)
    
    sub_data <- height_data %>% 
      filter(cg == site_i) %>% 
      left_join(df_sub, by = c("cg","pop")) %>% 
      left_join(pop_heights %>% dplyr::select(any_of(c("height", "pop"))) %>% dplyr::rename(init_height=height), by="pop")
      
    # Data in a list for Stan
    stanlist <- list(N = nrow(sub_data),
                     Y=(sub_data$height-mean(sub_data$height))/sd(sub_data$height),
                     H=(sub_data$init_height -mean(sub_data$init_height))/sd(sub_data$init_height),
                     nb_bloc = length(unique(sub_data$block)),
                     bloc = as.numeric(as.factor(sub_data$block)))

    # Run the models
    mod <- sampling(stancode, data = stanlist, iter = 2000, chains = 4, cores = 4, save_warmup = FALSE,
                    pars = params_to_estimate) 
    
    # Save the models
    mod %>% saveRDS(file=here(paste0("outputs/ValidationCommonGarden/HeightModels/stan_models/M2_",site_i,"_WithoutPredictor.rds")))
    
    
    # Extract coefficients
    broom.mixed::tidyMCMC(mod,
                          pars=params_to_estimate,
                          droppars = NULL, 
                          robust = FALSE, # give mean and standard deviation
                          ess = F, 
                          rhat = F, 
                          conf.int = T,
                          conf.level = 0.95) %>% 
    dplyr::rename(mean=estimate,
                  std_deviation=std.error,
                  conf_low=conf.low,
                  conf_high=conf.high) %>% 
    mutate(cg=site_i,
           method="WithoutPredictor",
           .before=1)
    
    
  }) %>% bind_rows()

coefftab %>% saveRDS(file=here("outputs/ValidationCommonGarden/HeightModels/coefftab_M2_WithoutPredictor.rds"))
```

### Model coefficients

We plot the mean and 95% credible intervals of the $\beta_{X_1}$, $\beta_{X_2}$ and $\beta_H$ coefficients. Graph titles include the time in months corresponding to the age at which height and survival were recorded. Coefficients in the green area have the expected sign, reflecting lower height in populations with higher GO predictions.

```{r IntervalPlotsM2, fig.width=12, fig.height=9, eval=T}
generate_interval_plots(model_i = "M2")
```

### Vizualising predicted associations

#### Mean height predictions

We plot the mean predicted relationships between tree height and GO predictions / CTD.

```{r PolyPlotsM2, fig.width=12, fig.height=7, eval=T}
generate_poly_plots(model_i = "M2")
```
 
#### Height predictions with uncertainty intervals

The graphs above do not show the estimate uncertainty. We generate some graphs to visualize the uncertainty around the estimates :

  - the uncertainty in the mean estimates (i.e. variability in posterior draws of the linear predictor $\mu$)
  
  - the uncertainty in tree height predictions (i.e. after accounting for $\sigma$ in the predictions).

```{r HeightPredictionsM2, message=F,warning=F, fig.height=6, fig.width=6, eval=F}
#############################################################################
# Visualizing the relationships between GO predictions and height predictions
#############################################################################

lapply(unique(height_data$cg), function(site_i){

list(CTDs=names(methods) %>% str_subset("^CTD"),
     go_methods=names(methods) %>% str_subset("^CTD", negate=T)) %>% 
    
    lapply(function(method_group_i){
      
myplots <- lapply(method_group_i, function(method_i){

# Subset the data
df_sub <- df %>% filter(method == method_i & cg == site_i)
    
sub_data <- height_data %>% 
      filter(cg == site_i) %>% 
      left_join(df_sub, by = c("cg","pop")) %>% 
      left_join(pop_heights %>% dplyr::select(any_of(c("height", "pop"))) %>% dplyr::rename(init_height=height), by="pop")
      
# Data in a list for Stan
stanlist <- list(N = nrow(sub_data),
                 Y=(sub_data$height-mean(sub_data$height))/sd(sub_data$height),
                 X=(sub_data$varX -mean(sub_data$varX))/sd(sub_data$varX),
                 H=(sub_data$init_height -mean(sub_data$init_height))/sd(sub_data$init_height),
                 nb_bloc = length(unique(sub_data$block)),
                 bloc = as.numeric(as.factor(sub_data$block)))
    
# Loading the model
mod <- readRDS(file = here(paste0("outputs/ValidationCommonGarden/HeightModels/stan_models/M2_",site_i,"_",method_i,".rds")))

# we extract the posterior distributions of all parameters
post <- as.data.frame(mod)

# Vector of predictor values (based on the min and max of the GO predictions)
x_vec <- seq(min(stanlist$X),max(stanlist$X),0.05)


# Predicting the linear predictor mu (predicting mean-centered height without sigma uncertainty)
################################################################################################

# we extract the posterior draws of mu, and its mean and HDPIs for each predictor value

# Function to predict mean-centered height in block 2 and with the initial tree height fixed to the mean
f_mu <- function(x) post$`alpha_bloc[2]` + post$`beta_X1` * x + post$`beta_X2` * x^2 + post$`beta_H` * mean(sub_data$init_height) 

mu_pred <- 
  sapply(x_vec, f_mu) %>% 
  tibble::as_tibble() %>%
  rename_all(function(x) x_vec) %>%
  mutate(Iter = row_number()) %>%
  gather(x, y, -Iter) %>%
  group_by(x) %>%
  mutate(hpdi_l = HDInterval::hdi(y, credMass = 0.90)[1],
         hpdi_h = HDInterval::hdi(y, credMass = 0.90)[2]) %>%
  mutate(mu_mean = mean(y)) %>%
  ungroup() %>%
  mutate(x = as.numeric(x))

# Keep mean and 90% HDPI of mu (one value for each iteration)
mu_mean_df <- mu_pred %>%
  dplyr::select(x,mu_mean,hpdi_l,hpdi_h) %>% 
  dplyr::distinct()

# Predicting mean-centered height with sigma uncertainty)
#########################################################

# we extract the posterior draws of height predictions, and its mean and PIs for each predictor value

y_pred <- 
  sapply(x_vec,
         function(x)
           rnorm(NROW(post),
                 post$`alpha_bloc[2]` + post$`beta_X1` * x + post$`beta_X2` * x^2 + post$`beta_H` * mean(sub_data$init_height),
                 post$sigma)) %>%
  as_tibble() %>%
  rename_all(function(x) x_vec) %>%
  mutate(Iter = row_number()) %>%
  gather(x, y, -Iter) %>%
  group_by(x) %>%
  mutate(hpdi_l = HDInterval::hdi(y, credMass = 0.90)[1],
         hpdi_h = HDInterval::hdi(y, credMass = 0.90)[2]
         # pi_l = rethinking::PI(y, prob = 0.90)[1],
         # pi_h = rethinking::PI(y, prob = 0.90)[2]
         ) %>%
  ungroup() %>%
  mutate(x = as.numeric(x)) %>% 
  dplyr::select(x,hpdi_l,hpdi_h) %>% 
  dplyr::distinct()


# Plots
#######

# Plot options 
y_limits <- c(-3,3)
if(grepl("CTD",method_group_i[[1]]) == T){x_axis <- "Mean-centered CTD"} else {
  x_axis <- "Mean-centered GO predictions"}
y_axis <- "Mean-centered tree height"

p <- ggplot() +
  ylim(y_limits) +
  labs(y=y_axis, x=x_axis) +
  theme_bw()

# First 100 posterior draws of the linear predictor mu
p1 <- p +
  geom_point(data = mu_pred %>% filter(Iter < 101),
             aes(x, y), alpha = .2, color = 'dodgerblue')
  
# Mean (line) and 90% HPDI (shaded region) of the linear predictor mu
p2 <- p +
  geom_ribbon(data = y_pred,
                 mapping = aes(x=x, ymin=hpdi_l, ymax=hpdi_h), alpha = .1, fill='dodgerblue') +
  geom_ribbon(data = mu_mean_df,
              aes(x = x, ymin = hpdi_l, ymax = hpdi_h),
              alpha = .2,
              fill='dodgerblue') +
  geom_line(data = mu_mean_df,
              aes(x=x, y=mu_mean), col="dodgerblue4")

p1_p2 <- ggarrange(p1, p2 + labs(y=""), nrow = 1)

# Title
title <- ggdraw() + 
  draw_label(paste0(cg_names[[site_i]]," - ",methods[[method_i]]),
             fontface = 'bold',
             x = 0, hjust = 0) +   
  theme(plot.margin = margin(0, 0, 0, 7))

# merge title and plots
p1_p2 <- plot_grid(title, p1_p2, ncol = 1, rel_heights = c(0.1, 1))

p2 <- p2 + labs(subtitle = methods[[method_i]])

ggsave(p1_p2,
       file=here(paste0("figs/ValidationCommonGarden/HeightModels/HeightPredictions_MuPosteriorDraws_UncertaintyIntervals/",
                        method_i,"_",site_i,"_M2.pdf")),
       device="pdf",
       height=6,
       width=11)


return(p2)

})

if(grepl("CTD",method_group_i[[1]]) == T){
  
  group_name <- "CTDs"
  
  p <- plot_grid(myplots[[1]] + labs(x=""),
                 myplots[[2]] + labs(y="",x=""),
                 myplots[[3]] + labs(x=""),
                 myplots[[4]] + labs(y="",x=""),
                 myplots[[5]],
                 myplots[[6]] + labs(y=""),
                 ncol=2)
  
  fig_width <- 10
  
} else {
  
  group_name <- "SNPsets"
  
  p <- plot_grid(myplots[[1]] + labs(x=""),
                 myplots[[2]] + labs(y="",x=""),
                 myplots[[3]] + labs(y="",x=""),
                 myplots[[4]] + labs(x=""),
                 myplots[[5]] + labs(y="",x=""),
                 myplots[[6]] + labs(y="",x=""),
                 myplots[[7]],
                 myplots[[8]] + labs(y=""),
                 myplots[[9]] + labs(y=""),
                 ncol=3)
  
    fig_width <- 12
    
    }


ggsave(p,
       file=here(paste0("figs/ValidationCommonGarden/HeightModels/HeightPredictions_",
                        group_name,"_",site_i,"_M2.pdf")),
       device="pdf",
       height=12,
       width=fig_width)

})
  
})
```


## Model 3

### Model equation and code 

Model 3 = Model 2 + Initial height as a confounder + Clone fixed intercepts

\begin{align*}
Y_{ipb}  &\sim \mathcal{N}(\mu_{pb},\sigma^{2}) \\
\mu_{pb} &= \beta_0 + B_b + \beta_{X1}X_p + \beta_{X2}X^2_p + \beta_H H_p\\
\beta_0 &\sim \mathcal{N}(\text{mean}(Y),2) \\ 
\sigma &\sim \text{Exp}(1) \\
\begin{bmatrix} B_b \\ C_c \\ \beta_{X1} \\ \beta_{X2} \\ \beta_H \end{bmatrix} &\sim \mathcal{N}(0,1) \\
\end{align*}

  - $Y_{ipb}$ is the height of the individual $i$ in the population $p$ and block $b$.
  - $\sigma^{2}$ is the residual variance of the model.
  - $B_b$ are the block intercepts. 
  - $X_p$ is the GO or CTD of the population $p$, with $\beta_{X1}$ and $\beta_{X2}$ being its linear and quadratic coefficients, respectively. The quadratic term was included to allow for potential nonlinearity in the response, following @fitzpatrick2021experimental.
  - $H_p$ is a proxy of the initial height of the trees from population $p$, i.e. when trees were planted. For that, we used the population varying intercepts calculated across all common gardens in the model 1 of @archambeau2022combining.
  - $\beta_0$ is the model global intercept.
  - $C_c$ are the clone intercepts. 

```{r CompileHeightModel3, message=F,warning=F}
stancode = stan_model(here("scripts/StanModels/ValidationCommonGarden_HeightModel_M3.stan"))
print(stancode)

params_to_estimate <- c("beta_X1","beta_X2","beta_H","R_squared","sigma","alpha_bloc","alpha_clon")
```


```{r RunHeightyModel3, eval=F}
coefftab <- lapply(unique(height_data$cg), function(site_i){
  
  lapply(unique(df$method), function(method_i){
  
    df_sub <- df %>% filter(method == method_i & cg == site_i)
    
    sub_data <- height_data %>% 
      filter(cg == site_i) %>% 
      left_join(df_sub, by = c("cg","pop")) %>% 
      
      left_join(pop_heights %>% dplyr::select(any_of(c("height", "pop"))) %>% dplyr::rename(init_height=height), by="pop")

# Datalist for Stan      
    stanlist <- list(N = nrow(sub_data),
                     Y=(sub_data$height-mean(sub_data$height))/sd(sub_data$height),
                     X=(sub_data$varX -mean(sub_data$varX))/sd(sub_data$varX),
                     H=(sub_data$init_height -mean(sub_data$init_height))/sd(sub_data$init_height),
                     nb_bloc = length(unique(sub_data$block)),
                     nb_clon = length(unique(sub_data$clon)),
                     bloc = as.numeric(as.factor(sub_data$block)),
                     clon = as.numeric(as.factor(sub_data$clon)))
    
# Running the model
    mod <- sampling(stancode, data = stanlist, iter = 2000, chains = 4, cores = 4, save_warmup = FALSE,
                    pars = params_to_estimate) 
  
# Model coefficients
    broom.mixed::tidyMCMC(mod,
                          pars=params_to_estimate,
                          droppars = NULL, 
                          robust = FALSE, # give mean and standard deviation
                          ess = F, 
                          rhat = F, 
                          conf.int = T,
                          conf.level = 0.95) %>% 
    dplyr::rename(mean=estimate,
                  std_deviation=std.error,
                  conf_low=conf.low,
                  conf_high=conf.high) %>% 
    mutate(cg=site_i,
           method=method_i,
           .before=1)
    
    
  }) %>% bind_rows()
  
}) %>% bind_rows()

coefftab %>% saveRDS(file=here("outputs/ValidationCommonGarden/HeightModels/coefftab_M3.rds"))
```

### Model coefficients

We plot the mean and 95% credible intervals of the $\beta_{X_1}$, $\beta_{X_2}$ and $\beta_H$ coefficients. Graph titles include the time in months corresponding to the age at which height and survival were recorded. Coefficients in the green area have the expected sign, reflecting lower height in populations with higher GO predictions.

```{r IntervalPlotsM3, fig.width=12, fig.height=9, eval=T}
generate_interval_plots(model_i = "M3")
```

### Predicted quadratic relationships

We plot the predicted quadratic relationships between tree height and GO predictions / CTD.

```{r PolyPlotsM3, fig.width=12, fig.height=7, eval=T}
generate_poly_plots(model_i = "M3")
```


## Model 4

### Model equation and code 

Model 4 = Model 2 + Initial height as a confounder + Clone varying intercepts

\begin{align*}
Y_{ipb}  &\sim \mathcal{N}(\mu_{pb},\sigma^2) \\
\mu_{pb} &= \beta_0 + B_b + \beta_{X1}X_p + \beta_{X2}X^2_p + \beta_H H_p\\
\beta_0 &\sim \mathcal{N}(\text{mean}(Y),2) \\ 
C_c &\sim \mathcal{N}(0,\sigma_C^2) \\ 
\begin{bmatrix} \sigma \\ \sigma_C \end{bmatrix} &\sim \text{Exp}(1) \\
\begin{bmatrix} B_b \\ \beta_{X1} \\ \beta_{X2} \\ \beta_H \end{bmatrix} &\sim \mathcal{N}(0,1) \\
\end{align*}

  - $Y_{ipb}$ is the height of the individual $i$ in the population $p$ and block $b$.
  - $\sigma^{2}$ is the residual variance of the model.
  - $B_b$ are the block intercepts. 
  - $X_p$ is the GO or CTD of the population $p$, with $\beta_{X1}$ and $\beta_{X2}$ being its linear and quadratic coefficients, respectively. The quadratic term was included to allow for potential nonlinearity in the response, following @fitzpatrick2021experimental.
  - $H_p$ is a proxy of the initial height of the trees from population $p$, i.e. when trees were planted. For that, we used the population varying intercepts calculated across all common gardens in the model 1 of @archambeau2022combining.
  - $\beta_0$ is the model global intercept.
  - $C_c$ are the clone varying intercepts which follow a normal distribution of variance $\sigma_C^2$.

```{r CompileHeightModel4, message=F,warning=F}
stancode = stan_model(here("scripts/StanModels/ValidationCommonGarden_HeightModel_M4.stan"))
print(stancode)

params_to_estimate <- c("beta_X1","beta_X2","beta_H","R_squared","sigma","alpha_bloc","alpha_clon")
```


```{r RunHeightModel4, eval=F}
coefftab <- lapply(unique(height_data$cg), function(site_i){
  
  lapply(unique(df$method), function(method_i){
  
    df_sub <- df %>% filter(method == method_i & cg == site_i)
    
    sub_data <- height_data %>% 
      filter(cg == site_i) %>% 
      left_join(df_sub, by = c("cg","pop")) %>% 
      
      left_join(pop_heights %>% dplyr::select(any_of(c("height", "pop"))) %>% dplyr::rename(init_height=height), by="pop")

# Datalist for Stan      
    stanlist <- list(N = nrow(sub_data),
                     Y=(sub_data$height-mean(sub_data$height))/sd(sub_data$height),
                     X=(sub_data$varX -mean(sub_data$varX))/sd(sub_data$varX),
                     H=(sub_data$init_height -mean(sub_data$init_height))/sd(sub_data$init_height),
                     nb_bloc = length(unique(sub_data$block)),
                     nb_clon = length(unique(sub_data$clon)),
                     bloc = as.numeric(as.factor(sub_data$block)),
                     clon = as.numeric(as.factor(sub_data$clon)))
    
# Running the model
    mod <- sampling(stancode, data = stanlist, iter = 2000, chains = 4, cores = 4, save_warmup = FALSE,
                    pars = params_to_estimate) 
  
# Model coefficients
    broom.mixed::tidyMCMC(mod,
                          pars=params_to_estimate,
                          droppars = NULL, 
                          robust = FALSE, # give mean and standard deviation
                          ess = F, 
                          rhat = F, 
                          conf.int = T,
                          conf.level = 0.95) %>% 
    dplyr::rename(mean=estimate,
                  std_deviation=std.error,
                  conf_low=conf.low,
                  conf_high=conf.high) %>% 
    mutate(cg=site_i,
           method=method_i,
           .before=1)
    
    
  }) %>% bind_rows()
  
}) %>% bind_rows()

coefftab %>% saveRDS(file=here("outputs/ValidationCommonGarden/HeightModels/coefftab_M4.rds"))
```

### Model coefficients

We plot the mean and 95% credible intervals of the $\beta_{X_1}$, $\beta_{X_2}$ and $\beta_H$ coefficients. Graph titles include the time in months corresponding to the age at which height and survival were recorded. Coefficients in the green area have the expected sign, reflecting lower height in populations with higher GO predictions.

```{r IntervalPlotsM4, fig.width=12, fig.height=9, eval=T}
generate_interval_plots(model_i = "M4")
```

### Predicted quadratic relationships

We plot the predicted quadratic relationships between tree height and GO predictions / CTD.

```{r PolyPlotsM4, fig.width=12, fig.height=7, eval=T}
generate_poly_plots(model_i = "M4")
```

## Sample size for each clone

We look at the number of height measurements for each clone. In the tables below (one for each common garden), the first column correspond to the number of height measurements and the second column correspond to the number of clones with this number of measurements.

```{r SampleSizeForEachClone}
lapply(unique(height_data$cg), function(site_i){
  
  
height_data %>% 
    filter(cg==site_i) %>% 
    dplyr::select(pop,clon) %>% 
    drop_na() %>% 
    group_by(clon) %>% 
    dplyr::summarise(nb_measurements=n()) %>% 
    count(nb_measurements)
  
  
}) %>% set_names(unique(height_data$cg))
```

# DRYAD repository

We export mortality and height data in the DRYAD repository.

```{r PhenoDataInDryadRepo}
pheno_data %>% 
  dplyr::rename(cg = site) %>% 
  dplyr::select(cg,block,pop,clon,tree,any_of(height_measurements),any_of(surv_measurements)) %>% 
  write_csv(here("data/DryadRepo/CommonGardenData_cleaned.csv"))
```


# Session information

```{r SessionInfo}
devtools::session_info()
```

