---
title: "Gradient Forest - Genomic offset predictions"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    toc: true
    toc-depth: 4
    code-fold: true
    page-layout: full
embed-resources: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body {
   font-size: 15px;
}
code.r{
  font-size: 11px;
}
pre {
  font-size: 11px
}

table {
  font-size: 11px
}
</style>

```{r setup, include=F}
knitr::opts_chunk$set(dev.args = list(png = list(type = "cairo")))
knitr::opts_chunk$set(cache=F, size="tiny")
options(width = 300)
library(knitr)      # CRAN v1.26
library(kableExtra) # CRAN v1.1.0
library(tidyverse)
library(gradientForest)
library(here)
library(cowplot)
library(magrittr)
library(rnaturalearthdata)
library(rnaturalearth)
library(sf)
library(here)
library(raster)
library(RColorBrewer)
library(pdist)
library(corrplot)
library(latex2exp)

# my own function for building tables in reports
source(here("scripts/functions/kable_mydf.R"))
source(here("scripts/functions/extract_climatedt_metadata.R")) # extracting meta data of the climatic variables in ClimateDT
```




# Introduction

R code based on [the github repository](https://github.com/fitzLab-AL/geneticOffsetR) associated with @fitzpatrick2021experimental. 


# Data

> Genomic data

```{r LoadData}
# Population-based allele frequencies
# ===================================
geno <- read.csv(here("data/DryadRepo/ImputedGenomicData_AlleleFrequencies_withoutmaf.csv"),
                     row.names = 1)

# SNP sets
# ========
snp_sets <- readRDS(here("outputs/list_snp_sets.rds"))
```

> Climatic data

```{r LoadClimaticData}
# Set of climatic variables
# =========================
clim_var <- readRDS(here("data/ClimaticData/NamesSelectedVariables.rds"))


# Climatic data
# =============
# we scale the past and future climatic data at the location of the populations
# with the parameters (mean and variance) of the past climatic data.
source(here("scripts/functions/generate_scaled_clim_datasets.R"))
clim_dfs <- generate_scaled_clim_datasets(clim_var,clim_ref_adj = FALSE)
```

# Running GF models

```{r RunGF, message=F, results="hide"}
snp_sets <- lapply(snp_sets, function(snp_set) {


# Warning! Important to sort the SNP names, otherwise
  # the colors in the species (allele) cumulative plots 
  # do not correspond to the right alleles
geno_sub <- geno %>% dplyr::select(all_of(sort(snp_set$set_snps)))

snp_set$gf_mod <- gradientForest(data.frame(clim_dfs$clim_ref[,-1], geno_sub), 
                                 predictor.vars=clim_var, 
                                 response.vars=colnames(geno_sub), 
                                 corr.threshold=0.5, 
                                 ntree=500, 
                                 trace=T)

return(snp_set)

})
```

Number of alleles for which the climatic variables have some predictive power:

```{r NbAllelesPredictivePower}
lapply(snp_sets, function(x){
  tibble("SNP set"=x$set_name,
             "Nb of alleles with predictive power"=x$gf_mod$species.pos.rsq)
}) %>% 
  bind_rows() %>% 
  kable_mydf()
```


We generate some plots to evaluate the GF models (stored in the files `GFplots_[SNP set code].pdf`):

  - **Predictor overall importance plots**. They show the mean accuracy importance and the mean importance weighted by SNPs $\mathcal{R}^2$.
  
  - **Splits density plots**. They show the binned split importance and location on each gradient (spikes), kernel density of splits (blacklines), of observations (red lines) and of splits standardised by observations density (bluelines). Each distribution integrates to predictor importance. These show where important changes in the abundance of multiple alleles are occurring along the gradient; they indicate a composition change rate.

  - **Species** (in our case alleles) **cumulative plots**. They show, for each SNPs, the cumulative importance distributions of splits improvement scaled by $\mathcal{R}^2$ weighted importance, and standardised by density of observations. These show cumulative change in the presence of individual allele, where changes occur on the gradient, and the alleles changing most on each gradient.

  - **Predictor cumulative plots**. They show, for each predictor, the cumulative importance distributions of splits improvement scaled by $\mathcal{R}^2$ weighted importance, and standardised by density of observations, averaged over all SNPs. These show cumulative change in overall allelic composition, and where changes occur on the gradient.
  
  - $\mathcal{R}^2$ **measure of the fit** of the random forest model for each SNPs.
  
The code to generate those plots comes from 'Example analysis of biodiversity survey data with R package `gradientForest`' by C. Roland Pitcher, Nick Ellis and Stephen J. Smith ([pdf available here](https://gradientforest.r-forge.r-project.org/biodiversity-survey.pdf)).

```{r GenerateGFplots, results="hide"}
# ==============================
# Functions to make the GF plots
# ==============================

# splits density plot
make_split_density_plot <- function(x){

  plot(x,plot.type="S",
       imp.vars=names(importance(x)),
       leg.posn="topright",
       cex.legend=1,
       cex.axis=1, 
       cex.lab=1.2,
       line.ylab=0.9,
       par.args=list(mgp=c(1.5, 0.5,0),mar=c(3.1,1.5,0.1,1),omi = c(0.1, 0.3, 0.1, 0.1)))
  
  }

# predictor cumulative plot
make_predictor_cumulative_plot <- function(x){
  
  plot(x, plot.type="C",
       imp.vars=names(importance(x)),
       show.species=F,common.scale=T,
       cex.axis=1, 
       cex.lab=1.5,
       line.ylab=1,
       par.args=list(mgp=c(1.5, 0.5,0),mar=c(2.5,1,0.1,0.5),omi=c(0, +0.3,0,0)))}


# species cumulative plot
make_species_cumulative_plot <- function(x){
  
  plot(x,
     plot.type="C",imp.vars=names(importance(x)), 
     show.overall=F,legend=T,leg.posn="topleft", 
     leg.nspecies=10,
     cex.lab=1,
     cex.legend=1, 
     cex.axis=1,
     line.ylab=1,
     par.args=list(mgp=c(1.5, 0.5,0),mar=c(2.5,1,0.1,0.5),omi=c(0, +0.3,0,0)))
  }


# R2 measure of the fit of the random forest model for each species
make_performance_plot <- function(x, horizontal=FALSE){

    old.mar<-par()$mar
    par(mfrow=c(1,1),mar=old.mar+c(0,0,0,0))
    Ylab <- expression(R^2)

    perf <- importance(x, type="Species")
    n <- length(perf)
    if (horizontal)
      plot(perf, 1:n, las = 2, pch=19, axes=F, xlab="", ylab="")
    else
      plot(1:n, perf, las = 2, pch=19, axes=F, xlab="", ylab="")
    axis(labels= names(perf),side=1+horizontal,at=1:n, cex.axis=0.7, padj=0,las=2)
    axis(side=2-horizontal, cex.axis=1)
    mtext(Ylab,side=2-horizontal,line=2)
    title("Overall performance of random forests over loci")
    abline(h = 0, lty = 2)
    box()
    par(mar=old.mar)

}

# ===============================================
# Generate the GF plots for the Github repository
# ===============================================
lapply(snp_sets, function(snp_set){

pdf(here(paste0("figs/GF/GFplots_",snp_set$set_code,".pdf")), width=12,height=8)

# Overall importance plot
plot(snp_set$gf_mod, plot.type="Overall.Importance")

# splits density plot
make_split_density_plot(x=snp_set$gf_mod)

# species cumulative plot
make_species_cumulative_plot(x=snp_set$gf_mod)

# predictor cumulative plot
make_predictor_cumulative_plot(x=snp_set$gf_mod)

# R2 measure of the fit of the random forest model for each species
make_performance_plot(x=snp_set$gf_mod)

dev.off()

})

# =======================================================
# Generate the GF plots for the Supplementary Information
# =======================================================
lapply(snp_sets[c(1,3)], function(snp_set){

# Overall importance plot
pdf(here(paste0("figs/GF/GFplots_OverallImportance_",snp_set$set_code,"_SI.pdf")), width=8,height=5)
plot(snp_set$gf_mod, plot.type="Overall.Importance")
dev.off()

# Splits density plot
pdf(here(paste0("figs/GF/GFplots_SplitDensityPlot_",snp_set$set_code,"_SI.pdf")), width=8,height=5)
make_split_density_plot(x=snp_set$gf_mod)
dev.off()

# Allele cumulative plot
pdf(here(paste0("figs/GF/GFplots_AlleleCumulativePlot_",snp_set$set_code,"_SI.pdf")), width=7,height=7)
make_species_cumulative_plot(x=snp_set$gf_mod)
dev.off()

# predictor cumulative plot
pdf(here(paste0("figs/GF/GFplots_PredictorCumulativePlot_",snp_set$set_code,"_SI.pdf")), width=7,height=7)
make_predictor_cumulative_plot(x=snp_set$gf_mod)
dev.off()

# R2 measure of the fit of the random forest model for each species
p <- tibble(snp=names(sort(snp_set$gf_mod$result)),importance=sort(snp_set$gf_mod$result)) %>% 
  ggplot() +
  geom_point(aes(y=reorder(snp, importance),x=importance)) +
  ylab("") +
  xlab(expression(R^2)) +
  theme_bw() 

ggsave(p, filename = here(paste0("figs/GF/GFPlots_AlleleImportance_",snp_set$set_code,"_SI.pdf")), width=4, height=10)


})
```

# GO predictions

```{r PredictGOpops}
snp_sets <- lapply(snp_sets, function(snp_set){
  
snp_set$go <- lapply(clim_dfs$clim_pred, function(clim_pred){

ref_pred <- predict(snp_set$gf_mod) # predictions under current climates
fut_pred <- predict(snp_set$gf_mod, as.data.frame(clim_pred[,clim_var])) # predictions under future climates


lapply(1:nrow(ref_pred), function(x, ref_pred, fut_pred){
    as.numeric(pdist(ref_pred[x,],  fut_pred[x,])@dist)}, fut_pred=fut_pred, ref_pred=ref_pred) %>% 
  unlist()

})
return(snp_set)
})
```


## Relationship with Euclidean distance

```{r MakeEuclideanDistancePlots}
source(here("scripts/functions/make_eucli_plot.R"))

# Calculate the Euclidean climatic distance
list_dist_env <- clim_dfs$clim_pred %>% lapply(function(clim_pred){
  
Delta = clim_dfs$clim_ref %>% dplyr::select(any_of(clim_var)) - clim_pred %>% dplyr::select(any_of(clim_var)) 
dist_env = sqrt( rowSums(Delta^2) )

})

# Main gene pools (for the figures)
gps <- readRDS(here("data/GenomicData/MainGenePoolPopulations.rds")) %>%  arrange(pop)
```

```{r MakeEucliPlots, fig.width=12, results="hide"}
par(mfrow=c(1,2))

lapply(snp_sets, function(x) {

lapply(names(list_dist_env), function(gcm){
  
make_eucli_plot(
  X = list_dist_env[[gcm]],
  Y = x$go[[gcm]],
  colors = gps$color_main_gp_pop,
  color_names = gps$main_gp_pop,
  ylab = "GF genomic offset",
  legend_position="topleft",
  plot_title = paste0(x$set_name," - ", gcm))

})
}) 
```


```{r MakeEucliPlotsGGPLOT, warning=F}
# We generate scatter plots for the Supplementary Information.
# ============================================================

# Axis limits
# ===========
max_go <- lapply(snp_sets[c(1,3)], function(z){
  z$go %>% unlist()
}) %>% unlist() %>% max()

range_eucli <- list_dist_env %>% unlist() %>% range()

# Run the function
# ================
lapply(snp_sets[c(1,3)], function(set_i) {

p <- lapply(names(list_dist_env), function(gcm){
  
make_ggscatterplot(
  x = list_dist_env[[gcm]],
  y = set_i$go[[gcm]],
  title=gcm,
  range_eucli = range_eucli,
  max_go = max_go)

})

# remove y-labels to graphs in the second column
p[[2]] <- p[[2]] + ylab("")
p[[4]] <- p[[4]] + ylab("")


# remove x-labels to graphs in the second and third rows
p[[1]] <- p[[1]] + xlab("")
p[[2]] <- p[[2]] + xlab("")
p[[3]] <- p[[3]] + xlab("")

p[[6]] <- get_legend(p[[1]])

for(i in 1:5){p[[i]] <- p[[i]]  +  theme(legend.position = "none")} 


plot_grid(plotlist=p, nrow = 3) %>% 
  ggsave(here(paste0("figs/GF/ScatterPlotEucliDistance_",set_i$set_code,".pdf")), 
         .,
         width=7,
         height=8,
         device="pdf")

})
```


## Comparing GO predictions

We look at the correlation across the different genomic offset predictions at the location of the populations, i.e. those based on all SNPs and those based on sets of candidates or control SNPs.

```{r CorrplotsGOPredictionsPopulations, fig.height=5,fig.width=14, results="hide"}
par(mfrow=c(1,3))

lapply(names(snp_sets[[1]]$go), function(gcm){
  
lapply(snp_sets, function(x) x$go[[gcm]]) %>% 
  as_tibble() %>%
  cor() %>% 
  corrplot(method = 'number',type = 'lower', 
           diag = FALSE,mar=c(0,0,2,0),
           title=gcm,
           number.cex=2,tl.cex=1.5)
  
})
```


### Maps

```{r MakeGomaps, fig.width=12, fig.height=7, results="hide", warning=F}
# Function to make the genomic offset maps
source(here("scripts/functions/make_go_map.R"))

# Population coordinates
pop_coord <-  readRDS(here(paste0("data/ClimaticData/MaritimePinePops/ClimatePopulationLocationPointEstimates_ReferencePeriods_noADJ.rds")))[[1]]$ref_means %>% dplyr::select(pop,longitude,latitude)

# Find minimum and maximum values of genomic offset for the maps
go_limits <- lapply(snp_sets, function(x) {
lapply(names(list_dist_env), function(gcm){
x$go[[gcm]]
}) %>%  unlist()
}) %>%  unlist() %>% range()
# The minimum GO value is very very small, almost zero, so we fix it to zero.
go_limits[[1]] <- 0


# Generate the maps for each set of SNPs and each GCM
lapply(snp_sets, function(x) {

go_maps <- lapply(names(list_dist_env), function(gcm){
  
make_go_map(dfcoord=pop_coord,
            snp_set = x,
            gcm=gcm,
            ggtitle=gcm,
            go_limits = go_limits,
            point_size = 3)

})

legend_maps  <- get_legend(go_maps[[1]])

go_maps <- lapply(go_maps, function(y) y + theme(legend.position = "none"))

go_maps$legend_maps <- legend_maps

go_maps <-plot_grid(plotlist=go_maps)

# =====================================================
# We save the figures for the Supplementary Information
# =====================================================
if(x$set_code=="cand"){ 
  ggsave(here("figs/GF/GOMaps_PopLocations_CandidateSNPs_SI.pdf"), go_maps, width=10,height=6, device="pdf")
  
  } else if(x$set_code=="control"){
    ggsave(here("figs/GF/GOMaps_PopLocations_ControlSNPs_SI.pdf"), go_maps, width=10,height=6, device="pdf")
    }


# =========
# Add title
# =========
title <- ggdraw() + 
  draw_label(
    x$set_name,
    fontface = 'bold',
    x = 0,
    hjust = 0
  ) +
  theme(plot.margin = margin(0, 0, 0, 7))

# merge title and plots
plot_grid(
  title, go_maps,
  ncol = 1,
  rel_heights = c(0.1, 1))
})
```

For each GCM, we attribute the value `1` to the top five populations with the highest genomic offset and we attribute the value `0` to the other populations. We then count the number of `1` for each population, which gives the table and map below:

```{r HighGoPopMap, fig.height=6,fig.width=6}
source(here("scripts/functions/make_high_go_pop_maps.R"))

high_go_pops <- make_high_go_pop_maps(pop_coord=pop_coord,
                                      list_go = snp_sets$cand$go,
                                      ggtitle="GF",
                                      nb_id_pop = 5) # number of selected populations

saveRDS(high_go_pops, file = here("outputs/GF/high_go_pops.rds"))

high_go_pops[[1]] %>% kable_mydf

high_go_pops[[2]]
```


# Validation - NFI plots

```{r NFIGOmaps, fig.width=8,fig.height=8, results="hide"}
# Load the climatic data of the NFI plots.
nfi_clim <- readRDS(here("data/ClimaticData/NFIplots/NFIclimate.rds"))
  
# Keep only the climatic variables of interest and scale the climatic data
nfi_dfs <- generate_scaled_clim_datasets(clim_var, clim_ref = nfi_clim$clim_ref, clim_pred = nfi_clim$clim_survey)

# calculate the genomic offset for the NFI plots
snp_sets <- lapply(snp_sets, function(snp_set){
  
ref_pred <- predict(snp_set$gf_mod, as.data.frame(nfi_dfs$clim_ref[,clim_var])) # predictions under reference-period climates
fut_pred <- predict(snp_set$gf_mod, as.data.frame(nfi_dfs$clim_pred[,clim_var])) # predictions under climates during survey period

snp_set$go_nfi <- lapply(1:nrow(ref_pred), function(x, ref_pred, fut_pred){
    as.numeric(pdist(ref_pred[x,],  fut_pred[x,])@dist)}, fut_pred=fut_pred, ref_pred=ref_pred) %>% 
  unlist()


return(snp_set)
})

# checking missing data
# lapply(snp_sets, function(x) sum(is.na(x$go_nfi)))

# Find minimum and maximum values of genomic offset for the maps
go_limits <- lapply(snp_sets, function(snp_set) snp_set$go_nfi) %>%  unlist() %>% range()
# The minimum GO value is very very small, almost zero, so we fix it to zero.
go_limits[[1]] <- 0


# map genomic offset predictions in the NFI plots 
lapply(snp_sets, function(x) {
  
  p <- make_go_map(
  dfcoord= readRDS(here("data/ClimaticData/NFIplots/NFIclimate.rds"))[[1]] %>% dplyr::select(contains("ude")), 
  snp_set = x,
  type="NFI",
  point_size = 0.5,
  go_limits = go_limits,
  legend_position = c(0.85,0.15),
  legend_box_background = "gray80",
  y_limits = c(35, 51))
  
  
# Figure for the SI
# =================
if(x$set_code=="cand"){ 
  p_SI <- p + theme(plot.title = element_blank())
  ggsave(here("figs/GF/NFI_GOmap_CandidateSNPs_SI.pdf"), p_SI, width=8,height=8, device="pdf")
  
  } else if(x$set_code=="control"){
    p_SI <- p + theme(plot.title = element_blank())
    ggsave(here("figs/GF/NFI_GOmap_ControlSNPs_SI.pdf"), p_SI, width=8,height=8, device="pdf")
    }

# Show maps in the Quarto document
# ================================
p
  
  })
```

We look at the correlation across the different genomic offset predictions in the NFI plots, i.e. those based on all SNPs and those based on sets of candidates or control SNPs.

```{r CorrelationGONFIPlots, fig.height=7,fig.width=7, results="hide"}
lapply(snp_sets, function(x) x$go_nfi) %>% 
  as_tibble() %>%
  cor() %>% 
  corrplot(method = 'number',type = 'lower', diag = FALSE,mar=c(0,0,2,0),
               number.cex=2,tl.cex=1.5)
```




# Validation - Common gardens

```{r MakeGOmapsCGplots, fig.width=15, fig.height=6, results="hide"}
cg_clim <- readRDS(here("data/ClimaticData/CommonGardens/ClimateCG.rds")) %>%  dplyr::select(cg,any_of(clim_var))
cg_coord <- readRDS(here("data/ClimaticData/CommonGardens/ClimateCG.rds")) %>% dplyr::select(cg,contains("ude"))
cg_names <- unique(cg_coord$cg)

# Generate scaled climatic datasets with climatic data at the location of the populations and at the location of the common gardens
cg_dfs <- generate_scaled_clim_datasets(clim_var, clim_pred = cg_clim)
  
# Predict genomic offset of each population when transplanted in the climate of the common gardens
snp_sets <- lapply(snp_sets, function(snp_set){

ref_pred <- predict(snp_set$gf_mod, as.data.frame(cg_dfs$clim_ref[,clim_var])) # predictions under reference-period climates
fut_pred <- predict(snp_set$gf_mod, as.data.frame(cg_dfs$clim_pred[,clim_var])) # predictions under climates during survey period

snp_set$go_cg <- lapply(1:nrow(ref_pred), function(x, ref_pred, fut_pred){
    as.numeric(pdist(ref_pred[x,],  fut_pred)@dist)}, fut_pred=fut_pred, ref_pred=ref_pred) %>% 
  setNames(cg_dfs$clim_ref[["pop"]]) %>% 
  as.data.frame() %>% 
  t() %>% 
  as.data.frame() %>% 
  set_colnames(cg_dfs$clim_pred[["cg"]]) %>% 
  rownames_to_column(var="pop") %>% 
  as_tibble()

return(snp_set)
})

# Map genomic offset predictions at the locations of the populations
go_maps_cg <- lapply(cg_names, function(cg_name){

# Find minimum and maximum values of genomic offset for the maps
go_limits <- lapply(snp_sets, function(snp_set) snp_set$go_cg[[cg_name]]) %>%  unlist() %>% range()
go_limits[[1]] <- 0

p <- lapply(snp_sets, function(x) make_go_map(dfcoord=pop_coord, 
                                              snp_set = x,
                                              point_size = 3,
                                              type="CG",
                                              go_limits = go_limits,
                                              cg_name=cg_name,
                                              cg_coord=cg_coord))

plot_grid(p[[1]],p[[2]],p[[3]],nrow=1)
  
}) %>% setNames(cg_names)

pdf(here("figs/GF/GOmaps_CGs.pdf"), width=15,height=6)
lapply(go_maps_cg, function(x) x)
dev.off()

# show maps
lapply(go_maps_cg, function(x) x)
```

We look at the correlation across the different genomic offset predictions in the common gardens, i.e. those based on all SNPs and those based on sets of candidates or control SNPs.

```{r CorrelationGOCommonGardens, fig.height=5,fig.width=14, results="hide"}
par(mfrow=c(1,3))

lapply(cg_names, function(cg_name){

lapply(snp_sets, function(x) x$go_cg) %>% 

lapply(function(set){
  set[[cg_name]]
}) %>% 
    as_tibble() %>% 
    cor() %>% 
    corrplot(method = 'number',type = 'lower', 
             diag = FALSE,mar=c(0,0,2,0),
             title=str_to_title(cg_name),
             number.cex=2,tl.cex=1.5)

})
```

Let's save the genomic offset predictions for comparison with the other methods.

```{r SaveGOpredictions}
snp_sets %>% saveRDS(file=here("outputs/GF/go_predictions.rds"))
```


# Session information

```{r SessionInfo}
devtools::session_info()
```


