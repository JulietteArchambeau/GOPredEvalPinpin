---
title: "Comparing genomic offset predictions"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    toc: true
    toc-depth: 4
    code-fold: true
    page-layout: full
embed-resources: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
body {
   font-size: 15px;
}
code.r{
  font-size: 11px;
}
pre {
  font-size: 11px
}

table {
  font-size: 11px
}
</style>

```{r setup, include=F}
knitr::opts_chunk$set(dev.args = list(png = list(type = "cairo")))
knitr::opts_chunk$set(cache=F, size="tiny")
options(width = 300)
library(knitr)      # CRAN v1.26
library(kableExtra) # CRAN v1.1.0
library(tidyverse)
library(here)
library(cowplot)
library(magrittr)
library(corrplot)

# my own function for building tables in reports
source(here("scripts/functions/kable_mydf.R"))
```

We compare the genomic offset predictions from the four following methods:

  - Generalized dissimilarity modelling (GDM). See report `9_GeneralizedDissimilarityModelling_GenomicOffsetPredictions.html`.
  
  - Latent factor mixed model (LFMM) . See report `7_LFMM_IdentificationCandidateSNPs_GenomicOffsetPredictions.html`.
  
  - Gradient Forest (GF). See report `10_GradientForest_GenomicOffsetPredictions.html`.
  
  - Redundancy analysis (RDA). See report `11_RedundancyAnalysis_GenomicOffsetPredictions.html`.
  
  
# Correlations

```{r BuildDataframeGOpredictions}
# Method names
meth_names <- c("GDM","LFMM","GF","RDA")

# population names
pop_names <- readRDS(here("data/GenomicData/MainGenePoolPopulations.rds")) %>%  arrange(pop) %>% pull(pop)

snp_sets <- readRDS(here("outputs/list_snp_sets.rds"))

# Load GO predictions
go_df <- lapply(meth_names, function(meth_name) {
  
readRDS(file=here(paste0("outputs/",meth_name,"/go_predictions.rds"))) %>% 
  lapply(function(snp_set) {

    as_tibble(snp_set$go) %>%
      mutate(pop=pop_names) %>% 
      pivot_longer(cols=-c(pop), names_to = "gcm", values_to = "go")
    }) %>% 
    bind_rows(.id="snp_set") %>% 
    mutate(go_scaled = (go - mean(go))/sd(go))


}) %>% 
  setNames(meth_names) %>% 
  bind_rows(.id="method")
```


```{r Corrplots, fig.height=5,fig.width=14, results="hide"}
par(mfrow=c(1,3))


lapply(unique(go_df$snp_set), function(x){
  
  lapply(unique(go_df$gcm), function(y){
    
go_df %>% 
      dplyr::filter(snp_set == x & gcm == y) %>% 
      pivot_wider(id_cols=pop, values_from = go, names_from = method) %>% 
      dplyr::select(-pop) %>% 
      cor() %>% 
      corrplot(method = 'number',type = 'lower', diag = FALSE,
               title=paste0(snp_sets[[x]]$set_name," - ",y),mar=c(0,0,2,0),
               number.cex=2,tl.cex=1.5)
  })
})
```

# Maps

```{r}
list_highpops <- list(LFMM = readRDS(here("outputs/LFMM/high_go_pops.rds"))[[2]],
                      RDA = readRDS(here("outputs/RDA/high_go_pops.rds"))[[2]],
                      GDM = readRDS(here("outputs/GDM/high_go_pops.rds"))[[2]],
                      GF = readRDS(here("outputs/GF/high_go_pops.rds"))[[2]])

list_highpops <- list(LFMM = readRDS(here("outputs/LFMM/high_go_pops.rds"))[[2]],
                      RDA = readRDS(here("outputs/LFMM/high_go_pops.rds"))[[2]],
                      GDM = readRDS(here("outputs/LFMM/high_go_pops.rds"))[[2]],
                      GF = readRDS(here("outputs/LFMM/high_go_pops.rds"))[[2]])

list_highpops[[1]] <- list_highpops[[1]] + theme(legend.position = "none")
list_highpops[[2]] <- list_highpops[[2]] + theme(legend.position = "none")
list_highpops[[3]] <- list_highpops[[3]] + theme(legend.position = "none")

plot_grid(plotlist = list_highpops, nrow=2)
```



