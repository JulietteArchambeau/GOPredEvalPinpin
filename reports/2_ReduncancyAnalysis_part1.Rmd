---
title: "Redundancy analysis - Part 1"
subtitle: "Climatic variable selection, variance partitionning & candidate SNPs identification"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output_dir: "docs"
output:
  bookdown::html_document2:
    df_print: kable
    fig.caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 4
    #toc_float:
    #  collapsed: no
editor_options:
  chunk_output_type: console
bibliography: references.bib
always_allow_html: true
---

```{css, echo=FALSE}
pre {
  max-height: 150px;
  overflow-y: auto;
  overflow-x: auto;
  font-size: 10px;
}

body{
  font-size: 12px;
}
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=F)
options(width = 300)
library(knitr)      # CRAN v1.26
library(kableExtra) # CRAN v1.1.0
library(dplyr)      # CRAN v1.0.0
library(psych)      # CRAN v1.8.12 (pairs.panels function)
library(tidyverse)  # CRAN v1.3.0
library(raster)     # CRAN v3.3-13
library(stringr)    # CRAN v1.4.0
library(ggbiplot)
library(corrplot)
library(vegan)
library(xtable)
library(reshape2)
library(robust)
library(qvalue)
library(ggpubr)
library(magrittr)
library(cowplot)
library(ggVennDiagram)

# my own function for building tables in reports
source("scripts/functions/kable_mydf.R")
```

```{r Functions, echo=F}
# Functions from other sources:
source("scripts/functions/corpmat.R") # to compute the matrix of p-value
source("scripts/functions/rdadapt.R") # to conduct a RDA based genome scan (from Capblancq & Forester 2021)
source("scripts/functions/detectoutliers.R") # to identify outliers based on their RDA loadings (from  Forester et al. 2018)

# Function to generate a corrplot
make_corrplot <- function(df,variables,fig_options){
  
  # correlation matrix
  cor <- cor(df[,variables]) 
  
  # matrix of the p-value of the correlation
  pmat <- corpmat(cor)

  # Generate a correlation plot
  png(filename=fig_options$path,
      width=fig_options$width,
      height=fig_options$height,
      res=fig_options$res)
  corrplot::corrplot(cor, 
                     method="color", 
                     col=colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))(200),
                     type="upper", 
                     order="hclust",
                     addCoef.col = "black", # Add coefficient of correlation
                     tl.col="black", 
                     tl.srt=45, #Text label color and rotation
                   
                     # Combine with significance
                     p.mat = pmat, 
                     sig.level = 0.01, 
                     insig = "blank",
                     
                     # hide correlation coefficient on the principal diagonal
                     diag=FALSE,
                     number.cex=0.6)
  dev.off()
  
}
```


# Introduction

Most analyses conducted in this document are based on:

  - @forester2018comparing and the associated [vignette](https://popgen.nescent.org/2018-03-27_RDA_GEA.html). 
  
  - @capblancq2021redundancy and the associated [Github repository](https://github.com/Capblancq/RDA-landscape-genomics).
  

RDA can either be performed on *individual-based genotypes* (i.e. allele counts 0, 1 or 2) or *population-based allele frequencies*. @forester2018comparing suggests to use individual-based allele counts when most samples have individual coordinates and individual environment data (which depends on the resolution of the environmental data across the study area). 

In the present study, we use *population-level allele frequencies* as several genotypes were collected at each sampling site (i.e. source population) and therefore experience the same climatic conditions. Moreover, the sample sizes varies across populations.

**Comment:** when I first conducted these analyses (in the third chapter of my PhD), I used *individual-based genotypes* because I accounted for the neutral population genetic structure with the ancestry coefficients from @jaramillo2015molecular, which are at the genotype level (i.e. proportion of gene pool assignment for each genotype). As the population genetic structure is highly confounded with the climatic gradients across the populations sampled (see section \@ref(VarPart)), correcting for population structure with the ancestry coefficient most likely resulted in overcorrection for population structure. In this document, we only use the *individual-based allele counts* for variance partitioning in section \@ref(VarPart), in which we estimate the relative contribution of climate, population structure and geography.

**Choices made in this document:**

  - Number of PC axes included in the RDA to account for the population genetic structure: see section \@ref(PCscores). 
  
```{r SetNbPCscores}
nb_PCscores <- 3
```

  
  - Number of distance-based Moran's eigen vector maps (dbMEMs) included in the variance partitioning to account for the effect of geography.
  
  
```{r SetNbdbMEMs}
nb_dbMEMs <- 4
```

  
# Downloading the data

## Genomic data


```{r LoadGenomicData}
# Individual-based allele counts
# ==============================
geno_ind <- read.csv("data/DryadRepo/ImputedGenomicData_AlleleCounts_NOMAF_454clones_9185snps.csv",row.names = 1) %>% 
  t() %>% 
  as.data.frame()

kable_mydf(geno_ind[1:10,1:10], boldfirstcolumn = T)


# Population-based allele frequencies
# ===================================
geno_pop <- read.csv("data/DryadRepo/ImputedGenomicData_AlleleFrequencies_NOMAF_34pops_9185snps.csv",
                     row.names = 1)

kable_mydf(geno_pop[1:10,1:10] %>% round(3), boldfirstcolumn = T)
```

The genomic dataset with *individual-based allele counts* contains `r nrow(geno_ind)` clones (i.e. genotypes) and `r ncol(geno_ind)` SNPs. The genomic dataset with *population-based allele frequencies* contains `r nrow(geno_pop)` populations and `r ncol(geno_pop)` SNPs.

RDA requires complete data frames (i.e., no missing data). Missing data were imputed based on the main gene pool of the clone, i.e. using the most common allele at each SNP (see report `1_FormattingGenomicData.Rmd`).

## Climatic data


### Load ClimateDT data 

Climatic data comes from the [Climate Downscaling Tool (ClimateDT)](https://www.ibbr.cnr.it/climate-dt/) and were extracted by Maurizio Marchi (CREA, Italy). The description of the climatic variables is available [here](https://www.ibbr.cnr.it/climate-dt/?action=fldlist).

**Reference period:** The climatic conditions at the location of the populations (i.e. climatic conditions under which the populations have evolved) correspond to the mean climatic conditions across the period 1901-1950 (i.e. average of annual climatic variables).


```{r LoadClimateDToutputs}
clim <- read_csv("data/DryadRepo/PopulationCoordinatesPastClimateInformation.csv",
               show_col_types = FALSE)

kable_mydf(clim[1:10,1:10], boldfirstcolumn = F)
```

The dataset contains geographical (coordinates and dbMEMs) and climatic information for the `r nrow(clim)` populations. 

### Filtering the climatic variables

```{r IdCorrelatedClimaticVariables}
# Function to identify climatic variable with a correlation coeff higher than a given threshold
identify_corr_var <- function(df,corr_threshold){

# calculate the correlation matrix among the variables
clim_cor <- df %>% 
  dplyr::select(-pop,-elevation,-contains("itude")) %>% 
  cor()

# attribute NA to the lower triangle and diagonal of the matrix
clim_cor[lower.tri(clim_cor,diag=T)] <- NA

# build a dataframe with the correlated variables
clim_cor <- clim_cor %>% 
  melt() %>% 
  na.omit() %>% 
  dplyr::filter(value>corr_threshold)

}

# we want to identify variables with a correlation coefficient higher than:
corr_threshold <- 0.95

# we ran the function to identify the highly correlated variables
clim_cor <- identify_corr_var(df=clim,corr_threshold = corr_threshold)

kable_mydf(clim_cor, boldfirstcolumn = F)
```

`r nrow(clim_cor)` pairs of variables have a correlation coefficient higher than `r corr_threshold`.

We remove some variables so that there are no more pairs of variables with a correlation coefficient greater than `r corr_threshold`.

We also remove the variables `MOP` and `AOP` because there is no metadata for these variables on the ClimateDT website.

We remove also some variables of low biological interest for maritime past adaptation or adaptation to future climate: `PAS` (precipitation as snow between August and July), `bio13` (precipitation of the wettest month).

When estimating exposure to climate change in section \@ref(ExpCC), we saw that `bFFP` has weird future climatic values, so we remove it also. 

We remove `EPQ` (Emberger Pluviometric Quotient) because there is very low information about this variable in the litterature and its possible influence on forest trees.

```{r FilteringClimVariables, results="hide"}
clim_var_to_rm <- c("bio7","TD", # we keep bio4
                    "bio6","bio11","EMT","NFFD","eFFP", # we keep MCMT
                    "GDD0","GDD5", # we keep bio1
                    "bio17","bio18","bio14", # we keep SP
                    "bio19","bio16", # we keep bio12
                    "bio2","CMD", # we keep Eref
                    "bio10", # we keep MWMT
                    "MOP","AOP", # we rm these variables because there is no metadata for them in the ClimateDT website!
                    "PAS","bio13", # low biological interest
                    "bFFP")

clim <- clim %>% dplyr::select(-all_of(clim_var_to_rm))

# we check that there are no more pairs of highly correlated variables
identify_corr_var(df=clim,corr_threshold = 0.95) %>% nrow()
```

### Viz 

We can look at the distribution of the climatic variables.

```{r PlotDistributionClimaticVariables, fig.height=9, fig.width=9}
p <- clim %>% 
  dplyr::select(-pop,-contains("itude"),-elevation) %>% 
  pivot_longer(everything(),names_to="variable") %>% 
  ggplot(aes(x=value)) +  
  geom_histogram(aes(y=after_stat(density)), colour="blue",fill="white",bins = 34) +
  geom_density(alpha=.2,fill="pink") +
  facet_wrap(~variable,scales="free") + 
  theme_bw() 

p %>% ggsave(file="figs/ExploratoryAnalyses/DistributionClimaticVariables_selected.png",
               width=15,height=12)

p
```

We also generate a correlation plot and perform a PCA to look at the correlation among the remaining climatic variables.

```{r CorrelationsPanels,fig.height=6,fig.width=6, results="hide"}
# Chunk to generate figures to visualize the correlations among the climatic variables
fig_options <- list(
  path = "figs/ExploratoryAnalyses/CorrplotClimVariables.png",
  width=1000,
  height=1000,
  res=100)

make_corrplot(df = clim,
              variables = colnames(clim)[-1], # we keep long, lat, elev and clim variables
              fig_options = fig_options)
```

![](../figs/ExploratoryAnalyses/CorrplotClimVariables.png)


```{r PCAClimVariables,fig.height=6,fig.width=6, results="hide"}
# Generate a PCA
pca <- prcomp(clim[,-1], center = TRUE,scale. = TRUE)

p <- ggbiplot(pca,varname.size =4) +  
  ylim(-4, 2.5) +    
  xlim(-3, 3) + 
  theme_minimal(base_size = 12)

ggsave(p,file="figs/ExploratoryAnalyses/PCAClimVariables.png",width=8,height=8,
       bg="white")
p
```



## Population genetic structure


### Ancestry coefficients

The proportion of gene pool assignment was estimated in @jaramillo2015molecular for each genotype with the *STRUCTURE* software.

```{r GenerateListDfIndividualLevel}
# We will store two datasets in a list: one with raw variables, the other one with mean-centered variables

listdf_ind <- list()

listdf_ind$df <- read.csv("data/DryadRepo/PopulationStructureCorrea2015.csv") %>% 
  filter(clon %in% rownames(geno_ind)) %>% # keep the same clones as in the genomic data
  unique() %>% 
  left_join(clim,by="pop") %>% # merge with the climatic variables
  dplyr::select(-max.Q) %>% 
  arrange(clon) # the clones have to be in the same order as in the genomic data.

# Run this line to check that the order of the clones in the genomic data and explanatory variables data is the same.
# identical(as.vector(listdf_ind$df$clon),rownames(geno_ind)) # should be TRUE 

listdf_ind$df[1:10,1:14] %>% 
  mutate(across(where(is.numeric), round, 2)) %>% 
  kable_mydf(boldfirstcolumn = F)


# create df with standardized variables (ie centered and scaled)
listdf_ind$dfsc <- listdf_ind$df %>% 
  dplyr::mutate(across(where(is.numeric), ~ (. - mean(.)) / sd(.)))

listdf_ind$dfsc[1:10,1:14] %>% 
  mutate(across(where(is.numeric), round, 2)) %>% 
  kable_mydf(boldfirstcolumn = F)
```


### PC scores{#PCscores}

Another way to account for population structure in the RDA models is to use PCs from a *principal component analysis* (PCA) as proxies of the population evolutionary history. This is the method used in @capblancq2021redundancy and @capblancq2023common.

As advised in @capblancq2021redundancy, the estimation of the population genetic structure should be performed on genomic data not filtered for minor allele frequencies because small genetic variations are expected to be involved in differentiating neutral genetic groups. So, we use *population-based allele frequencies* not filtered for MAF and imputed for missing data (based on the most common allele in the gene pool, see report `1_FormattingGenomicData.Rmd`).


```{r LoadImtGenDataMAF}
geno_pop_maf <-  read.csv("data/DryadRepo/ImputedGenomicData_AlleleFrequencies_MAF_34pops_9879snps.csv")

kable_mydf(geno_pop_maf[1:10,1:8], boldfirstcolumn = F)
```

We run the PCA with the `rda` function of the `vegan` package, which performs a PCA when no predictor is included.

```{r RunPCA, fig.height=4,fig.width=6}
pca <- rda(geno_pop_maf[,-1], scale=T)

# Screeplot of the PCA eigenvalues
screeplot(pca, type = "barplot", npcs=10, main="PCA Eigenvalues")
```

Based on the screeplot, retaining **three** or **four** PCs may be reasonable to account for neutral population structure in downstream analyses. 

<span style="color: red;">**We keep the first `r nb_PCscores` PCs.**</span>

```{r GenerateListDfPopLevelNotScaled}
# We store two datasets in a list: one with raw variables, the other one with mean-centered variables

listdf_pop <- list()

listdf_pop$df <- data.frame(pop = geno_pop_maf[,1], # population id
                            PCs = scores(pca, choices=c(1:3), display="sites", scaling="none")) %>% #
  setNames(c("pop", "PC1", "PC2", "PC3")) %>% 
  inner_join(clim, by="pop")


# extract mean and variance of the PC scores
listdf_pop$df %>% 
  dplyr::select(contains("PC")) %>% 
  dplyr::summarise(across(everything(),list(mean=mean,sd=sd))) %>% 
  pivot_longer(everything()) %>% 
  mutate(PC = str_sub(name,1,3),
         index = str_sub(name,5,-1)) %>%
  dplyr::select(-name) %>% 
  pivot_wider(names_from="index",values_from="value") %>% 
  kable_mydf(boldfirstcolumn = F)
```

The PC scores have a mean of O but a standard deviation of 0.2, so we scale them too so that they have the same standard deviation as the climatic variables.

```{r GenerateListDfPopLevelScaled}
listdf_pop$dfsc <- listdf_pop$df %>% 
  dplyr::mutate(across(where(is.numeric), ~ (. - mean(.)) / sd(.)))

kable_mydf(listdf_pop$dfsc[1:8,1:9], boldfirstcolumn = F)
```


### Population main gene pool

We extract the main gene pool for each population.

```{r IdAdmixturePopulations}
# Split into dataframes specific to each population
gp_pop <- listdf_ind$df %>% 
  dplyr::select(clon,pop) %>% 
  left_join(read.csv("data/DryadRepo/PopulationStructureCorrea2015.csv"), by=c("pop","clon")) %>% 
  group_by(pop) %>% 
  group_split() %>% 
  setNames(unique(sort(listdf_ind$df$pop)))

# Are there some populations for which the main gene pool is not the same for all genotypes?
gp_pop %>% 
  map_dfr(\(x) {
    data.frame(Populations = unique(x$pop),
               MainGenePoolNumber = x$max.Q %>% unique() %>% length())
  }) %>% 
  group_by(MainGenePoolNumber) %>% 
  group_split()  %>% 
  map_dfr(\(x) {
    data.frame(Populations = paste0(x$Populations, collapse =", "),
               MainGenePoolNumber = unique(x$MainGenePoolNumber))
  }) %>% 
  kable_mydf(boldfirstcolumn = F)
```


The LEI and QUA populations have genotypes that belong to two different main gene pool, the main gene pool corresponding to the gene pool with the highest proportion of assignment from the STRUCTURE analysis in @jaramillo2015molecular.

We can visualize the admixture in the following tables.


```{r AdmixturePopulations}
gp_pop[["LEI"]] %>% kable_mydf(boldfirstcolumn = F)
gp_pop[["QUA"]] %>% kable_mydf(boldfirstcolumn = F)
```


```{r CreateNewColumWithMainGenePoolPopulations}
gp_pop <- gp_pop %>% 
  modify(\(x) mutate(x, mainGPpop= x$max.Q  %>% table() %>% which.max() %>% names())) %>% 
  list_rbind() %>% 
  dplyr::select(pop, mainGPpop) %>% 
  distinct()

# We add this column to the dataframes in  listdf_pop
listdf_pop <- listdf_pop %>% 
  modify(\(x) right_join(gp_pop,x,by="pop"))

saveRDS(listdf_pop, "outputs/RDA/RDA_explanatorydataframes_PopLevel.rds")

kable_mydf(listdf_pop$dfsc[1:8,1:7], boldfirstcolumn = F)
```

```{r DefineMainGPcolor}
# Colors of the main gene pool for the following figures (PCA and RDA)
bg <- c("orangered3","gold2","darkorchid3","navyblue","turquoise2","green3") # define the colors
GPs <- listdf_pop$df$mainGPpop %>%  as.factor()
levels(GPs) <- list("Northern Africa" = "Q1",
                    "Corsica" = "Q2",
                    "Central Spain" = "Q3",
                    "French Atlantic" = "Q4",
                    "Iberian Atlantic" = "Q5",
                    "South-eastern Spain" = "Q6")
```


### Plot the PCA

We plot the PCA performed on **population-based allele frequencies not filtered for MAF** (section \@ref(PCscores)).

```{r PlotPCA, fig.width=10,fig.height=6, results="hide"}
pdf(width=10,"figs/ExploratoryAnalyses/PCAplot.pdf")
par(mfrow=c(1,2))
lapply(2:3, function(second_axis){
  plot(pca, type="n", scaling=3, choices=c(1,second_axis),
       xlab=paste0("PC1 (",round(summary(eigenvals(pca))[2,1]*100,2),"%)"),
       ylab=paste0("PC",second_axis," (",round(summary(eigenvals(pca))[2,second_axis]*100,2),"%)"))
  points(pca, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs], choices=c(1,second_axis))
  if(second_axis==3) legend("bottomright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
recordPlot()})
dev.off()
```


# Selecting the climatic variables

The selection procedure of the climatic variables is based on three criteria:

  - exposure to climate change.
  
  - strong contribution to explaining genetic variance.
  
  - biological relevance.
  
## Criteria 1: exposure to climate change{#ExpCC}

It may be relevant to include variables that will show in future years a **strong deviation** from their **current distribution** at the location of the study populations.

For each climatic variable, we estimate the mean $\mu_{ref}$ and standard deviation $\sigma_{ref}$ of its annual values between 1901 and 1950. We then compare its predicted mean climate value $X$ across the period 2041-2070 by calculating a Z-score such as: *Z-score* = $(X - \mu_{ref})/\sigma_{ref}$.

```{r CalculatingZscoreExposureCC, warning=F}
# we load and format the annual climatic values from ClimateDT between 1901 and 2041-2070.
raw_clim <-  read_csv("data/ClimaticData/MaritimePinePops/ClimateDT_cmip6_PopCoordinatesPreExtractionTab.csv",
               show_col_types = FALSE) %>% 
  dplyr::rename(pop=ID,
                year=Year,
                SP=MSP) %>% # replace mean summer precipitation by summer precipitation
  dplyr::mutate(pop= ifelse(pop=="VAL-VMQ", "VAL",pop)) %>%  # the VAL-VMQ population is referred as VAL in the present study
  dplyr::filter(pop %in% clim$pop) %>% # we keep only CLONAPIN pops
  dplyr::select(-contains("itude"), 
                -Elevation, 
                -contains("prc"), -contains("tmx"), -contains("tmn"), -contains("spi"), -contains("spei"), 
                -all_of(clim_var_to_rm))

# selected climatic variables
var_clim <- colnames(raw_clim)[!colnames(raw_clim) %in% c("pop", "year")]


# calculating the z-scores
zscores <- lapply(var_clim, function(x){
  
past_clim <- raw_clim %>% 
  dplyr::filter(year<1951) %>%  # keep 1901 to 1950
  dplyr::select(pop,all_of(x)) %>% 
  group_by(pop) %>% 
  dplyr::summarise_all(list(mean="mean",sd="sd"))

# z-scores
zscores <- raw_clim %>% 
  dplyr::filter(year=="2041-2070") %>% 
  dplyr::select(pop,year,all_of(x)) %>% 
  dplyr::rename(var=x) %>% 
  left_join(past_clim,by="pop") %>% 
  dplyr::mutate(zscore=(var-mean)/sd) %>% 
  dplyr::select(pop,year,zscore)
  
}) %>% 
  setNames(var_clim) %>% 
  bind_rows(.id="var") %>% 
  dplyr::left_join(gp_pop, by="pop") %>% 
  mutate(mainGPpop = case_when(mainGPpop == "Q1" ~ "Northern Africa",
                            mainGPpop == "Q2" ~ "Corsica",
                            mainGPpop == "Q3" ~ "Central Spain",
                            mainGPpop == "Q4" ~ "French Atlantic",
                            mainGPpop == "Q5" ~ "Iberian Atlantic",
                            mainGPpop == "Q6" ~ "South-eastern Spain")) %>% 
  mutate(mainGPpop=factor(mainGPpop, levels=c("Northern Africa",
                                              "Corsica",
                                              "Central Spain",
                                              "French Atlantic",
                                              "Iberian Atlantic",
                                              "South-eastern Spain")))
  

# we sort the average z-scores (across populations and years) to determine 
# which climatic variables have the highest abs(Z-scores)
abs_mean_zscore <- zscores %>% 
  spread(var,zscore) %>% 
  mutate_if(is.numeric,abs) %>%
  dplyr::select(all_of(var_clim)) %>% 
  dplyr::summarise_all("mean") %>% 
  gather(variable, value) %>% 
  arrange(value)
```

```{r ViolinPlotExposureCC, fig.cap="\\large Deviation of the 2041-2070 values of the climatic variables from the distribution of their values during the reference period 1901-1950. A point is specific to a given population. The two figures are the same, except that the y-axis of the second one has been cut to aid visualization.", fig.height=12,fig.width=10, fig.align="center", results="hide"}

# Violin plots
bg_color <- "gray44"

p1 <- zscores %>%
  mutate(var=factor(var,levels=c(abs_mean_zscore$variable))) %>% 
  ggplot(aes(x=var, y=zscore)) + 
  geom_hline(yintercept=0, color=bg_color) +
  geom_violin(alpha=0.2, fill="gray76", color=bg_color) + 
  geom_jitter(shape=16,aes(colour=mainGPpop),position=position_jitter(0.2),size=1) +
  scale_colour_manual(values = c("orangered3","gold2","darkorchid3","navyblue","turquoise2","green3")) +
  #coord_flip() +
  xlab("") + 
  ylab("Z-scores") +
  labs(colour="Main gene pool") +
  theme_bw() +
  theme(legend.position=c(0.15, 0.8),
        legend.title = element_text(size=14, color=bg_color),
        legend.text = element_text(size = 14, color=bg_color),
        axis.text = element_text(size = 14, color=bg_color),
        axis.title = element_text(size=16, color=bg_color),
        legend.box.background = element_rect(colour = bg_color),
        legend.background = element_rect(linewidth=0.4, color=bg_color)) + 
  guides(colour = guide_legend(override.aes = list(size=4))) 

# to aid visualization, we cut the y-axis
p2 <- p1 + 
  coord_cartesian(ylim = c(-50, 50)) +
  theme(legend.position = "none")

p <- ggarrange(p1, p2, nrow=2, labels=c("A)","B)"))

p %>% ggsave(file="figs/ExploratoryAnalyses/ExposureClimateChange.pdf", width=10,height=12)

p
```


```{r CalculatingZscoreExposureCCOldVersion,warning=F, echo=F, eval=F}
# Previous figure version with the future climatic variables extracted from the online ClimateDT, 
# and so based on the RCP scenarios

# Time window for future climates:
min_fut_clim <- 2023
max_fut_clim <- 2050

# Do we average the z-scores across future years?
avg <- FALSE

# We load ClimateDT outputs 
raw_clim <-  read_csv("data/DryadRepo/ClimateDT/ClimateDToutputs_Populations_1901_2098.csv",
               show_col_types = FALSE)

# selected clim variables
var_clim <- colnames(raw_clim)[!colnames(raw_clim) %in% c("ID","Year","Longitude","Latitude","Elevation",clim_var_to_rm)]


# calculating the z-scores
zscores <- lapply(var_clim, function(x){
  
past_clim <- raw_clim %>% 
  dplyr::filter(Year<1951) %>%  # keep 1901 to 1950
  dplyr::select(ID,all_of(x)) %>% 
  group_by(ID) %>% 
  dplyr::summarise_all(list(mean="mean",sd="sd"))

# z-scores
zcores <- raw_clim %>% 
  dplyr::filter(Year>min_fut_clim & Year<max_fut_clim) %>% 
  dplyr::select(ID,Year,all_of(x)) %>% 
  dplyr::rename(var=x) %>% 
  left_join(past_clim,by="ID") %>% 
  dplyr::mutate(zscore=(var-mean)/sd) 

if(avg==TRUE){
  zcores <-  zcores %>% 
    group_by(ID) %>% 
    dplyr::summarise_at("zscore","mean")
} else{
  zcores <-  zcores %>% 
    dplyr::select(ID,Year,zscore)
}
  
}) %>% 
  setNames(var_clim) %>% 
  bind_rows(.id="var") 

# we sort the average z-scores (across populations and years) to determine 
# which climatic variables have the highest abs(Z-scores)
abs_mean_zscore <- zscores %>% 
  spread(var,zscore) %>% 
  mutate_if(is.numeric,abs) %>%
  dplyr::select(all_of(var_clim)) %>% 
  dplyr::summarise_all("mean") %>% 
  gather(variable, value) %>% 
  arrange(value)


# Violin plots
p <- zscores %>%
  mutate(var=factor(var,levels=c(abs_mean_zscore$variable))) %>% 
  ggplot(aes(x=var, y=zscore)) + 
  geom_jitter(shape=16,aes(colour = Year),position=position_jitter(0.2),size=0.5) +
  geom_violin(alpha=0.2) + 
  scale_colour_gradient2(low = "blue", mid="yellow",high = "red",midpoint=(max_fut_clim+min_fut_clim)/2) +
  coord_flip() +
  xlab("") + ylab("Z-scores") +
  theme_bw() +
  theme(legend.position=c(0.8, 0.7),
        legend.title = element_text(size = 18),
        legend.text = element_text(size = 15),
        axis.text = element_text(size = 14),
        axis.title = element_text(size=16),
        legend.box.background = element_rect(colour = "black"))

p %>% ggsave(file="figs/ExploratoryAnalyses/ExposureClimateChange_old.png", width=10,height=10)
```

*Temperature*-related variables show the *highest deviations* from their distribution under the reference period 1901-1950 and also all show a consistent increase across populations and years.

*Precipitation*-related variables show *lower deviations* from their distribution under the reference period 1901-1950. Moreover, they do not show a consistent decrease across years and populations. 

For `AHM` (annual heat moisture index), the two populations of Northern Africa are predicted to show a very high increase for this variable. Even stronger for `GDD18`, some Iberian Atlantic populations are expected to show a strong increase for this variable. <span style="color: red;">**How reliable are these predictions?**</span>

**Notes on the graph interpretation:** Figure \@ref(fig:ViolinPlotExposureCC) quantifies the relative deviations of the values of the climate variables from their distribution over the reference period 1901-1950. The highest deviations of temperature-related variables do not imply that populations will be less affected by future changes in precipitation than in temperatures.  Indeed, for some climate variables, even minor changes can severely affect populations. For example, some populations may already be suffering from summer droughts and even a small decrease in precipitation could have dramatic consequences.

## Criteria 2: a predictive approach{#StepwiseSelection}

To select the climatic variables, we may also use a *predictive approach* using *RDA with stepwise selection*, where the goal is to *maximize the genetic variance* explained by a set of predictors [@capblancq2021redundancy].

For that, we use the selection procedure from the `ordiR2step` function of the package `vegan`. 

We have to specify two models:

  - a *null* model where the response is explained only by an intercept.

  - a *full* model including all variables. 
  
In the `ordi2step` function, the default criteria for including the variables is based on both *significance* of the newly selected variables, and the comparison of *adjusted variation* ($R^2_{adj}$) explained by the selected variables to $R^2_{adj}$ explained by the full model. If the new variable is not significant or the $R^2_{adj}$ of the model including this new variable does not exceed the $R^2_{adj}$ of the full model, the selection procedure stops.

We use the following stopping criteria: variable significance of p < 0.01 using 1000 permutations, and the $R^2_{adj}$ of the full model.

```{r NumberStewiseSelectionModels}
# How many iterations of the stepwise selection procedure do we perform?
nbmodels <- 100
```

We perform `r nbmodels` iterations of the stepwise selection procedure.

```{r StepwiseSelectionPopLevel, eval=F}
# we standardize the climatic variables
climsc <- clim %>% dplyr::mutate(across(where(is.numeric), ~ (. - mean(.)) / sd(.)))

# null model
rda_null <- rda(geno_pop ~ 1, climsc)

# formula full model
formula_full_model <- colnames(climsc)[!colnames((climsc)) %in% c("pop",
                                                                  "elevation","latitude","longitude",
                                                                  paste0("MEM",1:5))] %>% 
  paste(collapse= " + ") # climatic variables
formula_full_model <- paste0("geno_pop ~ ",formula_full_model) %>% as.formula()

# full model
rda_full <- rda(formula_full_model, climsc)

# Stepwise selection with ordiR2step function
sumstepwise <- lapply(1:nbmodels, function(x) {
  mod <- ordiR2step(rda_null, rda_full, Pin = 0.01, R2permutations = 1000, R2scope = T)
  return(names(mod$CCA$envcentre))}) %>% 
  setNames(paste0("model",1:nbmodels)) %>% 
  ldply(function(x) data.frame(variables=x),.id="models") %>%  
  dplyr::summarise(count(variables)) %>% 
  setNames(c("variable","count"))

saveRDS(sumstepwise,file=paste0("outputs/VariableSelection/SummaryStepwiseSelection_PopLevel_",nbmodels,"models.rds"))
```

```{r SummaryStepwiseSelection}
sumstepwise <- readRDS(file=paste0("outputs/VariableSelection/SummaryStepwiseSelection_PopLevel_",nbmodels,"models.rds"))

kable_mydf(sumstepwise, boldfirstcolumn = F)
```


According to the stepwise selection procedure, the climatic variables that maximize the variance of the genomic data are:
  
  - `bio3`: isothermality (`bio2`/`bio7`) (x100) (index) with `bio2` the mean diurnal range (mean of monthly (max temp - min temp)) and `bio7` the temperature annual range (`bio5`-`bio6`, with `bio5` the max temperature of warmest month and `bio6` the minimum temperature of the coldest month).
  
  - `AHM`: annual heat moisture index (in °C/mm): (`bio1`+10)/(`bio12`/1000))
  
  - `SHM`: summer heat moisture index (in °C/mm): `MWMT`/(`SP`/1000)
  
  - `bio9`: mean temperature of driest quarter (in °C)
  
  - `Eref`: Hargreaves reference evaporation (in mm)
  
  <!-- - `bio4`: temperature seasonality (standard deviation x100) (in °C). -->
  
  <!-- - `bio15`: precipitation seasonality (coefficient of Variation).  -->
  
**Comment:** `AHM`, `SHM` and `Eref` are among the climatic variables that will show the strongest changes under climate change (>> stronger exposure to climate change).


## Criteria 3: biological relevance to the study goals

Study goals:

  - *evaluate* the genomic offset predictions with different methods.
  
  - provide *GO estimates* for the studied populations to identify populations that will show the highest disruption of their current gene-environment relationships (those estimates will be provided based on the 'best performing' genomic offset predictions in the evaluation part).
  
It may be relevant not to select the same climatic variables for the different study goals and evaluation methods. 

### Climatic variables relevant for the evaluation part


> Evaluating genomic offset predictions with mortality data from common gardens after a strong summer drought

Differences among populations in their seedling survival in common gardens after a strong summer drought is likely to be mainly driven by their differences in adaptation to summer drought conditions. 

For this evaluation step, the genomic offset has to be calculated with climatic variables capturing the summer-drought conditions. It has also to be noted to even though the gene-environment relationships are estimated with a set of climatic variables incorporating summer drought related variables, these variables may not be important in explaining the genomic composition across the landscape and therefore may little contribute to the genomic offset predictions. 

Therefore, I think that this evaluation part requires that the genomic offset has to be estimated with a set of climatic variables including summer drought-related variables, and that these variables should contribute to some extent to the genomic offset predictions (i.e. contribute to explaining the current genomic composition across the landscape).

In the case where summer drought-related variables do not contribute much to the genomic composition across the landscape, it could be relevant to estimate a genomic offset based only on climatic variables capturing summer droughts, aka a *summer-drought genomic offset* (ie *summer drought GO*).



> Evaluating genomic offset predictions with height data from common gardens

Height of young trees in common gardens is likely to be impacted by both winter and summer conditions, and both temperature and precipitation conditions. 

Ideally, for this evaluation part, the genomic offset has to be estimated on a set of variables incorporating both summer drought conditions and mean climatic conditions across the whole year. 

<!-- on a set of variables capturing temperature and precipitation conditions across the whole year (ie *yearly-climate genomic offset*, *yearly-climate GO*). -->

It may still be interesting to compare height in common gardens with the *summer-drought GO* predictions. If the  *summer-drought GO* predictions are more associated with height in common gardens than *yearly-climate GO* predictions, it could mean that height is mostly impacted by summer conditions in the studied common gardens.

> Evaluating genomic offset predictions with mortality data from natural populations


In natural populations, climate change can *directly* impact tree mortality through more and more frequent and intense summer droughts. In contrast, an increase in winter temperatures is highly unlikely to *directly* impact the death of adult trees. However, increased temperatures in winter can benefit to pests and pathogens, which can *indirectly* impact tree death. Note here that in National Forest Inventories, a tree is not counted as dead if its death is attributed to pests. However, mortality is a multifactorial process and it can be very difficult (if not impossible) to determine the relative contributions of climate, pests and other factors to tree death.

Therefore, in this evaluation part, the genomic offset should be estimated with a set of climatic variables including both summer drought conditions and annual climatic conditions.

It may also be interesting to evaluate the association between *summer-drought GO* predictions and mortality rates in NFI to determine whether current mortality rates in natural populations may be *only* attributed to maladaptation to summer drought conditions.


> Evaluating genomic offset predictions with predictions from ecophysiological models

Comparing the genomic offset predictions with ecophysiological models such as Surreau would require including drought-related variables in the genomic offset estimations as Surreau predicts the **risk of hydraulic failure**.

<!-- I have to read the paper of Cailleux-Petit et al. to determine whether it is relevant to evaluate both *summer drought GO* and *yearly-climate GO* predictions. -->


### Climatic variables relevant for providing GO predictions

According to previous studies, maritime pine populations show strong patterns of adaption to temperatures, and especially cold temperatures (eg [@grivet2011molecular]). Under climate change, cold temperatures are expected to increase in average at the location of the studied populations (Figure \@ref(fig:ViolinPlotExposureCC)). An increase in cold temperatures is unlikely to directly negatively impact the fitness of adult trees but it may impact the survival of young trees, the reproductive ability and the impact of pests and pathogens. 

Thus, for the second objective of this paper (which is to provide GO estimates for the studied populations), whether or not to include winter conditions in GO predictions is a tricky question, for which there is probably no correct answer. 

## Selected variables

In the present document, variance partitioning and candidate SNP identification are performed for three sets of SNPs:

  - **Set 1**: **summer  drought-related variables**, which only include two climatic variables related to summer drought conditions.
  
  - **Set 2**: **yearly-climatic variables**, which include variables related the average climatic conditions across the whole year. This set include variables that were identified through the stepwise selection procedure (section \@ref(StepwiseSelection)) in preliminary analyses (i.e. based on climatic data extracted from ClimateDT with slightly different coordinates for some populations): `bio3`, `bio4` and `bio15`.
  
  - **Set 3**: both variables capturing **summer-drought** conditions and **average annual climatic** conditions. 


In preliminary analyses, I was unable to find a set of climate variables that incorporated both summer drought and annual climatic variables without the climate variables being too highly correlated. Thus, the variables in sets 1 and 2 cannot be grouped together because they have very high VIFs (variance inflation factors) in the RDA, indicating that their respective effects cannot be identified separately in the RDA. If we want to use those variables to estimate the genomic offset, we may have to go with sets 1 and 2 independantly and follow the the following workflow:

  - if the predictions of *summer-drought GO* or *yearly-climate GO* are consistently better across the different evaluation methods, then we will provide these GO predictions for the studied populations.
  
  - if the predictions of *summer-drought GO* or *yearly-climate GO* are not consistently better across the different evaluation parts, then we will provide both the *summer-drought GO* or *yearly-climate GO* predictions for the studied populations.
  

<span style="color: red;">However, I think that set 3 makes sense biologically, and integrates both summer and annual climatic conditions. So **I would suggest to use only set 3 in the following analyses**. But, we have to ask Maurizio if the strong deviations under future climates from the current distribution for `AHM` are reliable.</span> 

### Set 1: summer-drought climatic variables

Selected variables:

  - `SP`: summer (May-Sep) precipitation (in mm).
  
  - `MWMT`: the mean warmest month temperature (in °C).
  

`MWMT` will increase a lot under climate change => strong exposure to climate change (\@ref(fig:ViolinPlotExposureCC)).

```{r VizSelectedDroughtVar, fig.width=5,fig.height=5}
drought_var <- list(name="Summer-drought variables",
                   code="drought_var",
                   variables=c("SP","MWMT"))
```

### Set 2: yearly-climate variables

Selected variables:

  - `bio1`: mean annual temperature (in °C). 
  
  - `bio12`: annual precipitation (in mm).
  
  - `bio15`: precipitation seasonality (coefficient of Variation). 
  
  - `bio3`: isothermality (`bio2`/`bio7`) (x100) (index) with `bio2` the mean diurnal range (mean of monthly (max temp - min temp)) and `bio7` the temperature annual range (`bio5`-`bio6`, with `bio5` the max temperature of warmest month and `bio6` the minimum temperature of the coldest month).
  
  - `bio4`: temperature seasonality (standard deviation x100) (in °C). 
  

`bio1` will increase a lot under climate change => strong exposure to climate change (\@ref(fig:ViolinPlotExposureCC)).

```{r VizSelectedYearlyVar, fig.width=10,fig.height=10}
## Selected yearly-climate variables
yearly_var <- list(name="Yearly-climate variables",
                   code="yearly_var",
                   variables=c("bio1","bio12","bio15","bio3","bio4"))
```


### Set 3

**Incorporating both summer-drought climatic variables and yearly-climate variables.**

Selected variables:

  - `bio1`: mean annual temperature (in °C). 
  
  - `AHM`: annual heat moisture index (in °C/mm): (`bio1`+10)/(`bio12`/1000))
  
  - `SHM`: summer heat moisture index (in °C/mm): `MWMT`/(`SP`/1000)
  
  - `bio9`: mean temperature of driest quarter (in °C)
  
  - `Eref`: Hargreaves reference evaporation (in mm)
  
  - `bio3`: isothermality (`bio2`/`bio7`) (x100) (index) with `bio2` the mean diurnal range (mean of monthly (max temp - min temp)) and `bio7` the temperature annual range (`bio5`-`bio6`, with `bio5` the max temperature of warmest month and `bio6` the minimum temperature of the coldest month). 


```{r VizSelectedSet3var, fig.width=10,fig.height=10}
set3_var <- list(name="Set 3",
                 code="set3_var",
                 variables=c("AHM", "Eref", "SHM", "bio9", "bio1", "bio3"))
```


### Viz correlation

We can look at the correlation among variables and with the PCs scores and geographic variables.

```{r VizCorrSelectedVariables, fig.height=12,fig.width=12, results="hide"}
fig_options <- list(
  path = "figs/ExploratoryAnalyses/CorrplotSelectedClimVariables.png",
  width=900,
  height=900,
  res=100)

clim_var_selected <- c(drought_var$variables, 
                       yearly_var$variables,
                       set3_var$variables) %>% unique()

make_corrplot(df = listdf_pop$df,
              variables = c("longitude","latitude","PC1","PC2","PC3",clim_var_selected),
              fig_options = fig_options)

# listdf_pop$df %>%
#   dplyr::select(all_of(c("longitude","latitude","PC1","PC2","PC3",clim_var_selected))) %>%
#   unique() %>%
#   pairs.panels(scale=T,hist.col="palegreen1")
```

```{r ColorClimVar}
# Define the colors associated with each climatic variable for the following visualizations
color_clim_var <- c('#1f78b4','#a6cee3','#6a3d9a','#e31a1c','#33a02c','#ffff33','#fb9a99',
                    '#FF7FE6', '#FFB675', '#51FF74', '#B4FF32') %>% 
  setNames(clim_var_selected) 
```

### Export climatic variable names

We export the names of the climatic variables of interest in a list for other GEA analyses.

```{r ExportClimNames}
list(drought_var, yearly_var,set3_var) %>% 
  saveRDS("data/ClimaticData/NamesSelectedVariables.rds")
```


# Variance partitioning{#VarPart}

We want to disentangle the *relative contribution* of different factors in explaining genetic variation, namely:

  - *climate*, either captured by the *summer-drought* climate variables or the *yearly* climate variables.
  
  - *neutral population structure*, captured by the ancestry coefficients from @jaramillo2015molecular for the individual-based allele counts, or captured by the first `r nb_PCscores` PC scores for the **population-based allele frequencies**. 
  
  - *geography*, accounted for by the population coordinates (longitude and latitude) or by `r nb_dbMEMs` distance-based Moran's eigen vector maps. 
  
  

We will run:

  - one *full* RDA with all factors (population structure, environment and geographical distance), i.e. no variable conditioning.
  
  - three *partial* RDA in which the factor of interest is conditioned by the other two factors.
  

  
```{r FunctionVarPart}
var_part <- function(df_geno, select_clim_var, df_var, scale_rda, center_rda, geography, nb_dbMEMs){

# The df of the explanatory variables has to include only the variables included in the model
df_var <- df_var %>% 
  dplyr::select(all_of(select_clim_var$variables),
                starts_with("Q"),
                starts_with("PC"),
                ends_with("itude"),
                contains("MEM"))


# Build formulas of the RDA models
# ================================
form_clim_var <- paste(select_clim_var$variables,collapse= " + ") # climatic variables
form_pgs_var <- colnames(df_var) %>% stringr::str_subset("^Q|^PC") %>%  paste(collapse= " + ") # pop structure

if(geography=="coordinates"){
  form_geo_var <- colnames(df_var) %>% stringr::str_subset("itude") %>%  paste(collapse= " + ") # coordinates
} else {
  form_geo_var <- colnames(df_var) %>%  
    stringr::str_subset("MEM") %>%  
   `[`(1:nb_dbMEMs) %>% # keep only the n first MEMs
    paste(collapse= " + ") # coordinates
}

# complete model formulas
form_full_rda <- paste("df_geno ~ ",
                       paste(c(form_clim_var,form_pgs_var,form_geo_var),collapse=" + " )) %>% 
  as.formula()

form_clim_rda <- paste("df_geno ~ ",
                       form_clim_var,"+ Condition(",paste(c(form_pgs_var,form_geo_var),collapse=" + " ), ")") %>% 
  as.formula()

form_pgs_rda <- paste("df_geno ~ ",
                       form_pgs_var,"+ Condition(",paste(c(form_clim_var,form_geo_var),collapse=" + " ), ")") %>% 
  as.formula()

form.geo_rda <- paste("df_geno ~ ",
                       form_geo_var,"+ Condition(",paste(c(form_clim_var,form_pgs_var),collapse=" + " ), ")") %>% 
  as.formula()


# Run the RDA models
# ==================

# Full RDA
full_rda <- rda(form_full_rda, 
                data=df_var, 
                scale=scale_rda,
                center=center_rda) 
anova_full_rda <- anova(full_rda)

# Partial RDA: pure climatic model
clim_rda <- rda(form_clim_rda, 
                data=df_var, 
                scale=scale_rda,
                center=center_rda)
anova_clim_rda <- anova(clim_rda)

# Partial RDA: pure neutral population structure model
pgs_rda <- rda(form_pgs_rda, 
                data=df_var, 
                scale=scale_rda,
                center=center_rda)
anova_pgs_rda <- anova(pgs_rda)

# Partial RDA: pure geography model
geo_rda <- rda(form.geo_rda, 
                data=df_var, 
                scale=scale_rda,
                center=center_rda)
anova_geo_rda <- anova(geo_rda)


# Summary table
# =============

sum_tab_RDA <- tibble("RDA models"=c("Full model: Y ~ clim + geo + pgs.",
                      "Pure climate model: Y ~ clim | (geo + pgs)",
                      "Pure pop. gen. structure model: Y ~ pgs | (geo + clim)",
                      "Pure geography model: Y ~ geo | (pgs + clim)"),
       "Total exp. variance"=c(RsquareAdj(full_rda)[[1]],
              RsquareAdj(clim_rda)[[1]],
              RsquareAdj(pgs_rda)[[1]],
              RsquareAdj(geo_rda)[[1]]),
       "Relative exp. variance"=c(1,
                                  RsquareAdj(clim_rda)[[1]]/RsquareAdj(full_rda)[[1]],
                                  RsquareAdj(pgs_rda)[[1]]/RsquareAdj(full_rda)[[1]],
                                  RsquareAdj(geo_rda)[[1]]/RsquareAdj(full_rda)[[1]]),
       "P-value"=c(anova_full_rda[["Pr(>F)"]][[1]],
                   anova_clim_rda[["Pr(>F)"]][[1]],
                   anova_pgs_rda[["Pr(>F)"]][[1]],
                   anova_geo_rda[["Pr(>F)"]][[1]]))

# Export the table in latex
xtable(sum_tab_RDA, type = "latex",digits=2) %>% 
  print(file = paste("tables/VariancePartitioningRDA_",select_clim_var$code,".tex"), include.rownames=FALSE)

return(sum_tab_RDA)
}
```

## Individual-based allele counts{#VarPartInd}

I left this part in the document but I think we should only use the variance partitioning based on population-level allele frequencies.

```{r VartPartIndividualLevel, eval=F}
list_sum_var_part <- lapply(list(yearly_var,drought_var, set3_var), function(x){

  var_part(df_geno=geno_ind,
          select_clim_var=x,
          df_var=listdf_ind$dfsc %>% as_tibble(), 
          scale_rda=F,center_rda=F,
          geography="coordinates",
          nb_dbMEMs=nb_dbMEMs)
}) %>% setNames(c(yearly_var$name,
                  drought_var$name,
                  set3_var$name))

saveRDS(list_sum_var_part, file="outputs/RDA/SummaryVartPartIndividualLevel.rds")
```

```{r ShowSummaryVarPartIndividualLevel, eval=F}
list_sum_var_part <- readRDS(file="outputs/RDA/SummaryVartPartIndividualLevel.rds")

# yearly-climate variables
kable_mydf(list_sum_var_part[[1]], boldfirstcolumn = T)


# Summer-drought climatic variables
kable_mydf(list_sum_var_part[[2]], boldfirstcolumn = T)
```

## Population-based allele frequencies{#VarPartPop}


### Coordinates as proxies of geography

```{r SetGeographyCoordinates}
geography <- "coordinates"
```


```{r VartPartPopLevelCoordinates, eval=F}
list_sum_var_part <- lapply(list(yearly_var,drought_var,set3_var), function(x){
  
  var_part(df_geno=geno_pop,
           select_clim_var=x,
           df_var=listdf_pop$dfsc, 
           scale_rda=F,center_rda=F,
           geography = geography,
           nb_dbMEMs = nb_dbMEMs)
}) %>% setNames(c(yearly_var$name,
                  drought_var$name,
                  set3_var$name))

saveRDS(list_sum_var_part, file=paste0("outputs/RDA/SummaryVartPartPopLevel_",geography,".rds"))
```

```{r ShowSummaryVarPartPopLevelCoordinates, eval=T}
list_sum_var_part <- readRDS(file=paste0("outputs/RDA/SummaryVartPartPopLevel_",geography,".rds"))

# yearly-climate variables
kable_mydf(list_sum_var_part[[1]], boldfirstcolumn = T)


# summer-drought climatic variables
kable_mydf(list_sum_var_part[[2]], boldfirstcolumn = T)

# Set 3 climatic variables
kable_mydf(list_sum_var_part[[3]], boldfirstcolumn = T)
```


### dbMEMs as proxies of geography

We keep the first four dbMEMs.

```{r SetGeographyMEMs}
geography <- "dbMEMs"
```

```{r VartPartPopLevelMEMs, eval=F}
list_sum_var_part <- lapply(list(yearly_var,drought_var,set3_var), function(x){
  
  var_part(df_geno=geno_pop,
           select_clim_var=x,
           df_var=listdf_pop$dfsc, 
           scale_rda=F,center_rda=F,
           geography = geography,
           nb_dbMEMs = nb_dbMEMs)
}) %>% setNames(c(yearly_var$name,
                  drought_var$name,
                  set3_var$name))

saveRDS(list_sum_var_part, file=paste0("outputs/RDA/SummaryVartPartPopLevel_",geography,".rds"))
```

```{r ShowSummaryVarPartPopLevelMEMs, eval=T}
list_sum_var_part <- readRDS(file=paste0("outputs/RDA/SummaryVartPartPopLevel_",geography,".rds"))

# yearly-climate variables
kable_mydf(list_sum_var_part[[1]], boldfirstcolumn = T)

# summer-drought climatic variables
kable_mydf(list_sum_var_part[[2]], boldfirstcolumn = T)

# Set 3 climatic variables
kable_mydf(list_sum_var_part[[3]], boldfirstcolumn = T)
```


# Identifying loci under selection

  
## Run the RDA

We perform RDA models the six combinations of the three sets of selected climatic variables and accounting or not for the neutral genetic population structure. Here are the models that we run:

  - Allele frequencies ~ yearly climatic variables + Condition(PC1 + PC2 + PC3)
  
  - Allele frequencies ~ yearly climatic variables
  
  - Allele frequencies ~ drought-summer variables + Condition(PC1 + PC2 + PC3)
  
  - Allele frequencies ~ drought-summer variables 
  
  - Allele frequencies ~ set 3 variables + Condition(PC1 + PC2 + PC3)
  
  - Allele frequencies ~ set 3 variables 
  
    
RDA summary statistics are summarized in the pdfs `RDAsummary.pdf` and the RDA plots colored by gene pool are shown in the pdfs `RDAplots.pdf`.

The RDA summary plots show that the set with all climatic variables has very high Variance inflated factors, and that's why I decided to use two different sets of variables. 

```{r FunctionToRunRDAmodels}
# =========
# FUNCTIONS
# =========


# Function to create a S3 object with the RDA model and some info
# ===============================================================
new_RDA <- function(form_rda,selected_var,PCs,mod_rda,r2,eigenvalues,model_significance,axis_significance,vif){
  
  structure(
    .Data = list(form_rda=form_rda,
                 selected_var=selected_var,
                 PCs=PCs,
                 mod_rda=mod_rda,
                 r2=r2,
                 eigenvalues=eigenvalues,
                 model_significance=model_significance,
                 axis_significance=axis_significance,
                 vif=vif),
    creation_time = Sys.time(),
    class = "myrda"
  )
  }



# Function to print S3 object of class 'myrda'
# ============================================
print.myrda <- function(x,...){

  print_message <- c(
    paste0("  RDA formula: ", x$form_rda),
    paste0("  Creation time: ", format(attr(x, "creation_time"))),
    paste0(c("  List elements:", names(x)),collapse="   ")
    )

  cat(
    print_message,
    sep = "\n"
  )

}


# Function to run the RDA models and store the info in a S3 object of class 'myrda'
# =================================================================================
runRDA <- function(df,geno_pop,selected_var,pop_structure_correction){


  
  # write RDA formulas
form_clim_var <- paste(selected_var$variables,collapse= " + ")
if(pop_structure_correction==T) {
  PCs <- colnames(df) %>% stringr::str_subset("^PC")
  form_pgs_var <- PCs %>%  paste(collapse= " + ")
  form_rda <- paste("geno_pop ~ ", form_clim_var,"+ Condition(",paste(c(form_pgs_var),collapse=" + " ), ")")
} else {
  PCs = NULL
  form_rda <- paste("geno_pop ~ ", form_clim_var) 
  }
mod_rda <- rda(as.formula(form_rda), df)
r2 <- RsquareAdj(mod_rda)
eigenvalues <- summary(eigenvals(mod_rda, model = "constrained"))
model_significance <- anova.cca(mod_rda, parallel=getOption("mc.cores")) # default is permutation=999
axis_significance <- anova.cca(mod_rda, by="axis", parallel=getOption("mc.cores"))
vif <- vif.cca(mod_rda)

return(new_RDA(form_rda=form_rda,
               selected_var=selected_var,
               PCs=PCs,
               mod_rda=mod_rda,
               r2=r2,
               eigenvalues=eigenvalues,
               model_significance=model_significance,
               axis_significance=axis_significance,
               vif=vif))
  
}



# Function to generate a pdf with the RDA model outputs
# =====================================================
viz_RDAsummary <- function(x){
  
  # check the class of x
  stopifnot("x is not of class myrda" = class(x)=="myrda")
  
  # Generate R2 table
r2_tab <- x$r2 %>% 
  as.data.frame() %>%
  pivot_longer(everything()) %>%  
  column_to_rownames(var ="name") %>% 
  round(2) %>% 
  ggtexttable(rows = row.names(.),cols = NULL, theme = ttheme("blank"))
  
  # Generate table of eigenvalues and proportion of variance explained
eigenvalues_tab <- x$eigenvalues %>% 
  as.data.frame() %>% 
  round(2) %>% 
  ggtexttable(rows = rownames(.), theme = ttheme("blank")) %>% 
  tab_add_hline(at.row = 1:2, row.side = "top", linewidth = 2)

  # Generate table of model and axis significance
signi_tab <- bind_rows(as.data.frame(x$model_significance[-nrow(x$model_significance),]),
          as.data.frame(x$axis_significance[-nrow(x$axis_significance),])) %>% 
  dplyr::mutate(across(!Df, ~ round(.x,3))) %>% 
  ggtexttable(rows = rownames(.), theme = ttheme("blank")) %>% 
  tab_add_hline(at.row = 1:2, row.side = "top", linewidth = 2) %>% 
  tab_add_hline(at.row = 3, row.side = "top", linewidth = 0.01)

  # Generate table for VIF (Variance Inflation Factors)
vif_tab <- x$vif %>% 
  as.data.frame() %>% 
  round(2) %>% 
  rownames_to_column("Variable") %>%
  pivot_wider(values_from=".", names_from = "Variable") %>% 
  ggtexttable(rows = "VIF", theme = ttheme("blank")) %>% 
  tab_add_hline(at.row = 2, row.side = "top", linewidth = 2) 
  
  # Generate the screeplot of the eigenvalues
ggscreeplot <- x$eigenvalues %>% #
  as.data.frame() %>% 
  dplyr::filter(row.names(.) == "Eigenvalue")  %>% 
  pivot_longer(everything(),names_to="PC",values_to="eigenvalues") %>%
  ggplot(aes(x= PC,
             y=eigenvalues,
             group=1)) +
  geom_point(size=4)+
  geom_line() +
  ylab("Eigen values") + xlab("") + 
  labs(title="Scree plot") + 
  theme_bw()


ggarrange(ggarrange(r2_tab,signi_tab,vif_tab,nrow=3),
           ggarrange(eigenvalues_tab,ggscreeplot,nrow=2), 
           nrow = 1, 
           ncol = 2) %>% 
annotate_figure(top = text_grob(x$form_rda, 
                                size = 16, 
                                color = 'black', 
                                face = 'bold'))
  
}


# Function to plot the RDA models
# ==============================
plot_RDA <- function(df,x,GPs){
  
  # check the class of x
  stopifnot("x is not of class myrda" = class(x)=="myrda")
  
  if(x$axis_significance %>% as.data.frame() %>% nrow()-1>2) {
  par(mfrow=c(1,2))
  rdaplots <-  lapply(2:3, function(second_axis){
    plot(x$mod_rda, type="n", scaling=3, choices=c(1,second_axis))
    points(x$mod_rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3, choices=c(1,second_axis))
    points(x$mod_rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs], choices=c(1,second_axis))
    text(x$mod_rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,second_axis))
    if(second_axis==2) legend("topleft", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
    recordPlot()
  })} else {
    par(mfrow=c(1,1))
    plot(x$mod_rda, type="n", scaling=3, choices=c(1,2))
    points(x$mod_rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3, choices=c(1,2))
    points(x$mod_rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs], choices=c(1,2))
    text(x$mod_rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,2))
    legend("bottomright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
  }
  
  title(x$form_rda, line=-3,outer = TRUE)
}
```



```{r RunRDAmodels, eval=F, results="hide"}
# We store in a list the four combinations of: 
  # - the two sets of selected climatic variables
  # - correction or not by population structure
rda_combinations <- list(
  list(selected_var = yearly_var,
       pop_structure_correction = FALSE),
  list(selected_var = yearly_var,
       pop_structure_correction = TRUE),
  list(selected_var = drought_var,
       pop_structure_correction = FALSE),
  list(selected_var = drought_var,
       pop_structure_correction = TRUE),
  list(selected_var = set3_var,
       pop_structure_correction = FALSE),
  list(selected_var = set3_var,
       pop_structure_correction = TRUE))


# Run the RDA models and store their information
rda_models <- lapply(rda_combinations, function(x){
  runRDA(df = listdf_pop$dfsc,
         geno_pop = geno_pop,
         selected_var = x$selected_var,
         pop_structure_correction = x$pop_structure_correction)})

# save the RDA models and their information
saveRDS(rda_models, "outputs/RDA/RDAmodels.rds")

# viz RDA models and their summary information
pdf(width = 13, height = 6, "figs/RDA/RDAsummary.pdf")
lapply(rda_models, viz_RDAsummary)
dev.off()

# plot RDA models
pdf(width = 12, height = 8, "figs/RDA/RDAplots.pdf")
lapply(rda_models, function(x) plot_RDA(df=listdf_pop$dfsc,x=x,GPs=GPs))
dev.off()
```



## Identify outliers

Two ways of identifying the outliers with the RDA:

  - identifying outliers based on their *extremeness* along a *distribution of Mahalanobis distances* estimated between each locus and the center of the RDA space using a certain number of axes (K). Method used in @capblancq2020climate (see [code](https://github.com/Capblancq/Local-Adaptation-Fagus-sylvatica)) and @capblancq2021redundancy ([code](https://github.com/Capblancq/RDA-landscape-genomics)). To conduct the RDA-based genome scan, we use the `rdadapt` function from @capblancq2021redundancy.

  - identifying RDA outliers is to search for *extreme loadings on each retained axis*. Method used in @forester2018comparing (see [code](https://popgen.nescent.org/2018-03-27_RDA_GEA.html)
  

```{r echo=F}
# !!! Temporary chunk !!!
rda_models <- readRDS("outputs/RDA/RDAmodels.rds")
listdf_pop <- readRDS("outputs/RDA/RDA_explanatorydataframes_PopLevel.rds")
```

  
```{r FunctionToIdentifyOutliers}
# ====================================
# Function to identify the outlier SNPs
# =====================================

identify_outliers <- function(rda_model, explanatory_data, geno_data){

# outlier detection based on  extreme Mahalanobis distances from the RDA center
# =============================================================================

# Genome scan with K = 2 (degrees of freedom of the X2 distribution)
GSout <- rdadapt(rda_model$mod_rda, 2) %>%  # rdadapt is a function to conduct a RDA based genome scan (from Capblancq & Forester 2021)
  mutate(snp=colnames(geno_data)) 

# P-values threshold after Bonferroni correction
outliers_maha <- GSout %>% 
  filter(pvalues <  0.01/length(pvalues)) %>% 
  mutate(maha_meth = TRUE) %>% 
  dplyr::select(snp,maha_meth) # we do not keep the p.values and q.values in the outlier table


# outlier detection based on  extreme axis loadings
# =================================================

# As we identify the SNPs that has loadings along the significant axes,
# we first extract the number of significant axes 
nb_signi_axis <- rda_model$axis_significance %>% 
  as.data.frame() %>% 
  dplyr::rename(pvalue="Pr(>F)") %>% 
  dplyr::filter(pvalue<0.05) %>% 
  nrow()
  
loads <- scores(rda_model$mod_rda, choices=c(1:(nrow(as.data.frame(rda_model$axis_significance))-1)), display="species")
  

outliers_loads <- lapply(1:nb_signi_axis, function(id.axis){
  out <- detectoutliers(loads[,id.axis],3) # function to identify outliers based on their RDA loadings (from  Forester et al. 2018)
  tibble(
    #axis=rep(id.axis,times=length(out)), # we do not keep the information about the axis
    snp = names(out),
    load_meth = TRUE,
    # loading = out # we do not keep the loadings
  )
}) %>% 
  list_rbind() %>% 
  distinct()



# Merge outliers identified by the two methods
# ============================================

all_outliers <- full_join(outliers_maha,outliers_loads, by="snp") %>% 
  mutate(across(c(maha_meth,load_meth), ~replace_na(.,FALSE)))

all_outliers <- map(all_outliers$snp, function(snp){
 cordf <-  cor(explanatory_data[,names(rda_model$vif)],geno_data[,snp]) %>% 
    as.data.frame() %>% 
    rownames_to_column() %>% 
    pivot_wider(names_from="rowname", values_from = "V1") %>% 
     mutate(max_var = names(which.max(abs(.)))) %>% 
     mutate(max_var_clim = names(which.max(abs(.[,rda_model$selected_var$variables]))))
}) %>%
  setNames(all_outliers$snp) %>% 
  list_rbind(names_to = "snp") %>% 
  inner_join(all_outliers,by="snp")


list(rda_model = rda_model,
     GSout = GSout, # keep the p.values for the Manhattan plot
     outliers = all_outliers)

}
```

```{r IdentifyOutliers}
# we identify the outlier SNPs for the four RDA models
rda_outliers <- rda_models %>% 
  lapply(function(x) {
    identify_outliers(rda_model = x, explanatory_data = listdf_pop$dfsc, geno_data = geno_pop)
  })

saveRDS(rda_outliers, "outputs/RDA/RDA_outliers.rds")
```

## Outlier visualization


### RDA plots based on Forester et al. (2018)

We visualize the outliers with RDA plots following @forester2018comparing (see [code](https://popgen.nescent.org/2018-03-27_RDA_GEA.html)). Figures are stored in `RDAplots_outliers_1.pdf`.

```{r FunctionToPlotRDAoutliers}
# Function to make one RDA plot with different colors for outlier SNPs
make_one_outlier_rda_plot <- function(mod_rda, data_plots, xlim, ylim, second_axis,arrow_length,outline_col){
  
plot(mod_rda, type="n", scaling=3, xlim=xlim, ylim=ylim, choices=c(1,second_axis))
points(mod_rda, display="species", pch=21, cex=1, col=data_plots$allsnps$nooutlier_color, bg=data_plots$allsnps$nooutlier_bg , scaling=3, choices=c(1,second_axis))
points(mod_rda, display="species", pch=21, cex=1, col=data_plots$allsnps$outlier_color, bg=data_plots$allsnps$outlier_bg, scaling=3, choices=c(1,second_axis))
text(mod_rda, scaling=3, display="bp", col="#0868ac", cex=1, arrow.mul=arrow_length, choices=c(1,second_axis))
legend("topleft", legend=data_plots$legend_names, bty="n", col=outline_col, pch=21, cex=1, pt.bg=data_plots$legend_colors,ncol=1,title=data_plots$legend_title) 
recordPlot()

}




# Function that combines two types of plot:
  # plots in which outliers are colored according to their most associated climatic variable
  # plots in which outliers are colored according to the detection method used to identify them:
      # a method based on the Mahalanobis distances from the center of the RDA space
      # a method based on the extreme SNP loadings on each significant axis
combine_rda_outlier_plots <- function(rda_out,color_clim_var){

# Storing data and options to generate the plots in a list
list_data_plots <- list(clim=list(), # options/data specific to plots with colors based on the climatic variables
                        meth=list()) # options/data specific to plots with colors based on the detection methods


# Figure options shared between the two types of plot
# ===================================================

nooutliers_bg <- '#f1eef6'
outline_col <- 'gray32'
transparent_col <- rgb(0,1,0, alpha=0)


  
# Fig options/data specific to plots based on the climatic variables
# ==================================================================

# Attribute one color to each climatic variable 
selected_var_colors <- tibble(max_var_clim = names(color_clim_var),
                              outlier_bg = color_clim_var) %>% 
  dplyr::filter(max_var_clim %in% rda_out$rda_model$selected_var$variables)

# Generate a dataframe with color information for outliers
outlier_colors <-  rda_out$outliers %>% 
  dplyr::select(snp, max_var_clim) %>% 
  left_join(selected_var_colors, by="max_var_clim")
 
# Generate a dataframe with color information for all SNPs
list_data_plots$clim$allsnps <- tibble(snp=rownames(rda_out$rda_model$mod_rda$CCA$v)) %>% 
  left_join(outlier_colors, by="snp") %>% 
  mutate(outlier_bg = replace_na(outlier_bg,transparent_col),
         outlier_color = ifelse(outlier_bg == transparent_col, transparent_col, outline_col),
         nooutlier_bg = ifelse(outlier_bg == transparent_col, nooutliers_bg, transparent_col),
         nooutlier_color = ifelse(outlier_bg == transparent_col, outline_col, transparent_col))

# Legend options
list_data_plots$clim$legend_title <- 'Climatic variable'
list_data_plots$clim$legend_names <- selected_var_colors$max_var_clim
list_data_plots$clim$legend_colors <- selected_var_colors$outlier_bg

  
# Fig options/data specific to plots based on the detection methods
# =================================================================

# Attribute one color to each method
method_colors <- c('#FCF926','#3BCD24','#CD24B2') %>% setNames(c("Mahalanobis distance","Axis loadings", "Both"))

# Legend options
list_data_plots$meth$legend_colors <- method_colors
list_data_plots$meth$legend_names <- names(method_colors)
list_data_plots$meth$legend_title <- 'Outlier detection method'


# attribute colors to all SNPs
list_data_plots$meth$allsnps <-  tibble(snp=rownames(rda_out$rda_model$mod_rda$CCA$v)) %>% 
  left_join(rda_out$outliers[,c("snp", "load_meth", "maha_meth")],by="snp") %>%  
  mutate(outlier_bg = case_when(load_meth == TRUE & maha_meth == TRUE ~ method_colors["Both"],
                                load_meth == TRUE & maha_meth == FALSE ~ method_colors["Axis loadings"],
                                load_meth == FALSE & maha_meth == TRUE ~ method_colors["Mahalanobis distance"],
                                is.na(load_meth) & is.na(maha_meth) ~ transparent_col),
         outlier_color = ifelse(outlier_bg == transparent_col, transparent_col, outline_col),
         nooutlier_bg = ifelse(outlier_bg == transparent_col, nooutliers_bg, transparent_col),
         nooutlier_color = ifelse(outlier_bg == transparent_col, outline_col, transparent_col))


# Generate the RDA plots
# =====================

# For RDA models with 2 explanatory variables, we can only plot RDA1 vs RDA2

if(rda_out$rda_model$axis_significance %>% as.data.frame() %>% nrow()-1>2) { # rda models with more than 2 climatic variables
    
par(mfrow=c(2,2))
lapply(2:3, function(second_axis){ # generate two plots: RDA1 vs RDA2 and RDA1 vs RDA3
    lapply(list_data_plots, function(x) make_one_outlier_rda_plot(mod_rda = rda_out$rda_model$mod_rda,
                                                                  data_plots = x,
                                                                  xlim=c(-1,1), 
                                                                  ylim=c(-0.5,0.5),
                                                                  arrow_length=1.25,
                                                                  outline_col=outline_col,
                                                                  second_axis=second_axis))

  })} else {  # rda models with 2 climatic variables

par(mfrow=c(1,2))
    lapply(list_data_plots, function(x) make_one_outlier_rda_plot(mod_rda = rda_out$rda_model$mod_rda,
                                                                  data_plots = x,
                                                                  xlim=c(-0.3,0.3), 
                                                                  ylim=c(-0.5,0.5),
                                                                  outline_col=outline_col,
                                                                  arrow_length=0.6,
                                                                  second_axis=2))
    
  }

  title(rda_out$rda_model$form_rda, line=-3,outer = TRUE) # rda model formula as title
   
}
```



```{r PlotRDAoutliers, results='hide'}
# Plot RDA outliers with different colors based either on the detection method or the most associated climatic variable
pdf(width = 12, height = 8, "figs/RDA/RDAplots_outliers_1.pdf")
lapply(rda_outliers, function(x) combine_rda_outlier_plots(rda_out = x,color_clim_var = color_clim_var))
dev.off()
```


### RDA plots based on Capblancq and Forester (2021)


We visualize the outliers with RDA and Manhattan plots following @capblancq2021redundancy ([code](https://github.com/Capblancq/RDA-landscape-genomics)). Figures are stored in `RDAplots_outliers_2.pdf`.


```{r FunctionToGGPlotRDAoutliers}
make_rda_ggplot <- function(data_plots,TAB_var){ 

  data_plots$tab[order(data_plots$tab$snp_type),] %>% 
  ggplot() +
  geom_hline(yintercept=0, linetype="dashed", color = gray(.80), linewidth=0.6) +
  geom_vline(xintercept=0, linetype="dashed", color = gray(.80), linewidth=0.6) +
  geom_point(aes(x=RDA1*20, y=RDA2*20, colour = snp_type), size = 1.4) +
  scale_color_manual(values = data_plots$legend_colors) +
  geom_segment(data = TAB_var, aes(xend=RDA1, yend=RDA2, x=0, y=0), 
               colour="black", linewidth=0.15, linetype=1, arrow=arrow(length = unit(0.02, "npc"))) +
  geom_text(data = TAB_var, aes(x=1.1*RDA1, y=1.1*RDA2, label = row.names(TAB_var)), size = 2.5) +
  xlab("RDA 1") + ylab("RDA 2") +
  facet_wrap(~"RDA space") +
  guides(color=guide_legend(title=data_plots$legend_title)) +
  theme_bw(base_size = 11) +
  theme(panel.background = element_blank(), 
        legend.background = element_blank(), 
        panel.grid = element_blank(), 
        plot.background = element_blank(), 
        legend.text=element_text(size=rel(.8)), 
        strip.text = element_text(size=11))
  
  
  
}

make_manhattan_plot <- function(data_plots){ 

data_plots$tab[order(data_plots$tab$snp_type),] %>% 
ggplot() +
  geom_hline(yintercept=-log10(0.01/length(data_plots$tab$pvalues)), linetype="dashed", color = gray(.80), linewidth=0.6) +
  geom_point(aes(x=pos, y=-log10(pvalues), col = snp_type), size=1.4) +
  scale_color_manual(values = data_plots$legend_colors) +
  xlab("Loci") + ylab("-log10(p-values)") +
  facet_wrap(~"Manhattan plot", nrow = 3) +
  guides(color=guide_legend(title=data_plots$legend_title)) +
  theme_bw(base_size = 11, base_family = "Times") +
  theme(legend.position="right", legend.background = element_blank(), panel.grid = element_blank(), legend.box.background = element_blank(), plot.background = element_blank(), panel.background = element_blank(), legend.text=element_text(size=rel(.8)), strip.text = element_text(size=11))
  }


# Function that combines two types of plot:
  # plots in which outliers are colored according to their most associated climatic variable
  # plots in which outliers are colored according to the detection method used to identify them:
      # a method based on the Mahalanobis distances from the center of the RDA space
      # a method based on the extreme SNP loadings on each significant axis
combine_rda_outlier_ggplots <- function(rda_out,color_clim_var){

# Storing data and options to generate the plots in a list
list_data_plots <- list(clim=list(), # options/data specific to plots with colors based on the climatic variables
                        meth=list()) # options/data specific to plots with colors based on the detection methods


# Figure options shared between the two types of plot
# ===================================================

nooutliers_bg <- "gray90"
nooutliers_legend <- "No detection"

locus_scores <- scores(rda_out$rda_model$mod_rda, choices=c(1:2), 
                       display="species", # 'species' in the vegan package correspond to the loci
                       scaling="none") %>% 
  as.data.frame() %>% 
  rownames_to_column("snp") %>% 
  as_tibble() %>% 
  inner_join(rda_out$GSout, by="snp") %>% 
  mutate(pos=seq(1:nrow(.)))

TAB_var <- as.data.frame(scores(rda_out$rda_model$mod_rda, choices=c(1,2), display="bp"))
  
# Fig options/data specific to plots based on the climatic variables
# ==================================================================

# Legend options
vec_color_clim_var <- color_clim_var[names(color_clim_var) %in% unique(rda_out$outliers$max_var_clim)]
list_data_plots$clim$legend_title <- 'Climatic variable'
list_data_plots$clim$legend_names <- c(nooutliers_legend,names(vec_color_clim_var))
list_data_plots$clim$legend_colors <- c(nooutliers_bg,vec_color_clim_var) %>% unname()


list_data_plots$clim$tab <-  locus_scores %>% 
  left_join(rda_out$outliers[,c("snp", "max_var_clim")],by="snp") %>%  
  mutate(max_var_clim = replace_na(max_var_clim,nooutliers_legend)) %>% 
  mutate(max_var_clim =factor(max_var_clim,levels=list_data_plots$clim$legend_names)) %>% 
  dplyr::rename(snp_type = max_var_clim)


# Fig options/data specific to plots based on the detection methods
# =================================================================


# Legend options
list_data_plots$meth$legend_colors <- c(nooutliers_bg,'#FCF926','#3BCD24','#CD24B2')
list_data_plots$meth$legend_names <- c(nooutliers_legend,"Mahalanobis distance","Axis loadings", "Both")
list_data_plots$meth$legend_title <- 'Outlier detection'


list_data_plots$meth$tab <-   locus_scores %>% 
  left_join(rda_out$outliers[,c("snp", "load_meth", "maha_meth")],by="snp") %>%  
  mutate(snp_type = case_when(load_meth == TRUE & maha_meth == TRUE ~  list_data_plots$meth$legend_names[[4]],
                              load_meth == TRUE & maha_meth == FALSE ~ list_data_plots$meth$legend_names[[3]],
                              load_meth == FALSE & maha_meth == TRUE ~ list_data_plots$meth$legend_names[[2]],
                              is.na(load_meth) & is.na(maha_meth) ~ list_data_plots$meth$legend_names[[1]])) %>% 
  mutate(snp_type=factor(snp_type,levels=list_data_plots$meth$legend_names)) 



# Generate the RDA plots
# =====================


p1 <- lapply(list_data_plots, function(x) make_rda_ggplot(data_plots = x,
                                                         TAB_var=TAB_var))

p2 <- lapply(list_data_plots, function(x) make_manhattan_plot(data_plots = x))

plot_row <- plot_grid(p1$clim, p1$meth,p2$clim,p2$meth, ncol=2)

# Title options
title <- ggdraw() + 
  draw_label(
    rda_out$rda_model$form_rda,
    fontface = 'bold',
    x = 0,
    hjust = 0
  ) +
  theme(
    # add margin on the left of the drawing canvas,
    # so title is aligned with left edge of first plot
    plot.margin = margin(0, 0, 0, 7)
  )

# merge title and plots
plot_grid(
  title, plot_row,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
)

   
}
```

```{r GGPlotRDAoutliers, results='hide'}
# Plot RDA outliers with different colors based either on the detection method or the most asspciated climatic variable
pdf(width = 12, height = 8, "figs/RDA/RDAplots_outliers_2.pdf")
lapply(rda_outliers, function(x) combine_rda_outlier_ggplots(rda_out = x, color_clim_var=color_clim_var))
dev.off()
```


## Common outliers

We identify the common outliers among the four RDA models with Venn diagrams. 

```{r VennDiagramOutliers, fig.height=7, fig.width=9, message=F}
venn_diagrams <- lapply(list(1:2,2:3,4:5), function(x) 
  list("Raw climate" = rda_outliers[[x[1]]]$outliers$snp,
       "Climate corrected by PS" = rda_outliers[[x[2]]]$outliers$snp) %>% 
  ggVennDiagram(lty="solid", size=0.2) + 
  scale_fill_gradient2(low = "white", high = 'gray40') + 
  scale_color_manual(values = c("grey", "grey", "grey", "grey","grey","grey")) + 
  guides(fill = "none") + 
  theme(text = element_text(size=16)) + 
  scale_x_continuous(expand = expansion(mult = .2))) %>% 
  setNames(c(yearly_var$name,
           drought_var$name,
           set3_var$name))

venn_diagrams <- ggarrange(venn_diagrams[[1]],
                           venn_diagrams[[2]],
                           venn_diagrams[[3]],
                           labels=names(venn_diagrams))

ggsave("figs/RDA/VennDiagramOutliers.pdf",venn_diagrams, width = 9, height=7)

venn_diagrams
```


# References
